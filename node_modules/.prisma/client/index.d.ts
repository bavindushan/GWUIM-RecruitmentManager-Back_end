
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model additionalinfo
 * 
 */
export type additionalinfo = $Result.DefaultSelection<Prisma.$additionalinfoPayload>
/**
 * Model admin
 * 
 */
export type admin = $Result.DefaultSelection<Prisma.$adminPayload>
/**
 * Model application
 * 
 */
export type application = $Result.DefaultSelection<Prisma.$applicationPayload>
/**
 * Model applicationattachments
 * 
 */
export type applicationattachments = $Result.DefaultSelection<Prisma.$applicationattachmentsPayload>
/**
 * Model applicationgeneraldetails
 * 
 */
export type applicationgeneraldetails = $Result.DefaultSelection<Prisma.$applicationgeneraldetailsPayload>
/**
 * Model applicationreferences
 * 
 */
export type applicationreferences = $Result.DefaultSelection<Prisma.$applicationreferencesPayload>
/**
 * Model applicationtemplate
 * 
 */
export type applicationtemplate = $Result.DefaultSelection<Prisma.$applicationtemplatePayload>
/**
 * Model auditlog
 * 
 */
export type auditlog = $Result.DefaultSelection<Prisma.$auditlogPayload>
/**
 * Model employmenthistories
 * 
 */
export type employmenthistories = $Result.DefaultSelection<Prisma.$employmenthistoriesPayload>
/**
 * Model experiencedetails
 * 
 */
export type experiencedetails = $Result.DefaultSelection<Prisma.$experiencedetailsPayload>
/**
 * Model gce_al_results
 * 
 */
export type gce_al_results = $Result.DefaultSelection<Prisma.$gce_al_resultsPayload>
/**
 * Model gce_ol_results
 * 
 */
export type gce_ol_results = $Result.DefaultSelection<Prisma.$gce_ol_resultsPayload>
/**
 * Model jobvacancy
 * 
 */
export type jobvacancy = $Result.DefaultSelection<Prisma.$jobvacancyPayload>
/**
 * Model languageproficiencies
 * 
 */
export type languageproficiencies = $Result.DefaultSelection<Prisma.$languageproficienciesPayload>
/**
 * Model professionalqualifications
 * 
 */
export type professionalqualifications = $Result.DefaultSelection<Prisma.$professionalqualificationsPayload>
/**
 * Model researchandpublications
 * 
 */
export type researchandpublications = $Result.DefaultSelection<Prisma.$researchandpublicationsPayload>
/**
 * Model specialqualifications
 * 
 */
export type specialqualifications = $Result.DefaultSelection<Prisma.$specialqualificationsPayload>
/**
 * Model superadmin
 * 
 */
export type superadmin = $Result.DefaultSelection<Prisma.$superadminPayload>
/**
 * Model universityeducations
 * 
 */
export type universityeducations = $Result.DefaultSelection<Prisma.$universityeducationsPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const applicationtemplate_Type: {
  Academic: 'Academic',
  Non_Academic: 'Non_Academic'
};

export type applicationtemplate_Type = (typeof applicationtemplate_Type)[keyof typeof applicationtemplate_Type]


export const auditlog_ActorRole: {
  Admin: 'Admin',
  SuperAdmin: 'SuperAdmin'
};

export type auditlog_ActorRole = (typeof auditlog_ActorRole)[keyof typeof auditlog_ActorRole]


export const jobvacancy_Type: {
  Academic: 'Academic',
  Non_Academic: 'Non_Academic'
};

export type jobvacancy_Type = (typeof jobvacancy_Type)[keyof typeof jobvacancy_Type]


export const languageproficiencies_CanSpeak: {
  Very_Good: 'Very_Good',
  Good: 'Good',
  Fair: 'Fair',
  None: 'None'
};

export type languageproficiencies_CanSpeak = (typeof languageproficiencies_CanSpeak)[keyof typeof languageproficiencies_CanSpeak]


export const application_Status: {
  New: 'New',
  In_Reviewing: 'In_Reviewing',
  Called_for_Interview: 'Called_for_Interview',
  Hired: 'Hired',
  Rejected: 'Rejected'
};

export type application_Status = (typeof application_Status)[keyof typeof application_Status]


export const languageproficiencies_CanRead: {
  Very_Good: 'Very_Good',
  Good: 'Good',
  Fair: 'Fair',
  None: 'None'
};

export type languageproficiencies_CanRead = (typeof languageproficiencies_CanRead)[keyof typeof languageproficiencies_CanRead]


export const languageproficiencies_CanWrite: {
  Very_Good: 'Very_Good',
  Good: 'Good',
  Fair: 'Fair',
  None: 'None'
};

export type languageproficiencies_CanWrite = (typeof languageproficiencies_CanWrite)[keyof typeof languageproficiencies_CanWrite]


export const applicationgeneraldetails_Gender: {
  Male: 'Male',
  Female: 'Female',
  Other: 'Other'
};

export type applicationgeneraldetails_Gender = (typeof applicationgeneraldetails_Gender)[keyof typeof applicationgeneraldetails_Gender]


export const languageproficiencies_CanTeach: {
  Very_Good: 'Very_Good',
  Good: 'Good',
  Fair: 'Fair',
  None: 'None'
};

export type languageproficiencies_CanTeach = (typeof languageproficiencies_CanTeach)[keyof typeof languageproficiencies_CanTeach]


export const user_AccountStatus: {
  Active: 'Active',
  Suspended: 'Suspended',
  Deleted: 'Deleted'
};

export type user_AccountStatus = (typeof user_AccountStatus)[keyof typeof user_AccountStatus]


export const jobvacancy_Status: {
  Open: 'Open',
  Closed: 'Closed'
};

export type jobvacancy_Status = (typeof jobvacancy_Status)[keyof typeof jobvacancy_Status]


export const applicationgeneraldetails_CitizenshipType: {
  Descent: 'Descent',
  Registration: 'Registration'
};

export type applicationgeneraldetails_CitizenshipType = (typeof applicationgeneraldetails_CitizenshipType)[keyof typeof applicationgeneraldetails_CitizenshipType]

}

export type applicationtemplate_Type = $Enums.applicationtemplate_Type

export const applicationtemplate_Type: typeof $Enums.applicationtemplate_Type

export type auditlog_ActorRole = $Enums.auditlog_ActorRole

export const auditlog_ActorRole: typeof $Enums.auditlog_ActorRole

export type jobvacancy_Type = $Enums.jobvacancy_Type

export const jobvacancy_Type: typeof $Enums.jobvacancy_Type

export type languageproficiencies_CanSpeak = $Enums.languageproficiencies_CanSpeak

export const languageproficiencies_CanSpeak: typeof $Enums.languageproficiencies_CanSpeak

export type application_Status = $Enums.application_Status

export const application_Status: typeof $Enums.application_Status

export type languageproficiencies_CanRead = $Enums.languageproficiencies_CanRead

export const languageproficiencies_CanRead: typeof $Enums.languageproficiencies_CanRead

export type languageproficiencies_CanWrite = $Enums.languageproficiencies_CanWrite

export const languageproficiencies_CanWrite: typeof $Enums.languageproficiencies_CanWrite

export type applicationgeneraldetails_Gender = $Enums.applicationgeneraldetails_Gender

export const applicationgeneraldetails_Gender: typeof $Enums.applicationgeneraldetails_Gender

export type languageproficiencies_CanTeach = $Enums.languageproficiencies_CanTeach

export const languageproficiencies_CanTeach: typeof $Enums.languageproficiencies_CanTeach

export type user_AccountStatus = $Enums.user_AccountStatus

export const user_AccountStatus: typeof $Enums.user_AccountStatus

export type jobvacancy_Status = $Enums.jobvacancy_Status

export const jobvacancy_Status: typeof $Enums.jobvacancy_Status

export type applicationgeneraldetails_CitizenshipType = $Enums.applicationgeneraldetails_CitizenshipType

export const applicationgeneraldetails_CitizenshipType: typeof $Enums.applicationgeneraldetails_CitizenshipType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Additionalinfos
 * const additionalinfos = await prisma.additionalinfo.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Additionalinfos
   * const additionalinfos = await prisma.additionalinfo.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.additionalinfo`: Exposes CRUD operations for the **additionalinfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Additionalinfos
    * const additionalinfos = await prisma.additionalinfo.findMany()
    * ```
    */
  get additionalinfo(): Prisma.additionalinfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.adminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.application`: Exposes CRUD operations for the **application** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applications
    * const applications = await prisma.application.findMany()
    * ```
    */
  get application(): Prisma.applicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.applicationattachments`: Exposes CRUD operations for the **applicationattachments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applicationattachments
    * const applicationattachments = await prisma.applicationattachments.findMany()
    * ```
    */
  get applicationattachments(): Prisma.applicationattachmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.applicationgeneraldetails`: Exposes CRUD operations for the **applicationgeneraldetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applicationgeneraldetails
    * const applicationgeneraldetails = await prisma.applicationgeneraldetails.findMany()
    * ```
    */
  get applicationgeneraldetails(): Prisma.applicationgeneraldetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.applicationreferences`: Exposes CRUD operations for the **applicationreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applicationreferences
    * const applicationreferences = await prisma.applicationreferences.findMany()
    * ```
    */
  get applicationreferences(): Prisma.applicationreferencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.applicationtemplate`: Exposes CRUD operations for the **applicationtemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applicationtemplates
    * const applicationtemplates = await prisma.applicationtemplate.findMany()
    * ```
    */
  get applicationtemplate(): Prisma.applicationtemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditlog`: Exposes CRUD operations for the **auditlog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auditlogs
    * const auditlogs = await prisma.auditlog.findMany()
    * ```
    */
  get auditlog(): Prisma.auditlogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employmenthistories`: Exposes CRUD operations for the **employmenthistories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employmenthistories
    * const employmenthistories = await prisma.employmenthistories.findMany()
    * ```
    */
  get employmenthistories(): Prisma.employmenthistoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.experiencedetails`: Exposes CRUD operations for the **experiencedetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Experiencedetails
    * const experiencedetails = await prisma.experiencedetails.findMany()
    * ```
    */
  get experiencedetails(): Prisma.experiencedetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gce_al_results`: Exposes CRUD operations for the **gce_al_results** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gce_al_results
    * const gce_al_results = await prisma.gce_al_results.findMany()
    * ```
    */
  get gce_al_results(): Prisma.gce_al_resultsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gce_ol_results`: Exposes CRUD operations for the **gce_ol_results** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gce_ol_results
    * const gce_ol_results = await prisma.gce_ol_results.findMany()
    * ```
    */
  get gce_ol_results(): Prisma.gce_ol_resultsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobvacancy`: Exposes CRUD operations for the **jobvacancy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobvacancies
    * const jobvacancies = await prisma.jobvacancy.findMany()
    * ```
    */
  get jobvacancy(): Prisma.jobvacancyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.languageproficiencies`: Exposes CRUD operations for the **languageproficiencies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languageproficiencies
    * const languageproficiencies = await prisma.languageproficiencies.findMany()
    * ```
    */
  get languageproficiencies(): Prisma.languageproficienciesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.professionalqualifications`: Exposes CRUD operations for the **professionalqualifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Professionalqualifications
    * const professionalqualifications = await prisma.professionalqualifications.findMany()
    * ```
    */
  get professionalqualifications(): Prisma.professionalqualificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.researchandpublications`: Exposes CRUD operations for the **researchandpublications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Researchandpublications
    * const researchandpublications = await prisma.researchandpublications.findMany()
    * ```
    */
  get researchandpublications(): Prisma.researchandpublicationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.specialqualifications`: Exposes CRUD operations for the **specialqualifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Specialqualifications
    * const specialqualifications = await prisma.specialqualifications.findMany()
    * ```
    */
  get specialqualifications(): Prisma.specialqualificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.superadmin`: Exposes CRUD operations for the **superadmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Superadmins
    * const superadmins = await prisma.superadmin.findMany()
    * ```
    */
  get superadmin(): Prisma.superadminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.universityeducations`: Exposes CRUD operations for the **universityeducations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Universityeducations
    * const universityeducations = await prisma.universityeducations.findMany()
    * ```
    */
  get universityeducations(): Prisma.universityeducationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    additionalinfo: 'additionalinfo',
    admin: 'admin',
    application: 'application',
    applicationattachments: 'applicationattachments',
    applicationgeneraldetails: 'applicationgeneraldetails',
    applicationreferences: 'applicationreferences',
    applicationtemplate: 'applicationtemplate',
    auditlog: 'auditlog',
    employmenthistories: 'employmenthistories',
    experiencedetails: 'experiencedetails',
    gce_al_results: 'gce_al_results',
    gce_ol_results: 'gce_ol_results',
    jobvacancy: 'jobvacancy',
    languageproficiencies: 'languageproficiencies',
    professionalqualifications: 'professionalqualifications',
    researchandpublications: 'researchandpublications',
    specialqualifications: 'specialqualifications',
    superadmin: 'superadmin',
    universityeducations: 'universityeducations',
    user: 'user'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "additionalinfo" | "admin" | "application" | "applicationattachments" | "applicationgeneraldetails" | "applicationreferences" | "applicationtemplate" | "auditlog" | "employmenthistories" | "experiencedetails" | "gce_al_results" | "gce_ol_results" | "jobvacancy" | "languageproficiencies" | "professionalqualifications" | "researchandpublications" | "specialqualifications" | "superadmin" | "universityeducations" | "user"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      additionalinfo: {
        payload: Prisma.$additionalinfoPayload<ExtArgs>
        fields: Prisma.additionalinfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.additionalinfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$additionalinfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.additionalinfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$additionalinfoPayload>
          }
          findFirst: {
            args: Prisma.additionalinfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$additionalinfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.additionalinfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$additionalinfoPayload>
          }
          findMany: {
            args: Prisma.additionalinfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$additionalinfoPayload>[]
          }
          create: {
            args: Prisma.additionalinfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$additionalinfoPayload>
          }
          createMany: {
            args: Prisma.additionalinfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.additionalinfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$additionalinfoPayload>
          }
          update: {
            args: Prisma.additionalinfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$additionalinfoPayload>
          }
          deleteMany: {
            args: Prisma.additionalinfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.additionalinfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.additionalinfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$additionalinfoPayload>
          }
          aggregate: {
            args: Prisma.AdditionalinfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdditionalinfo>
          }
          groupBy: {
            args: Prisma.additionalinfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdditionalinfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.additionalinfoCountArgs<ExtArgs>
            result: $Utils.Optional<AdditionalinfoCountAggregateOutputType> | number
          }
        }
      }
      admin: {
        payload: Prisma.$adminPayload<ExtArgs>
        fields: Prisma.adminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.adminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.adminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findFirst: {
            args: Prisma.adminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.adminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findMany: {
            args: Prisma.adminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          create: {
            args: Prisma.adminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          createMany: {
            args: Prisma.adminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.adminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          update: {
            args: Prisma.adminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          deleteMany: {
            args: Prisma.adminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.adminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.adminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.adminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.adminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      application: {
        payload: Prisma.$applicationPayload<ExtArgs>
        fields: Prisma.applicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.applicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.applicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationPayload>
          }
          findFirst: {
            args: Prisma.applicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.applicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationPayload>
          }
          findMany: {
            args: Prisma.applicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationPayload>[]
          }
          create: {
            args: Prisma.applicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationPayload>
          }
          createMany: {
            args: Prisma.applicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.applicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationPayload>
          }
          update: {
            args: Prisma.applicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationPayload>
          }
          deleteMany: {
            args: Prisma.applicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.applicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.applicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationPayload>
          }
          aggregate: {
            args: Prisma.ApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplication>
          }
          groupBy: {
            args: Prisma.applicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.applicationCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationCountAggregateOutputType> | number
          }
        }
      }
      applicationattachments: {
        payload: Prisma.$applicationattachmentsPayload<ExtArgs>
        fields: Prisma.applicationattachmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.applicationattachmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationattachmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.applicationattachmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationattachmentsPayload>
          }
          findFirst: {
            args: Prisma.applicationattachmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationattachmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.applicationattachmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationattachmentsPayload>
          }
          findMany: {
            args: Prisma.applicationattachmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationattachmentsPayload>[]
          }
          create: {
            args: Prisma.applicationattachmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationattachmentsPayload>
          }
          createMany: {
            args: Prisma.applicationattachmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.applicationattachmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationattachmentsPayload>
          }
          update: {
            args: Prisma.applicationattachmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationattachmentsPayload>
          }
          deleteMany: {
            args: Prisma.applicationattachmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.applicationattachmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.applicationattachmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationattachmentsPayload>
          }
          aggregate: {
            args: Prisma.ApplicationattachmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplicationattachments>
          }
          groupBy: {
            args: Prisma.applicationattachmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationattachmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.applicationattachmentsCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationattachmentsCountAggregateOutputType> | number
          }
        }
      }
      applicationgeneraldetails: {
        payload: Prisma.$applicationgeneraldetailsPayload<ExtArgs>
        fields: Prisma.applicationgeneraldetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.applicationgeneraldetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationgeneraldetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.applicationgeneraldetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationgeneraldetailsPayload>
          }
          findFirst: {
            args: Prisma.applicationgeneraldetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationgeneraldetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.applicationgeneraldetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationgeneraldetailsPayload>
          }
          findMany: {
            args: Prisma.applicationgeneraldetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationgeneraldetailsPayload>[]
          }
          create: {
            args: Prisma.applicationgeneraldetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationgeneraldetailsPayload>
          }
          createMany: {
            args: Prisma.applicationgeneraldetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.applicationgeneraldetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationgeneraldetailsPayload>
          }
          update: {
            args: Prisma.applicationgeneraldetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationgeneraldetailsPayload>
          }
          deleteMany: {
            args: Prisma.applicationgeneraldetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.applicationgeneraldetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.applicationgeneraldetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationgeneraldetailsPayload>
          }
          aggregate: {
            args: Prisma.ApplicationgeneraldetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplicationgeneraldetails>
          }
          groupBy: {
            args: Prisma.applicationgeneraldetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationgeneraldetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.applicationgeneraldetailsCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationgeneraldetailsCountAggregateOutputType> | number
          }
        }
      }
      applicationreferences: {
        payload: Prisma.$applicationreferencesPayload<ExtArgs>
        fields: Prisma.applicationreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.applicationreferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.applicationreferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationreferencesPayload>
          }
          findFirst: {
            args: Prisma.applicationreferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.applicationreferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationreferencesPayload>
          }
          findMany: {
            args: Prisma.applicationreferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationreferencesPayload>[]
          }
          create: {
            args: Prisma.applicationreferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationreferencesPayload>
          }
          createMany: {
            args: Prisma.applicationreferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.applicationreferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationreferencesPayload>
          }
          update: {
            args: Prisma.applicationreferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationreferencesPayload>
          }
          deleteMany: {
            args: Prisma.applicationreferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.applicationreferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.applicationreferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationreferencesPayload>
          }
          aggregate: {
            args: Prisma.ApplicationreferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplicationreferences>
          }
          groupBy: {
            args: Prisma.applicationreferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.applicationreferencesCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationreferencesCountAggregateOutputType> | number
          }
        }
      }
      applicationtemplate: {
        payload: Prisma.$applicationtemplatePayload<ExtArgs>
        fields: Prisma.applicationtemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.applicationtemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationtemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.applicationtemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationtemplatePayload>
          }
          findFirst: {
            args: Prisma.applicationtemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationtemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.applicationtemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationtemplatePayload>
          }
          findMany: {
            args: Prisma.applicationtemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationtemplatePayload>[]
          }
          create: {
            args: Prisma.applicationtemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationtemplatePayload>
          }
          createMany: {
            args: Prisma.applicationtemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.applicationtemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationtemplatePayload>
          }
          update: {
            args: Prisma.applicationtemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationtemplatePayload>
          }
          deleteMany: {
            args: Prisma.applicationtemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.applicationtemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.applicationtemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationtemplatePayload>
          }
          aggregate: {
            args: Prisma.ApplicationtemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplicationtemplate>
          }
          groupBy: {
            args: Prisma.applicationtemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationtemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.applicationtemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationtemplateCountAggregateOutputType> | number
          }
        }
      }
      auditlog: {
        payload: Prisma.$auditlogPayload<ExtArgs>
        fields: Prisma.auditlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auditlogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auditlogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          findFirst: {
            args: Prisma.auditlogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auditlogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          findMany: {
            args: Prisma.auditlogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>[]
          }
          create: {
            args: Prisma.auditlogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          createMany: {
            args: Prisma.auditlogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.auditlogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          update: {
            args: Prisma.auditlogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          deleteMany: {
            args: Prisma.auditlogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.auditlogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.auditlogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          aggregate: {
            args: Prisma.AuditlogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditlog>
          }
          groupBy: {
            args: Prisma.auditlogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.auditlogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditlogCountAggregateOutputType> | number
          }
        }
      }
      employmenthistories: {
        payload: Prisma.$employmenthistoriesPayload<ExtArgs>
        fields: Prisma.employmenthistoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.employmenthistoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employmenthistoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.employmenthistoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employmenthistoriesPayload>
          }
          findFirst: {
            args: Prisma.employmenthistoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employmenthistoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.employmenthistoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employmenthistoriesPayload>
          }
          findMany: {
            args: Prisma.employmenthistoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employmenthistoriesPayload>[]
          }
          create: {
            args: Prisma.employmenthistoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employmenthistoriesPayload>
          }
          createMany: {
            args: Prisma.employmenthistoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.employmenthistoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employmenthistoriesPayload>
          }
          update: {
            args: Prisma.employmenthistoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employmenthistoriesPayload>
          }
          deleteMany: {
            args: Prisma.employmenthistoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.employmenthistoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.employmenthistoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employmenthistoriesPayload>
          }
          aggregate: {
            args: Prisma.EmploymenthistoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmploymenthistories>
          }
          groupBy: {
            args: Prisma.employmenthistoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmploymenthistoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.employmenthistoriesCountArgs<ExtArgs>
            result: $Utils.Optional<EmploymenthistoriesCountAggregateOutputType> | number
          }
        }
      }
      experiencedetails: {
        payload: Prisma.$experiencedetailsPayload<ExtArgs>
        fields: Prisma.experiencedetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.experiencedetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencedetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.experiencedetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencedetailsPayload>
          }
          findFirst: {
            args: Prisma.experiencedetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencedetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.experiencedetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencedetailsPayload>
          }
          findMany: {
            args: Prisma.experiencedetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencedetailsPayload>[]
          }
          create: {
            args: Prisma.experiencedetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencedetailsPayload>
          }
          createMany: {
            args: Prisma.experiencedetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.experiencedetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencedetailsPayload>
          }
          update: {
            args: Prisma.experiencedetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencedetailsPayload>
          }
          deleteMany: {
            args: Prisma.experiencedetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.experiencedetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.experiencedetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencedetailsPayload>
          }
          aggregate: {
            args: Prisma.ExperiencedetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExperiencedetails>
          }
          groupBy: {
            args: Prisma.experiencedetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExperiencedetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.experiencedetailsCountArgs<ExtArgs>
            result: $Utils.Optional<ExperiencedetailsCountAggregateOutputType> | number
          }
        }
      }
      gce_al_results: {
        payload: Prisma.$gce_al_resultsPayload<ExtArgs>
        fields: Prisma.gce_al_resultsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.gce_al_resultsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gce_al_resultsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.gce_al_resultsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gce_al_resultsPayload>
          }
          findFirst: {
            args: Prisma.gce_al_resultsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gce_al_resultsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.gce_al_resultsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gce_al_resultsPayload>
          }
          findMany: {
            args: Prisma.gce_al_resultsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gce_al_resultsPayload>[]
          }
          create: {
            args: Prisma.gce_al_resultsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gce_al_resultsPayload>
          }
          createMany: {
            args: Prisma.gce_al_resultsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.gce_al_resultsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gce_al_resultsPayload>
          }
          update: {
            args: Prisma.gce_al_resultsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gce_al_resultsPayload>
          }
          deleteMany: {
            args: Prisma.gce_al_resultsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.gce_al_resultsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.gce_al_resultsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gce_al_resultsPayload>
          }
          aggregate: {
            args: Prisma.Gce_al_resultsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGce_al_results>
          }
          groupBy: {
            args: Prisma.gce_al_resultsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Gce_al_resultsGroupByOutputType>[]
          }
          count: {
            args: Prisma.gce_al_resultsCountArgs<ExtArgs>
            result: $Utils.Optional<Gce_al_resultsCountAggregateOutputType> | number
          }
        }
      }
      gce_ol_results: {
        payload: Prisma.$gce_ol_resultsPayload<ExtArgs>
        fields: Prisma.gce_ol_resultsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.gce_ol_resultsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gce_ol_resultsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.gce_ol_resultsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gce_ol_resultsPayload>
          }
          findFirst: {
            args: Prisma.gce_ol_resultsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gce_ol_resultsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.gce_ol_resultsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gce_ol_resultsPayload>
          }
          findMany: {
            args: Prisma.gce_ol_resultsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gce_ol_resultsPayload>[]
          }
          create: {
            args: Prisma.gce_ol_resultsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gce_ol_resultsPayload>
          }
          createMany: {
            args: Prisma.gce_ol_resultsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.gce_ol_resultsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gce_ol_resultsPayload>
          }
          update: {
            args: Prisma.gce_ol_resultsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gce_ol_resultsPayload>
          }
          deleteMany: {
            args: Prisma.gce_ol_resultsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.gce_ol_resultsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.gce_ol_resultsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gce_ol_resultsPayload>
          }
          aggregate: {
            args: Prisma.Gce_ol_resultsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGce_ol_results>
          }
          groupBy: {
            args: Prisma.gce_ol_resultsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Gce_ol_resultsGroupByOutputType>[]
          }
          count: {
            args: Prisma.gce_ol_resultsCountArgs<ExtArgs>
            result: $Utils.Optional<Gce_ol_resultsCountAggregateOutputType> | number
          }
        }
      }
      jobvacancy: {
        payload: Prisma.$jobvacancyPayload<ExtArgs>
        fields: Prisma.jobvacancyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.jobvacancyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobvacancyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.jobvacancyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobvacancyPayload>
          }
          findFirst: {
            args: Prisma.jobvacancyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobvacancyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.jobvacancyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobvacancyPayload>
          }
          findMany: {
            args: Prisma.jobvacancyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobvacancyPayload>[]
          }
          create: {
            args: Prisma.jobvacancyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobvacancyPayload>
          }
          createMany: {
            args: Prisma.jobvacancyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.jobvacancyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobvacancyPayload>
          }
          update: {
            args: Prisma.jobvacancyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobvacancyPayload>
          }
          deleteMany: {
            args: Prisma.jobvacancyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.jobvacancyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.jobvacancyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobvacancyPayload>
          }
          aggregate: {
            args: Prisma.JobvacancyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobvacancy>
          }
          groupBy: {
            args: Prisma.jobvacancyGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobvacancyGroupByOutputType>[]
          }
          count: {
            args: Prisma.jobvacancyCountArgs<ExtArgs>
            result: $Utils.Optional<JobvacancyCountAggregateOutputType> | number
          }
        }
      }
      languageproficiencies: {
        payload: Prisma.$languageproficienciesPayload<ExtArgs>
        fields: Prisma.languageproficienciesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.languageproficienciesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languageproficienciesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.languageproficienciesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languageproficienciesPayload>
          }
          findFirst: {
            args: Prisma.languageproficienciesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languageproficienciesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.languageproficienciesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languageproficienciesPayload>
          }
          findMany: {
            args: Prisma.languageproficienciesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languageproficienciesPayload>[]
          }
          create: {
            args: Prisma.languageproficienciesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languageproficienciesPayload>
          }
          createMany: {
            args: Prisma.languageproficienciesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.languageproficienciesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languageproficienciesPayload>
          }
          update: {
            args: Prisma.languageproficienciesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languageproficienciesPayload>
          }
          deleteMany: {
            args: Prisma.languageproficienciesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.languageproficienciesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.languageproficienciesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$languageproficienciesPayload>
          }
          aggregate: {
            args: Prisma.LanguageproficienciesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguageproficiencies>
          }
          groupBy: {
            args: Prisma.languageproficienciesGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageproficienciesGroupByOutputType>[]
          }
          count: {
            args: Prisma.languageproficienciesCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageproficienciesCountAggregateOutputType> | number
          }
        }
      }
      professionalqualifications: {
        payload: Prisma.$professionalqualificationsPayload<ExtArgs>
        fields: Prisma.professionalqualificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.professionalqualificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$professionalqualificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.professionalqualificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$professionalqualificationsPayload>
          }
          findFirst: {
            args: Prisma.professionalqualificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$professionalqualificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.professionalqualificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$professionalqualificationsPayload>
          }
          findMany: {
            args: Prisma.professionalqualificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$professionalqualificationsPayload>[]
          }
          create: {
            args: Prisma.professionalqualificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$professionalqualificationsPayload>
          }
          createMany: {
            args: Prisma.professionalqualificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.professionalqualificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$professionalqualificationsPayload>
          }
          update: {
            args: Prisma.professionalqualificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$professionalqualificationsPayload>
          }
          deleteMany: {
            args: Prisma.professionalqualificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.professionalqualificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.professionalqualificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$professionalqualificationsPayload>
          }
          aggregate: {
            args: Prisma.ProfessionalqualificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfessionalqualifications>
          }
          groupBy: {
            args: Prisma.professionalqualificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfessionalqualificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.professionalqualificationsCountArgs<ExtArgs>
            result: $Utils.Optional<ProfessionalqualificationsCountAggregateOutputType> | number
          }
        }
      }
      researchandpublications: {
        payload: Prisma.$researchandpublicationsPayload<ExtArgs>
        fields: Prisma.researchandpublicationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.researchandpublicationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$researchandpublicationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.researchandpublicationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$researchandpublicationsPayload>
          }
          findFirst: {
            args: Prisma.researchandpublicationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$researchandpublicationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.researchandpublicationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$researchandpublicationsPayload>
          }
          findMany: {
            args: Prisma.researchandpublicationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$researchandpublicationsPayload>[]
          }
          create: {
            args: Prisma.researchandpublicationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$researchandpublicationsPayload>
          }
          createMany: {
            args: Prisma.researchandpublicationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.researchandpublicationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$researchandpublicationsPayload>
          }
          update: {
            args: Prisma.researchandpublicationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$researchandpublicationsPayload>
          }
          deleteMany: {
            args: Prisma.researchandpublicationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.researchandpublicationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.researchandpublicationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$researchandpublicationsPayload>
          }
          aggregate: {
            args: Prisma.ResearchandpublicationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResearchandpublications>
          }
          groupBy: {
            args: Prisma.researchandpublicationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResearchandpublicationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.researchandpublicationsCountArgs<ExtArgs>
            result: $Utils.Optional<ResearchandpublicationsCountAggregateOutputType> | number
          }
        }
      }
      specialqualifications: {
        payload: Prisma.$specialqualificationsPayload<ExtArgs>
        fields: Prisma.specialqualificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.specialqualificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$specialqualificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.specialqualificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$specialqualificationsPayload>
          }
          findFirst: {
            args: Prisma.specialqualificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$specialqualificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.specialqualificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$specialqualificationsPayload>
          }
          findMany: {
            args: Prisma.specialqualificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$specialqualificationsPayload>[]
          }
          create: {
            args: Prisma.specialqualificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$specialqualificationsPayload>
          }
          createMany: {
            args: Prisma.specialqualificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.specialqualificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$specialqualificationsPayload>
          }
          update: {
            args: Prisma.specialqualificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$specialqualificationsPayload>
          }
          deleteMany: {
            args: Prisma.specialqualificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.specialqualificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.specialqualificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$specialqualificationsPayload>
          }
          aggregate: {
            args: Prisma.SpecialqualificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpecialqualifications>
          }
          groupBy: {
            args: Prisma.specialqualificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpecialqualificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.specialqualificationsCountArgs<ExtArgs>
            result: $Utils.Optional<SpecialqualificationsCountAggregateOutputType> | number
          }
        }
      }
      superadmin: {
        payload: Prisma.$superadminPayload<ExtArgs>
        fields: Prisma.superadminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.superadminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superadminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.superadminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superadminPayload>
          }
          findFirst: {
            args: Prisma.superadminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superadminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.superadminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superadminPayload>
          }
          findMany: {
            args: Prisma.superadminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superadminPayload>[]
          }
          create: {
            args: Prisma.superadminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superadminPayload>
          }
          createMany: {
            args: Prisma.superadminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.superadminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superadminPayload>
          }
          update: {
            args: Prisma.superadminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superadminPayload>
          }
          deleteMany: {
            args: Prisma.superadminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.superadminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.superadminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superadminPayload>
          }
          aggregate: {
            args: Prisma.SuperadminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuperadmin>
          }
          groupBy: {
            args: Prisma.superadminGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuperadminGroupByOutputType>[]
          }
          count: {
            args: Prisma.superadminCountArgs<ExtArgs>
            result: $Utils.Optional<SuperadminCountAggregateOutputType> | number
          }
        }
      }
      universityeducations: {
        payload: Prisma.$universityeducationsPayload<ExtArgs>
        fields: Prisma.universityeducationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.universityeducationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$universityeducationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.universityeducationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$universityeducationsPayload>
          }
          findFirst: {
            args: Prisma.universityeducationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$universityeducationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.universityeducationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$universityeducationsPayload>
          }
          findMany: {
            args: Prisma.universityeducationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$universityeducationsPayload>[]
          }
          create: {
            args: Prisma.universityeducationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$universityeducationsPayload>
          }
          createMany: {
            args: Prisma.universityeducationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.universityeducationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$universityeducationsPayload>
          }
          update: {
            args: Prisma.universityeducationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$universityeducationsPayload>
          }
          deleteMany: {
            args: Prisma.universityeducationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.universityeducationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.universityeducationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$universityeducationsPayload>
          }
          aggregate: {
            args: Prisma.UniversityeducationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUniversityeducations>
          }
          groupBy: {
            args: Prisma.universityeducationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UniversityeducationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.universityeducationsCountArgs<ExtArgs>
            result: $Utils.Optional<UniversityeducationsCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    additionalinfo?: additionalinfoOmit
    admin?: adminOmit
    application?: applicationOmit
    applicationattachments?: applicationattachmentsOmit
    applicationgeneraldetails?: applicationgeneraldetailsOmit
    applicationreferences?: applicationreferencesOmit
    applicationtemplate?: applicationtemplateOmit
    auditlog?: auditlogOmit
    employmenthistories?: employmenthistoriesOmit
    experiencedetails?: experiencedetailsOmit
    gce_al_results?: gce_al_resultsOmit
    gce_ol_results?: gce_ol_resultsOmit
    jobvacancy?: jobvacancyOmit
    languageproficiencies?: languageproficienciesOmit
    professionalqualifications?: professionalqualificationsOmit
    researchandpublications?: researchandpublicationsOmit
    specialqualifications?: specialqualificationsOmit
    superadmin?: superadminOmit
    universityeducations?: universityeducationsOmit
    user?: userOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    applicationtemplate: number
    jobvacancy: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicationtemplate?: boolean | AdminCountOutputTypeCountApplicationtemplateArgs
    jobvacancy?: boolean | AdminCountOutputTypeCountJobvacancyArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountApplicationtemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicationtemplateWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountJobvacancyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobvacancyWhereInput
  }


  /**
   * Count Type ApplicationCountOutputType
   */

  export type ApplicationCountOutputType = {
    additionalinfo: number
    applicationattachments: number
    applicationreferences: number
    employmenthistories: number
    experiencedetails: number
    gce_al_results: number
    gce_ol_results: number
    languageproficiencies: number
    professionalqualifications: number
    researchandpublications: number
    specialqualifications: number
    universityeducations: number
  }

  export type ApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    additionalinfo?: boolean | ApplicationCountOutputTypeCountAdditionalinfoArgs
    applicationattachments?: boolean | ApplicationCountOutputTypeCountApplicationattachmentsArgs
    applicationreferences?: boolean | ApplicationCountOutputTypeCountApplicationreferencesArgs
    employmenthistories?: boolean | ApplicationCountOutputTypeCountEmploymenthistoriesArgs
    experiencedetails?: boolean | ApplicationCountOutputTypeCountExperiencedetailsArgs
    gce_al_results?: boolean | ApplicationCountOutputTypeCountGce_al_resultsArgs
    gce_ol_results?: boolean | ApplicationCountOutputTypeCountGce_ol_resultsArgs
    languageproficiencies?: boolean | ApplicationCountOutputTypeCountLanguageproficienciesArgs
    professionalqualifications?: boolean | ApplicationCountOutputTypeCountProfessionalqualificationsArgs
    researchandpublications?: boolean | ApplicationCountOutputTypeCountResearchandpublicationsArgs
    specialqualifications?: boolean | ApplicationCountOutputTypeCountSpecialqualificationsArgs
    universityeducations?: boolean | ApplicationCountOutputTypeCountUniversityeducationsArgs
  }

  // Custom InputTypes
  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationCountOutputType
     */
    select?: ApplicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountAdditionalinfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: additionalinfoWhereInput
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountApplicationattachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicationattachmentsWhereInput
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountApplicationreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicationreferencesWhereInput
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountEmploymenthistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employmenthistoriesWhereInput
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountExperiencedetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: experiencedetailsWhereInput
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountGce_al_resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gce_al_resultsWhereInput
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountGce_ol_resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gce_ol_resultsWhereInput
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountLanguageproficienciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: languageproficienciesWhereInput
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountProfessionalqualificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: professionalqualificationsWhereInput
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountResearchandpublicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: researchandpublicationsWhereInput
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountSpecialqualificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: specialqualificationsWhereInput
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountUniversityeducationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: universityeducationsWhereInput
  }


  /**
   * Count Type ApplicationtemplateCountOutputType
   */

  export type ApplicationtemplateCountOutputType = {
    jobvacancy: number
  }

  export type ApplicationtemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobvacancy?: boolean | ApplicationtemplateCountOutputTypeCountJobvacancyArgs
  }

  // Custom InputTypes
  /**
   * ApplicationtemplateCountOutputType without action
   */
  export type ApplicationtemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationtemplateCountOutputType
     */
    select?: ApplicationtemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApplicationtemplateCountOutputType without action
   */
  export type ApplicationtemplateCountOutputTypeCountJobvacancyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobvacancyWhereInput
  }


  /**
   * Count Type JobvacancyCountOutputType
   */

  export type JobvacancyCountOutputType = {
    application: number
  }

  export type JobvacancyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | JobvacancyCountOutputTypeCountApplicationArgs
  }

  // Custom InputTypes
  /**
   * JobvacancyCountOutputType without action
   */
  export type JobvacancyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobvacancyCountOutputType
     */
    select?: JobvacancyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobvacancyCountOutputType without action
   */
  export type JobvacancyCountOutputTypeCountApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicationWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    application: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | UserCountOutputTypeCountApplicationArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model additionalinfo
   */

  export type AggregateAdditionalinfo = {
    _count: AdditionalinfoCountAggregateOutputType | null
    _avg: AdditionalinfoAvgAggregateOutputType | null
    _sum: AdditionalinfoSumAggregateOutputType | null
    _min: AdditionalinfoMinAggregateOutputType | null
    _max: AdditionalinfoMaxAggregateOutputType | null
  }

  export type AdditionalinfoAvgAggregateOutputType = {
    InfoID: number | null
    ApplicationID: number | null
  }

  export type AdditionalinfoSumAggregateOutputType = {
    InfoID: number | null
    ApplicationID: number | null
  }

  export type AdditionalinfoMinAggregateOutputType = {
    InfoID: number | null
    ApplicationID: number | null
    Content: string | null
  }

  export type AdditionalinfoMaxAggregateOutputType = {
    InfoID: number | null
    ApplicationID: number | null
    Content: string | null
  }

  export type AdditionalinfoCountAggregateOutputType = {
    InfoID: number
    ApplicationID: number
    Content: number
    _all: number
  }


  export type AdditionalinfoAvgAggregateInputType = {
    InfoID?: true
    ApplicationID?: true
  }

  export type AdditionalinfoSumAggregateInputType = {
    InfoID?: true
    ApplicationID?: true
  }

  export type AdditionalinfoMinAggregateInputType = {
    InfoID?: true
    ApplicationID?: true
    Content?: true
  }

  export type AdditionalinfoMaxAggregateInputType = {
    InfoID?: true
    ApplicationID?: true
    Content?: true
  }

  export type AdditionalinfoCountAggregateInputType = {
    InfoID?: true
    ApplicationID?: true
    Content?: true
    _all?: true
  }

  export type AdditionalinfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which additionalinfo to aggregate.
     */
    where?: additionalinfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of additionalinfos to fetch.
     */
    orderBy?: additionalinfoOrderByWithRelationInput | additionalinfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: additionalinfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` additionalinfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` additionalinfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned additionalinfos
    **/
    _count?: true | AdditionalinfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdditionalinfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdditionalinfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdditionalinfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdditionalinfoMaxAggregateInputType
  }

  export type GetAdditionalinfoAggregateType<T extends AdditionalinfoAggregateArgs> = {
        [P in keyof T & keyof AggregateAdditionalinfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdditionalinfo[P]>
      : GetScalarType<T[P], AggregateAdditionalinfo[P]>
  }




  export type additionalinfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: additionalinfoWhereInput
    orderBy?: additionalinfoOrderByWithAggregationInput | additionalinfoOrderByWithAggregationInput[]
    by: AdditionalinfoScalarFieldEnum[] | AdditionalinfoScalarFieldEnum
    having?: additionalinfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdditionalinfoCountAggregateInputType | true
    _avg?: AdditionalinfoAvgAggregateInputType
    _sum?: AdditionalinfoSumAggregateInputType
    _min?: AdditionalinfoMinAggregateInputType
    _max?: AdditionalinfoMaxAggregateInputType
  }

  export type AdditionalinfoGroupByOutputType = {
    InfoID: number
    ApplicationID: number | null
    Content: string | null
    _count: AdditionalinfoCountAggregateOutputType | null
    _avg: AdditionalinfoAvgAggregateOutputType | null
    _sum: AdditionalinfoSumAggregateOutputType | null
    _min: AdditionalinfoMinAggregateOutputType | null
    _max: AdditionalinfoMaxAggregateOutputType | null
  }

  type GetAdditionalinfoGroupByPayload<T extends additionalinfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdditionalinfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdditionalinfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdditionalinfoGroupByOutputType[P]>
            : GetScalarType<T[P], AdditionalinfoGroupByOutputType[P]>
        }
      >
    >


  export type additionalinfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    InfoID?: boolean
    ApplicationID?: boolean
    Content?: boolean
    application?: boolean | additionalinfo$applicationArgs<ExtArgs>
  }, ExtArgs["result"]["additionalinfo"]>



  export type additionalinfoSelectScalar = {
    InfoID?: boolean
    ApplicationID?: boolean
    Content?: boolean
  }

  export type additionalinfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"InfoID" | "ApplicationID" | "Content", ExtArgs["result"]["additionalinfo"]>
  export type additionalinfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | additionalinfo$applicationArgs<ExtArgs>
  }

  export type $additionalinfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "additionalinfo"
    objects: {
      application: Prisma.$applicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      InfoID: number
      ApplicationID: number | null
      Content: string | null
    }, ExtArgs["result"]["additionalinfo"]>
    composites: {}
  }

  type additionalinfoGetPayload<S extends boolean | null | undefined | additionalinfoDefaultArgs> = $Result.GetResult<Prisma.$additionalinfoPayload, S>

  type additionalinfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<additionalinfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdditionalinfoCountAggregateInputType | true
    }

  export interface additionalinfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['additionalinfo'], meta: { name: 'additionalinfo' } }
    /**
     * Find zero or one Additionalinfo that matches the filter.
     * @param {additionalinfoFindUniqueArgs} args - Arguments to find a Additionalinfo
     * @example
     * // Get one Additionalinfo
     * const additionalinfo = await prisma.additionalinfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends additionalinfoFindUniqueArgs>(args: SelectSubset<T, additionalinfoFindUniqueArgs<ExtArgs>>): Prisma__additionalinfoClient<$Result.GetResult<Prisma.$additionalinfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Additionalinfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {additionalinfoFindUniqueOrThrowArgs} args - Arguments to find a Additionalinfo
     * @example
     * // Get one Additionalinfo
     * const additionalinfo = await prisma.additionalinfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends additionalinfoFindUniqueOrThrowArgs>(args: SelectSubset<T, additionalinfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__additionalinfoClient<$Result.GetResult<Prisma.$additionalinfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Additionalinfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {additionalinfoFindFirstArgs} args - Arguments to find a Additionalinfo
     * @example
     * // Get one Additionalinfo
     * const additionalinfo = await prisma.additionalinfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends additionalinfoFindFirstArgs>(args?: SelectSubset<T, additionalinfoFindFirstArgs<ExtArgs>>): Prisma__additionalinfoClient<$Result.GetResult<Prisma.$additionalinfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Additionalinfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {additionalinfoFindFirstOrThrowArgs} args - Arguments to find a Additionalinfo
     * @example
     * // Get one Additionalinfo
     * const additionalinfo = await prisma.additionalinfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends additionalinfoFindFirstOrThrowArgs>(args?: SelectSubset<T, additionalinfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__additionalinfoClient<$Result.GetResult<Prisma.$additionalinfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Additionalinfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {additionalinfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Additionalinfos
     * const additionalinfos = await prisma.additionalinfo.findMany()
     * 
     * // Get first 10 Additionalinfos
     * const additionalinfos = await prisma.additionalinfo.findMany({ take: 10 })
     * 
     * // Only select the `InfoID`
     * const additionalinfoWithInfoIDOnly = await prisma.additionalinfo.findMany({ select: { InfoID: true } })
     * 
     */
    findMany<T extends additionalinfoFindManyArgs>(args?: SelectSubset<T, additionalinfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$additionalinfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Additionalinfo.
     * @param {additionalinfoCreateArgs} args - Arguments to create a Additionalinfo.
     * @example
     * // Create one Additionalinfo
     * const Additionalinfo = await prisma.additionalinfo.create({
     *   data: {
     *     // ... data to create a Additionalinfo
     *   }
     * })
     * 
     */
    create<T extends additionalinfoCreateArgs>(args: SelectSubset<T, additionalinfoCreateArgs<ExtArgs>>): Prisma__additionalinfoClient<$Result.GetResult<Prisma.$additionalinfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Additionalinfos.
     * @param {additionalinfoCreateManyArgs} args - Arguments to create many Additionalinfos.
     * @example
     * // Create many Additionalinfos
     * const additionalinfo = await prisma.additionalinfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends additionalinfoCreateManyArgs>(args?: SelectSubset<T, additionalinfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Additionalinfo.
     * @param {additionalinfoDeleteArgs} args - Arguments to delete one Additionalinfo.
     * @example
     * // Delete one Additionalinfo
     * const Additionalinfo = await prisma.additionalinfo.delete({
     *   where: {
     *     // ... filter to delete one Additionalinfo
     *   }
     * })
     * 
     */
    delete<T extends additionalinfoDeleteArgs>(args: SelectSubset<T, additionalinfoDeleteArgs<ExtArgs>>): Prisma__additionalinfoClient<$Result.GetResult<Prisma.$additionalinfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Additionalinfo.
     * @param {additionalinfoUpdateArgs} args - Arguments to update one Additionalinfo.
     * @example
     * // Update one Additionalinfo
     * const additionalinfo = await prisma.additionalinfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends additionalinfoUpdateArgs>(args: SelectSubset<T, additionalinfoUpdateArgs<ExtArgs>>): Prisma__additionalinfoClient<$Result.GetResult<Prisma.$additionalinfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Additionalinfos.
     * @param {additionalinfoDeleteManyArgs} args - Arguments to filter Additionalinfos to delete.
     * @example
     * // Delete a few Additionalinfos
     * const { count } = await prisma.additionalinfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends additionalinfoDeleteManyArgs>(args?: SelectSubset<T, additionalinfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Additionalinfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {additionalinfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Additionalinfos
     * const additionalinfo = await prisma.additionalinfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends additionalinfoUpdateManyArgs>(args: SelectSubset<T, additionalinfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Additionalinfo.
     * @param {additionalinfoUpsertArgs} args - Arguments to update or create a Additionalinfo.
     * @example
     * // Update or create a Additionalinfo
     * const additionalinfo = await prisma.additionalinfo.upsert({
     *   create: {
     *     // ... data to create a Additionalinfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Additionalinfo we want to update
     *   }
     * })
     */
    upsert<T extends additionalinfoUpsertArgs>(args: SelectSubset<T, additionalinfoUpsertArgs<ExtArgs>>): Prisma__additionalinfoClient<$Result.GetResult<Prisma.$additionalinfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Additionalinfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {additionalinfoCountArgs} args - Arguments to filter Additionalinfos to count.
     * @example
     * // Count the number of Additionalinfos
     * const count = await prisma.additionalinfo.count({
     *   where: {
     *     // ... the filter for the Additionalinfos we want to count
     *   }
     * })
    **/
    count<T extends additionalinfoCountArgs>(
      args?: Subset<T, additionalinfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdditionalinfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Additionalinfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalinfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdditionalinfoAggregateArgs>(args: Subset<T, AdditionalinfoAggregateArgs>): Prisma.PrismaPromise<GetAdditionalinfoAggregateType<T>>

    /**
     * Group by Additionalinfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {additionalinfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends additionalinfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: additionalinfoGroupByArgs['orderBy'] }
        : { orderBy?: additionalinfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, additionalinfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdditionalinfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the additionalinfo model
   */
  readonly fields: additionalinfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for additionalinfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__additionalinfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends additionalinfo$applicationArgs<ExtArgs> = {}>(args?: Subset<T, additionalinfo$applicationArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the additionalinfo model
   */
  interface additionalinfoFieldRefs {
    readonly InfoID: FieldRef<"additionalinfo", 'Int'>
    readonly ApplicationID: FieldRef<"additionalinfo", 'Int'>
    readonly Content: FieldRef<"additionalinfo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * additionalinfo findUnique
   */
  export type additionalinfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the additionalinfo
     */
    select?: additionalinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the additionalinfo
     */
    omit?: additionalinfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: additionalinfoInclude<ExtArgs> | null
    /**
     * Filter, which additionalinfo to fetch.
     */
    where: additionalinfoWhereUniqueInput
  }

  /**
   * additionalinfo findUniqueOrThrow
   */
  export type additionalinfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the additionalinfo
     */
    select?: additionalinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the additionalinfo
     */
    omit?: additionalinfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: additionalinfoInclude<ExtArgs> | null
    /**
     * Filter, which additionalinfo to fetch.
     */
    where: additionalinfoWhereUniqueInput
  }

  /**
   * additionalinfo findFirst
   */
  export type additionalinfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the additionalinfo
     */
    select?: additionalinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the additionalinfo
     */
    omit?: additionalinfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: additionalinfoInclude<ExtArgs> | null
    /**
     * Filter, which additionalinfo to fetch.
     */
    where?: additionalinfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of additionalinfos to fetch.
     */
    orderBy?: additionalinfoOrderByWithRelationInput | additionalinfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for additionalinfos.
     */
    cursor?: additionalinfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` additionalinfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` additionalinfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of additionalinfos.
     */
    distinct?: AdditionalinfoScalarFieldEnum | AdditionalinfoScalarFieldEnum[]
  }

  /**
   * additionalinfo findFirstOrThrow
   */
  export type additionalinfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the additionalinfo
     */
    select?: additionalinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the additionalinfo
     */
    omit?: additionalinfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: additionalinfoInclude<ExtArgs> | null
    /**
     * Filter, which additionalinfo to fetch.
     */
    where?: additionalinfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of additionalinfos to fetch.
     */
    orderBy?: additionalinfoOrderByWithRelationInput | additionalinfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for additionalinfos.
     */
    cursor?: additionalinfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` additionalinfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` additionalinfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of additionalinfos.
     */
    distinct?: AdditionalinfoScalarFieldEnum | AdditionalinfoScalarFieldEnum[]
  }

  /**
   * additionalinfo findMany
   */
  export type additionalinfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the additionalinfo
     */
    select?: additionalinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the additionalinfo
     */
    omit?: additionalinfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: additionalinfoInclude<ExtArgs> | null
    /**
     * Filter, which additionalinfos to fetch.
     */
    where?: additionalinfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of additionalinfos to fetch.
     */
    orderBy?: additionalinfoOrderByWithRelationInput | additionalinfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing additionalinfos.
     */
    cursor?: additionalinfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` additionalinfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` additionalinfos.
     */
    skip?: number
    distinct?: AdditionalinfoScalarFieldEnum | AdditionalinfoScalarFieldEnum[]
  }

  /**
   * additionalinfo create
   */
  export type additionalinfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the additionalinfo
     */
    select?: additionalinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the additionalinfo
     */
    omit?: additionalinfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: additionalinfoInclude<ExtArgs> | null
    /**
     * The data needed to create a additionalinfo.
     */
    data?: XOR<additionalinfoCreateInput, additionalinfoUncheckedCreateInput>
  }

  /**
   * additionalinfo createMany
   */
  export type additionalinfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many additionalinfos.
     */
    data: additionalinfoCreateManyInput | additionalinfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * additionalinfo update
   */
  export type additionalinfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the additionalinfo
     */
    select?: additionalinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the additionalinfo
     */
    omit?: additionalinfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: additionalinfoInclude<ExtArgs> | null
    /**
     * The data needed to update a additionalinfo.
     */
    data: XOR<additionalinfoUpdateInput, additionalinfoUncheckedUpdateInput>
    /**
     * Choose, which additionalinfo to update.
     */
    where: additionalinfoWhereUniqueInput
  }

  /**
   * additionalinfo updateMany
   */
  export type additionalinfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update additionalinfos.
     */
    data: XOR<additionalinfoUpdateManyMutationInput, additionalinfoUncheckedUpdateManyInput>
    /**
     * Filter which additionalinfos to update
     */
    where?: additionalinfoWhereInput
    /**
     * Limit how many additionalinfos to update.
     */
    limit?: number
  }

  /**
   * additionalinfo upsert
   */
  export type additionalinfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the additionalinfo
     */
    select?: additionalinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the additionalinfo
     */
    omit?: additionalinfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: additionalinfoInclude<ExtArgs> | null
    /**
     * The filter to search for the additionalinfo to update in case it exists.
     */
    where: additionalinfoWhereUniqueInput
    /**
     * In case the additionalinfo found by the `where` argument doesn't exist, create a new additionalinfo with this data.
     */
    create: XOR<additionalinfoCreateInput, additionalinfoUncheckedCreateInput>
    /**
     * In case the additionalinfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<additionalinfoUpdateInput, additionalinfoUncheckedUpdateInput>
  }

  /**
   * additionalinfo delete
   */
  export type additionalinfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the additionalinfo
     */
    select?: additionalinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the additionalinfo
     */
    omit?: additionalinfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: additionalinfoInclude<ExtArgs> | null
    /**
     * Filter which additionalinfo to delete.
     */
    where: additionalinfoWhereUniqueInput
  }

  /**
   * additionalinfo deleteMany
   */
  export type additionalinfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which additionalinfos to delete
     */
    where?: additionalinfoWhereInput
    /**
     * Limit how many additionalinfos to delete.
     */
    limit?: number
  }

  /**
   * additionalinfo.application
   */
  export type additionalinfo$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    where?: applicationWhereInput
  }

  /**
   * additionalinfo without action
   */
  export type additionalinfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the additionalinfo
     */
    select?: additionalinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the additionalinfo
     */
    omit?: additionalinfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: additionalinfoInclude<ExtArgs> | null
  }


  /**
   * Model admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    AdminID: number | null
  }

  export type AdminSumAggregateOutputType = {
    AdminID: number | null
  }

  export type AdminMinAggregateOutputType = {
    AdminID: number | null
    FullName: string | null
    Email: string | null
    PasswordHash: string | null
    Department: string | null
    PhoneNumber: string | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
    isDeleted: boolean | null
  }

  export type AdminMaxAggregateOutputType = {
    AdminID: number | null
    FullName: string | null
    Email: string | null
    PasswordHash: string | null
    Department: string | null
    PhoneNumber: string | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
    isDeleted: boolean | null
  }

  export type AdminCountAggregateOutputType = {
    AdminID: number
    FullName: number
    Email: number
    PasswordHash: number
    Department: number
    PhoneNumber: number
    CreatedAt: number
    UpdatedAt: number
    isDeleted: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    AdminID?: true
  }

  export type AdminSumAggregateInputType = {
    AdminID?: true
  }

  export type AdminMinAggregateInputType = {
    AdminID?: true
    FullName?: true
    Email?: true
    PasswordHash?: true
    Department?: true
    PhoneNumber?: true
    CreatedAt?: true
    UpdatedAt?: true
    isDeleted?: true
  }

  export type AdminMaxAggregateInputType = {
    AdminID?: true
    FullName?: true
    Email?: true
    PasswordHash?: true
    Department?: true
    PhoneNumber?: true
    CreatedAt?: true
    UpdatedAt?: true
    isDeleted?: true
  }

  export type AdminCountAggregateInputType = {
    AdminID?: true
    FullName?: true
    Email?: true
    PasswordHash?: true
    Department?: true
    PhoneNumber?: true
    CreatedAt?: true
    UpdatedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin to aggregate.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type adminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adminWhereInput
    orderBy?: adminOrderByWithAggregationInput | adminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: adminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    AdminID: number
    FullName: string | null
    Email: string | null
    PasswordHash: string | null
    Department: string | null
    PhoneNumber: string | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
    isDeleted: boolean | null
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends adminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type adminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    AdminID?: boolean
    FullName?: boolean
    Email?: boolean
    PasswordHash?: boolean
    Department?: boolean
    PhoneNumber?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    isDeleted?: boolean
    applicationtemplate?: boolean | admin$applicationtemplateArgs<ExtArgs>
    jobvacancy?: boolean | admin$jobvacancyArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>



  export type adminSelectScalar = {
    AdminID?: boolean
    FullName?: boolean
    Email?: boolean
    PasswordHash?: boolean
    Department?: boolean
    PhoneNumber?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    isDeleted?: boolean
  }

  export type adminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"AdminID" | "FullName" | "Email" | "PasswordHash" | "Department" | "PhoneNumber" | "CreatedAt" | "UpdatedAt" | "isDeleted", ExtArgs["result"]["admin"]>
  export type adminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicationtemplate?: boolean | admin$applicationtemplateArgs<ExtArgs>
    jobvacancy?: boolean | admin$jobvacancyArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $adminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin"
    objects: {
      applicationtemplate: Prisma.$applicationtemplatePayload<ExtArgs>[]
      jobvacancy: Prisma.$jobvacancyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      AdminID: number
      FullName: string | null
      Email: string | null
      PasswordHash: string | null
      Department: string | null
      PhoneNumber: string | null
      CreatedAt: Date | null
      UpdatedAt: Date | null
      isDeleted: boolean | null
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type adminGetPayload<S extends boolean | null | undefined | adminDefaultArgs> = $Result.GetResult<Prisma.$adminPayload, S>

  type adminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<adminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface adminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin'], meta: { name: 'admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {adminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends adminFindUniqueArgs>(args: SelectSubset<T, adminFindUniqueArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {adminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends adminFindUniqueOrThrowArgs>(args: SelectSubset<T, adminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends adminFindFirstArgs>(args?: SelectSubset<T, adminFindFirstArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends adminFindFirstOrThrowArgs>(args?: SelectSubset<T, adminFindFirstOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `AdminID`
     * const adminWithAdminIDOnly = await prisma.admin.findMany({ select: { AdminID: true } })
     * 
     */
    findMany<T extends adminFindManyArgs>(args?: SelectSubset<T, adminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {adminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends adminCreateArgs>(args: SelectSubset<T, adminCreateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {adminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends adminCreateManyArgs>(args?: SelectSubset<T, adminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {adminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends adminDeleteArgs>(args: SelectSubset<T, adminDeleteArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {adminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends adminUpdateArgs>(args: SelectSubset<T, adminUpdateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {adminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends adminDeleteManyArgs>(args?: SelectSubset<T, adminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends adminUpdateManyArgs>(args: SelectSubset<T, adminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {adminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends adminUpsertArgs>(args: SelectSubset<T, adminUpsertArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends adminCountArgs>(
      args?: Subset<T, adminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends adminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: adminGroupByArgs['orderBy'] }
        : { orderBy?: adminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, adminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin model
   */
  readonly fields: adminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__adminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applicationtemplate<T extends admin$applicationtemplateArgs<ExtArgs> = {}>(args?: Subset<T, admin$applicationtemplateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationtemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobvacancy<T extends admin$jobvacancyArgs<ExtArgs> = {}>(args?: Subset<T, admin$jobvacancyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobvacancyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admin model
   */
  interface adminFieldRefs {
    readonly AdminID: FieldRef<"admin", 'Int'>
    readonly FullName: FieldRef<"admin", 'String'>
    readonly Email: FieldRef<"admin", 'String'>
    readonly PasswordHash: FieldRef<"admin", 'String'>
    readonly Department: FieldRef<"admin", 'String'>
    readonly PhoneNumber: FieldRef<"admin", 'String'>
    readonly CreatedAt: FieldRef<"admin", 'DateTime'>
    readonly UpdatedAt: FieldRef<"admin", 'DateTime'>
    readonly isDeleted: FieldRef<"admin", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * admin findUnique
   */
  export type adminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findUniqueOrThrow
   */
  export type adminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findFirst
   */
  export type adminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findFirstOrThrow
   */
  export type adminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findMany
   */
  export type adminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin create
   */
  export type adminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The data needed to create a admin.
     */
    data?: XOR<adminCreateInput, adminUncheckedCreateInput>
  }

  /**
   * admin createMany
   */
  export type adminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admins.
     */
    data: adminCreateManyInput | adminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin update
   */
  export type adminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The data needed to update a admin.
     */
    data: XOR<adminUpdateInput, adminUncheckedUpdateInput>
    /**
     * Choose, which admin to update.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin updateMany
   */
  export type adminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admins.
     */
    data: XOR<adminUpdateManyMutationInput, adminUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminWhereInput
    /**
     * Limit how many admins to update.
     */
    limit?: number
  }

  /**
   * admin upsert
   */
  export type adminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The filter to search for the admin to update in case it exists.
     */
    where: adminWhereUniqueInput
    /**
     * In case the admin found by the `where` argument doesn't exist, create a new admin with this data.
     */
    create: XOR<adminCreateInput, adminUncheckedCreateInput>
    /**
     * In case the admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<adminUpdateInput, adminUncheckedUpdateInput>
  }

  /**
   * admin delete
   */
  export type adminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter which admin to delete.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin deleteMany
   */
  export type adminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admins to delete
     */
    where?: adminWhereInput
    /**
     * Limit how many admins to delete.
     */
    limit?: number
  }

  /**
   * admin.applicationtemplate
   */
  export type admin$applicationtemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtemplate
     */
    select?: applicationtemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationtemplate
     */
    omit?: applicationtemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationtemplateInclude<ExtArgs> | null
    where?: applicationtemplateWhereInput
    orderBy?: applicationtemplateOrderByWithRelationInput | applicationtemplateOrderByWithRelationInput[]
    cursor?: applicationtemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationtemplateScalarFieldEnum | ApplicationtemplateScalarFieldEnum[]
  }

  /**
   * admin.jobvacancy
   */
  export type admin$jobvacancyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobvacancy
     */
    select?: jobvacancySelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobvacancy
     */
    omit?: jobvacancyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobvacancyInclude<ExtArgs> | null
    where?: jobvacancyWhereInput
    orderBy?: jobvacancyOrderByWithRelationInput | jobvacancyOrderByWithRelationInput[]
    cursor?: jobvacancyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobvacancyScalarFieldEnum | JobvacancyScalarFieldEnum[]
  }

  /**
   * admin without action
   */
  export type adminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
  }


  /**
   * Model application
   */

  export type AggregateApplication = {
    _count: ApplicationCountAggregateOutputType | null
    _avg: ApplicationAvgAggregateOutputType | null
    _sum: ApplicationSumAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  export type ApplicationAvgAggregateOutputType = {
    ApplicationID: number | null
    UserID: number | null
    JobID: number | null
  }

  export type ApplicationSumAggregateOutputType = {
    ApplicationID: number | null
    UserID: number | null
    JobID: number | null
  }

  export type ApplicationMinAggregateOutputType = {
    ApplicationID: number | null
    UserID: number | null
    JobID: number | null
    SubmissionDate: Date | null
    Status: $Enums.application_Status | null
    Remarks: string | null
  }

  export type ApplicationMaxAggregateOutputType = {
    ApplicationID: number | null
    UserID: number | null
    JobID: number | null
    SubmissionDate: Date | null
    Status: $Enums.application_Status | null
    Remarks: string | null
  }

  export type ApplicationCountAggregateOutputType = {
    ApplicationID: number
    UserID: number
    JobID: number
    SubmissionDate: number
    Status: number
    Remarks: number
    _all: number
  }


  export type ApplicationAvgAggregateInputType = {
    ApplicationID?: true
    UserID?: true
    JobID?: true
  }

  export type ApplicationSumAggregateInputType = {
    ApplicationID?: true
    UserID?: true
    JobID?: true
  }

  export type ApplicationMinAggregateInputType = {
    ApplicationID?: true
    UserID?: true
    JobID?: true
    SubmissionDate?: true
    Status?: true
    Remarks?: true
  }

  export type ApplicationMaxAggregateInputType = {
    ApplicationID?: true
    UserID?: true
    JobID?: true
    SubmissionDate?: true
    Status?: true
    Remarks?: true
  }

  export type ApplicationCountAggregateInputType = {
    ApplicationID?: true
    UserID?: true
    JobID?: true
    SubmissionDate?: true
    Status?: true
    Remarks?: true
    _all?: true
  }

  export type ApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which application to aggregate.
     */
    where?: applicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applications to fetch.
     */
    orderBy?: applicationOrderByWithRelationInput | applicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: applicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned applications
    **/
    _count?: true | ApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationMaxAggregateInputType
  }

  export type GetApplicationAggregateType<T extends ApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplication[P]>
      : GetScalarType<T[P], AggregateApplication[P]>
  }




  export type applicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicationWhereInput
    orderBy?: applicationOrderByWithAggregationInput | applicationOrderByWithAggregationInput[]
    by: ApplicationScalarFieldEnum[] | ApplicationScalarFieldEnum
    having?: applicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationCountAggregateInputType | true
    _avg?: ApplicationAvgAggregateInputType
    _sum?: ApplicationSumAggregateInputType
    _min?: ApplicationMinAggregateInputType
    _max?: ApplicationMaxAggregateInputType
  }

  export type ApplicationGroupByOutputType = {
    ApplicationID: number
    UserID: number | null
    JobID: number | null
    SubmissionDate: Date | null
    Status: $Enums.application_Status | null
    Remarks: string | null
    _count: ApplicationCountAggregateOutputType | null
    _avg: ApplicationAvgAggregateOutputType | null
    _sum: ApplicationSumAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  type GetApplicationGroupByPayload<T extends applicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
        }
      >
    >


  export type applicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ApplicationID?: boolean
    UserID?: boolean
    JobID?: boolean
    SubmissionDate?: boolean
    Status?: boolean
    Remarks?: boolean
    additionalinfo?: boolean | application$additionalinfoArgs<ExtArgs>
    user?: boolean | application$userArgs<ExtArgs>
    jobvacancy?: boolean | application$jobvacancyArgs<ExtArgs>
    applicationattachments?: boolean | application$applicationattachmentsArgs<ExtArgs>
    applicationgeneraldetails?: boolean | application$applicationgeneraldetailsArgs<ExtArgs>
    applicationreferences?: boolean | application$applicationreferencesArgs<ExtArgs>
    employmenthistories?: boolean | application$employmenthistoriesArgs<ExtArgs>
    experiencedetails?: boolean | application$experiencedetailsArgs<ExtArgs>
    gce_al_results?: boolean | application$gce_al_resultsArgs<ExtArgs>
    gce_ol_results?: boolean | application$gce_ol_resultsArgs<ExtArgs>
    languageproficiencies?: boolean | application$languageproficienciesArgs<ExtArgs>
    professionalqualifications?: boolean | application$professionalqualificationsArgs<ExtArgs>
    researchandpublications?: boolean | application$researchandpublicationsArgs<ExtArgs>
    specialqualifications?: boolean | application$specialqualificationsArgs<ExtArgs>
    universityeducations?: boolean | application$universityeducationsArgs<ExtArgs>
    _count?: boolean | ApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["application"]>



  export type applicationSelectScalar = {
    ApplicationID?: boolean
    UserID?: boolean
    JobID?: boolean
    SubmissionDate?: boolean
    Status?: boolean
    Remarks?: boolean
  }

  export type applicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ApplicationID" | "UserID" | "JobID" | "SubmissionDate" | "Status" | "Remarks", ExtArgs["result"]["application"]>
  export type applicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    additionalinfo?: boolean | application$additionalinfoArgs<ExtArgs>
    user?: boolean | application$userArgs<ExtArgs>
    jobvacancy?: boolean | application$jobvacancyArgs<ExtArgs>
    applicationattachments?: boolean | application$applicationattachmentsArgs<ExtArgs>
    applicationgeneraldetails?: boolean | application$applicationgeneraldetailsArgs<ExtArgs>
    applicationreferences?: boolean | application$applicationreferencesArgs<ExtArgs>
    employmenthistories?: boolean | application$employmenthistoriesArgs<ExtArgs>
    experiencedetails?: boolean | application$experiencedetailsArgs<ExtArgs>
    gce_al_results?: boolean | application$gce_al_resultsArgs<ExtArgs>
    gce_ol_results?: boolean | application$gce_ol_resultsArgs<ExtArgs>
    languageproficiencies?: boolean | application$languageproficienciesArgs<ExtArgs>
    professionalqualifications?: boolean | application$professionalqualificationsArgs<ExtArgs>
    researchandpublications?: boolean | application$researchandpublicationsArgs<ExtArgs>
    specialqualifications?: boolean | application$specialqualificationsArgs<ExtArgs>
    universityeducations?: boolean | application$universityeducationsArgs<ExtArgs>
    _count?: boolean | ApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $applicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "application"
    objects: {
      additionalinfo: Prisma.$additionalinfoPayload<ExtArgs>[]
      user: Prisma.$userPayload<ExtArgs> | null
      jobvacancy: Prisma.$jobvacancyPayload<ExtArgs> | null
      applicationattachments: Prisma.$applicationattachmentsPayload<ExtArgs>[]
      applicationgeneraldetails: Prisma.$applicationgeneraldetailsPayload<ExtArgs> | null
      applicationreferences: Prisma.$applicationreferencesPayload<ExtArgs>[]
      employmenthistories: Prisma.$employmenthistoriesPayload<ExtArgs>[]
      experiencedetails: Prisma.$experiencedetailsPayload<ExtArgs>[]
      gce_al_results: Prisma.$gce_al_resultsPayload<ExtArgs>[]
      gce_ol_results: Prisma.$gce_ol_resultsPayload<ExtArgs>[]
      languageproficiencies: Prisma.$languageproficienciesPayload<ExtArgs>[]
      professionalqualifications: Prisma.$professionalqualificationsPayload<ExtArgs>[]
      researchandpublications: Prisma.$researchandpublicationsPayload<ExtArgs>[]
      specialqualifications: Prisma.$specialqualificationsPayload<ExtArgs>[]
      universityeducations: Prisma.$universityeducationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ApplicationID: number
      UserID: number | null
      JobID: number | null
      SubmissionDate: Date | null
      Status: $Enums.application_Status | null
      Remarks: string | null
    }, ExtArgs["result"]["application"]>
    composites: {}
  }

  type applicationGetPayload<S extends boolean | null | undefined | applicationDefaultArgs> = $Result.GetResult<Prisma.$applicationPayload, S>

  type applicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<applicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicationCountAggregateInputType | true
    }

  export interface applicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['application'], meta: { name: 'application' } }
    /**
     * Find zero or one Application that matches the filter.
     * @param {applicationFindUniqueArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends applicationFindUniqueArgs>(args: SelectSubset<T, applicationFindUniqueArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Application that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {applicationFindUniqueOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends applicationFindUniqueOrThrowArgs>(args: SelectSubset<T, applicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Application that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationFindFirstArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends applicationFindFirstArgs>(args?: SelectSubset<T, applicationFindFirstArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Application that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationFindFirstOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends applicationFindFirstOrThrowArgs>(args?: SelectSubset<T, applicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applications
     * const applications = await prisma.application.findMany()
     * 
     * // Get first 10 Applications
     * const applications = await prisma.application.findMany({ take: 10 })
     * 
     * // Only select the `ApplicationID`
     * const applicationWithApplicationIDOnly = await prisma.application.findMany({ select: { ApplicationID: true } })
     * 
     */
    findMany<T extends applicationFindManyArgs>(args?: SelectSubset<T, applicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Application.
     * @param {applicationCreateArgs} args - Arguments to create a Application.
     * @example
     * // Create one Application
     * const Application = await prisma.application.create({
     *   data: {
     *     // ... data to create a Application
     *   }
     * })
     * 
     */
    create<T extends applicationCreateArgs>(args: SelectSubset<T, applicationCreateArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Applications.
     * @param {applicationCreateManyArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends applicationCreateManyArgs>(args?: SelectSubset<T, applicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Application.
     * @param {applicationDeleteArgs} args - Arguments to delete one Application.
     * @example
     * // Delete one Application
     * const Application = await prisma.application.delete({
     *   where: {
     *     // ... filter to delete one Application
     *   }
     * })
     * 
     */
    delete<T extends applicationDeleteArgs>(args: SelectSubset<T, applicationDeleteArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Application.
     * @param {applicationUpdateArgs} args - Arguments to update one Application.
     * @example
     * // Update one Application
     * const application = await prisma.application.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends applicationUpdateArgs>(args: SelectSubset<T, applicationUpdateArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Applications.
     * @param {applicationDeleteManyArgs} args - Arguments to filter Applications to delete.
     * @example
     * // Delete a few Applications
     * const { count } = await prisma.application.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends applicationDeleteManyArgs>(args?: SelectSubset<T, applicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applications
     * const application = await prisma.application.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends applicationUpdateManyArgs>(args: SelectSubset<T, applicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Application.
     * @param {applicationUpsertArgs} args - Arguments to update or create a Application.
     * @example
     * // Update or create a Application
     * const application = await prisma.application.upsert({
     *   create: {
     *     // ... data to create a Application
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Application we want to update
     *   }
     * })
     */
    upsert<T extends applicationUpsertArgs>(args: SelectSubset<T, applicationUpsertArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationCountArgs} args - Arguments to filter Applications to count.
     * @example
     * // Count the number of Applications
     * const count = await prisma.application.count({
     *   where: {
     *     // ... the filter for the Applications we want to count
     *   }
     * })
    **/
    count<T extends applicationCountArgs>(
      args?: Subset<T, applicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationAggregateArgs>(args: Subset<T, ApplicationAggregateArgs>): Prisma.PrismaPromise<GetApplicationAggregateType<T>>

    /**
     * Group by Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends applicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: applicationGroupByArgs['orderBy'] }
        : { orderBy?: applicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, applicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the application model
   */
  readonly fields: applicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for application.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__applicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    additionalinfo<T extends application$additionalinfoArgs<ExtArgs> = {}>(args?: Subset<T, application$additionalinfoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$additionalinfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends application$userArgs<ExtArgs> = {}>(args?: Subset<T, application$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    jobvacancy<T extends application$jobvacancyArgs<ExtArgs> = {}>(args?: Subset<T, application$jobvacancyArgs<ExtArgs>>): Prisma__jobvacancyClient<$Result.GetResult<Prisma.$jobvacancyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    applicationattachments<T extends application$applicationattachmentsArgs<ExtArgs> = {}>(args?: Subset<T, application$applicationattachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationattachmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    applicationgeneraldetails<T extends application$applicationgeneraldetailsArgs<ExtArgs> = {}>(args?: Subset<T, application$applicationgeneraldetailsArgs<ExtArgs>>): Prisma__applicationgeneraldetailsClient<$Result.GetResult<Prisma.$applicationgeneraldetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    applicationreferences<T extends application$applicationreferencesArgs<ExtArgs> = {}>(args?: Subset<T, application$applicationreferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationreferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employmenthistories<T extends application$employmenthistoriesArgs<ExtArgs> = {}>(args?: Subset<T, application$employmenthistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employmenthistoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    experiencedetails<T extends application$experiencedetailsArgs<ExtArgs> = {}>(args?: Subset<T, application$experiencedetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$experiencedetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gce_al_results<T extends application$gce_al_resultsArgs<ExtArgs> = {}>(args?: Subset<T, application$gce_al_resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gce_al_resultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gce_ol_results<T extends application$gce_ol_resultsArgs<ExtArgs> = {}>(args?: Subset<T, application$gce_ol_resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gce_ol_resultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    languageproficiencies<T extends application$languageproficienciesArgs<ExtArgs> = {}>(args?: Subset<T, application$languageproficienciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$languageproficienciesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    professionalqualifications<T extends application$professionalqualificationsArgs<ExtArgs> = {}>(args?: Subset<T, application$professionalqualificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$professionalqualificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    researchandpublications<T extends application$researchandpublicationsArgs<ExtArgs> = {}>(args?: Subset<T, application$researchandpublicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$researchandpublicationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    specialqualifications<T extends application$specialqualificationsArgs<ExtArgs> = {}>(args?: Subset<T, application$specialqualificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$specialqualificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    universityeducations<T extends application$universityeducationsArgs<ExtArgs> = {}>(args?: Subset<T, application$universityeducationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$universityeducationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the application model
   */
  interface applicationFieldRefs {
    readonly ApplicationID: FieldRef<"application", 'Int'>
    readonly UserID: FieldRef<"application", 'Int'>
    readonly JobID: FieldRef<"application", 'Int'>
    readonly SubmissionDate: FieldRef<"application", 'DateTime'>
    readonly Status: FieldRef<"application", 'application_Status'>
    readonly Remarks: FieldRef<"application", 'String'>
  }
    

  // Custom InputTypes
  /**
   * application findUnique
   */
  export type applicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    /**
     * Filter, which application to fetch.
     */
    where: applicationWhereUniqueInput
  }

  /**
   * application findUniqueOrThrow
   */
  export type applicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    /**
     * Filter, which application to fetch.
     */
    where: applicationWhereUniqueInput
  }

  /**
   * application findFirst
   */
  export type applicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    /**
     * Filter, which application to fetch.
     */
    where?: applicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applications to fetch.
     */
    orderBy?: applicationOrderByWithRelationInput | applicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applications.
     */
    cursor?: applicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * application findFirstOrThrow
   */
  export type applicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    /**
     * Filter, which application to fetch.
     */
    where?: applicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applications to fetch.
     */
    orderBy?: applicationOrderByWithRelationInput | applicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applications.
     */
    cursor?: applicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * application findMany
   */
  export type applicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    /**
     * Filter, which applications to fetch.
     */
    where?: applicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applications to fetch.
     */
    orderBy?: applicationOrderByWithRelationInput | applicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing applications.
     */
    cursor?: applicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applications.
     */
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * application create
   */
  export type applicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    /**
     * The data needed to create a application.
     */
    data?: XOR<applicationCreateInput, applicationUncheckedCreateInput>
  }

  /**
   * application createMany
   */
  export type applicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many applications.
     */
    data: applicationCreateManyInput | applicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * application update
   */
  export type applicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    /**
     * The data needed to update a application.
     */
    data: XOR<applicationUpdateInput, applicationUncheckedUpdateInput>
    /**
     * Choose, which application to update.
     */
    where: applicationWhereUniqueInput
  }

  /**
   * application updateMany
   */
  export type applicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update applications.
     */
    data: XOR<applicationUpdateManyMutationInput, applicationUncheckedUpdateManyInput>
    /**
     * Filter which applications to update
     */
    where?: applicationWhereInput
    /**
     * Limit how many applications to update.
     */
    limit?: number
  }

  /**
   * application upsert
   */
  export type applicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    /**
     * The filter to search for the application to update in case it exists.
     */
    where: applicationWhereUniqueInput
    /**
     * In case the application found by the `where` argument doesn't exist, create a new application with this data.
     */
    create: XOR<applicationCreateInput, applicationUncheckedCreateInput>
    /**
     * In case the application was found with the provided `where` argument, update it with this data.
     */
    update: XOR<applicationUpdateInput, applicationUncheckedUpdateInput>
  }

  /**
   * application delete
   */
  export type applicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    /**
     * Filter which application to delete.
     */
    where: applicationWhereUniqueInput
  }

  /**
   * application deleteMany
   */
  export type applicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applications to delete
     */
    where?: applicationWhereInput
    /**
     * Limit how many applications to delete.
     */
    limit?: number
  }

  /**
   * application.additionalinfo
   */
  export type application$additionalinfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the additionalinfo
     */
    select?: additionalinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the additionalinfo
     */
    omit?: additionalinfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: additionalinfoInclude<ExtArgs> | null
    where?: additionalinfoWhereInput
    orderBy?: additionalinfoOrderByWithRelationInput | additionalinfoOrderByWithRelationInput[]
    cursor?: additionalinfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdditionalinfoScalarFieldEnum | AdditionalinfoScalarFieldEnum[]
  }

  /**
   * application.user
   */
  export type application$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * application.jobvacancy
   */
  export type application$jobvacancyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobvacancy
     */
    select?: jobvacancySelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobvacancy
     */
    omit?: jobvacancyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobvacancyInclude<ExtArgs> | null
    where?: jobvacancyWhereInput
  }

  /**
   * application.applicationattachments
   */
  export type application$applicationattachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationattachments
     */
    select?: applicationattachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationattachments
     */
    omit?: applicationattachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationattachmentsInclude<ExtArgs> | null
    where?: applicationattachmentsWhereInput
    orderBy?: applicationattachmentsOrderByWithRelationInput | applicationattachmentsOrderByWithRelationInput[]
    cursor?: applicationattachmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationattachmentsScalarFieldEnum | ApplicationattachmentsScalarFieldEnum[]
  }

  /**
   * application.applicationgeneraldetails
   */
  export type application$applicationgeneraldetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationgeneraldetails
     */
    select?: applicationgeneraldetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationgeneraldetails
     */
    omit?: applicationgeneraldetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationgeneraldetailsInclude<ExtArgs> | null
    where?: applicationgeneraldetailsWhereInput
  }

  /**
   * application.applicationreferences
   */
  export type application$applicationreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationreferences
     */
    select?: applicationreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationreferences
     */
    omit?: applicationreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationreferencesInclude<ExtArgs> | null
    where?: applicationreferencesWhereInput
    orderBy?: applicationreferencesOrderByWithRelationInput | applicationreferencesOrderByWithRelationInput[]
    cursor?: applicationreferencesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationreferencesScalarFieldEnum | ApplicationreferencesScalarFieldEnum[]
  }

  /**
   * application.employmenthistories
   */
  export type application$employmenthistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenthistories
     */
    select?: employmenthistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenthistories
     */
    omit?: employmenthistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenthistoriesInclude<ExtArgs> | null
    where?: employmenthistoriesWhereInput
    orderBy?: employmenthistoriesOrderByWithRelationInput | employmenthistoriesOrderByWithRelationInput[]
    cursor?: employmenthistoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmploymenthistoriesScalarFieldEnum | EmploymenthistoriesScalarFieldEnum[]
  }

  /**
   * application.experiencedetails
   */
  export type application$experiencedetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiencedetails
     */
    select?: experiencedetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiencedetails
     */
    omit?: experiencedetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencedetailsInclude<ExtArgs> | null
    where?: experiencedetailsWhereInput
    orderBy?: experiencedetailsOrderByWithRelationInput | experiencedetailsOrderByWithRelationInput[]
    cursor?: experiencedetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExperiencedetailsScalarFieldEnum | ExperiencedetailsScalarFieldEnum[]
  }

  /**
   * application.gce_al_results
   */
  export type application$gce_al_resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_al_results
     */
    select?: gce_al_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_al_results
     */
    omit?: gce_al_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_al_resultsInclude<ExtArgs> | null
    where?: gce_al_resultsWhereInput
    orderBy?: gce_al_resultsOrderByWithRelationInput | gce_al_resultsOrderByWithRelationInput[]
    cursor?: gce_al_resultsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Gce_al_resultsScalarFieldEnum | Gce_al_resultsScalarFieldEnum[]
  }

  /**
   * application.gce_ol_results
   */
  export type application$gce_ol_resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_ol_results
     */
    select?: gce_ol_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_ol_results
     */
    omit?: gce_ol_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_ol_resultsInclude<ExtArgs> | null
    where?: gce_ol_resultsWhereInput
    orderBy?: gce_ol_resultsOrderByWithRelationInput | gce_ol_resultsOrderByWithRelationInput[]
    cursor?: gce_ol_resultsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Gce_ol_resultsScalarFieldEnum | Gce_ol_resultsScalarFieldEnum[]
  }

  /**
   * application.languageproficiencies
   */
  export type application$languageproficienciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languageproficiencies
     */
    select?: languageproficienciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languageproficiencies
     */
    omit?: languageproficienciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageproficienciesInclude<ExtArgs> | null
    where?: languageproficienciesWhereInput
    orderBy?: languageproficienciesOrderByWithRelationInput | languageproficienciesOrderByWithRelationInput[]
    cursor?: languageproficienciesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LanguageproficienciesScalarFieldEnum | LanguageproficienciesScalarFieldEnum[]
  }

  /**
   * application.professionalqualifications
   */
  export type application$professionalqualificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professionalqualifications
     */
    select?: professionalqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the professionalqualifications
     */
    omit?: professionalqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professionalqualificationsInclude<ExtArgs> | null
    where?: professionalqualificationsWhereInput
    orderBy?: professionalqualificationsOrderByWithRelationInput | professionalqualificationsOrderByWithRelationInput[]
    cursor?: professionalqualificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfessionalqualificationsScalarFieldEnum | ProfessionalqualificationsScalarFieldEnum[]
  }

  /**
   * application.researchandpublications
   */
  export type application$researchandpublicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the researchandpublications
     */
    select?: researchandpublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the researchandpublications
     */
    omit?: researchandpublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: researchandpublicationsInclude<ExtArgs> | null
    where?: researchandpublicationsWhereInput
    orderBy?: researchandpublicationsOrderByWithRelationInput | researchandpublicationsOrderByWithRelationInput[]
    cursor?: researchandpublicationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchandpublicationsScalarFieldEnum | ResearchandpublicationsScalarFieldEnum[]
  }

  /**
   * application.specialqualifications
   */
  export type application$specialqualificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialqualifications
     */
    select?: specialqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the specialqualifications
     */
    omit?: specialqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: specialqualificationsInclude<ExtArgs> | null
    where?: specialqualificationsWhereInput
    orderBy?: specialqualificationsOrderByWithRelationInput | specialqualificationsOrderByWithRelationInput[]
    cursor?: specialqualificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecialqualificationsScalarFieldEnum | SpecialqualificationsScalarFieldEnum[]
  }

  /**
   * application.universityeducations
   */
  export type application$universityeducationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the universityeducations
     */
    select?: universityeducationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the universityeducations
     */
    omit?: universityeducationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: universityeducationsInclude<ExtArgs> | null
    where?: universityeducationsWhereInput
    orderBy?: universityeducationsOrderByWithRelationInput | universityeducationsOrderByWithRelationInput[]
    cursor?: universityeducationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UniversityeducationsScalarFieldEnum | UniversityeducationsScalarFieldEnum[]
  }

  /**
   * application without action
   */
  export type applicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
  }


  /**
   * Model applicationattachments
   */

  export type AggregateApplicationattachments = {
    _count: ApplicationattachmentsCountAggregateOutputType | null
    _avg: ApplicationattachmentsAvgAggregateOutputType | null
    _sum: ApplicationattachmentsSumAggregateOutputType | null
    _min: ApplicationattachmentsMinAggregateOutputType | null
    _max: ApplicationattachmentsMaxAggregateOutputType | null
  }

  export type ApplicationattachmentsAvgAggregateOutputType = {
    AttachmentID: number | null
    ApplicationID: number | null
  }

  export type ApplicationattachmentsSumAggregateOutputType = {
    AttachmentID: number | null
    ApplicationID: number | null
  }

  export type ApplicationattachmentsMinAggregateOutputType = {
    AttachmentID: number | null
    ApplicationID: number | null
    FileType: string | null
    FilePath: string | null
    UploadedAt: Date | null
  }

  export type ApplicationattachmentsMaxAggregateOutputType = {
    AttachmentID: number | null
    ApplicationID: number | null
    FileType: string | null
    FilePath: string | null
    UploadedAt: Date | null
  }

  export type ApplicationattachmentsCountAggregateOutputType = {
    AttachmentID: number
    ApplicationID: number
    FileType: number
    FilePath: number
    UploadedAt: number
    _all: number
  }


  export type ApplicationattachmentsAvgAggregateInputType = {
    AttachmentID?: true
    ApplicationID?: true
  }

  export type ApplicationattachmentsSumAggregateInputType = {
    AttachmentID?: true
    ApplicationID?: true
  }

  export type ApplicationattachmentsMinAggregateInputType = {
    AttachmentID?: true
    ApplicationID?: true
    FileType?: true
    FilePath?: true
    UploadedAt?: true
  }

  export type ApplicationattachmentsMaxAggregateInputType = {
    AttachmentID?: true
    ApplicationID?: true
    FileType?: true
    FilePath?: true
    UploadedAt?: true
  }

  export type ApplicationattachmentsCountAggregateInputType = {
    AttachmentID?: true
    ApplicationID?: true
    FileType?: true
    FilePath?: true
    UploadedAt?: true
    _all?: true
  }

  export type ApplicationattachmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applicationattachments to aggregate.
     */
    where?: applicationattachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationattachments to fetch.
     */
    orderBy?: applicationattachmentsOrderByWithRelationInput | applicationattachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: applicationattachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationattachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationattachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned applicationattachments
    **/
    _count?: true | ApplicationattachmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApplicationattachmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApplicationattachmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationattachmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationattachmentsMaxAggregateInputType
  }

  export type GetApplicationattachmentsAggregateType<T extends ApplicationattachmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateApplicationattachments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplicationattachments[P]>
      : GetScalarType<T[P], AggregateApplicationattachments[P]>
  }




  export type applicationattachmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicationattachmentsWhereInput
    orderBy?: applicationattachmentsOrderByWithAggregationInput | applicationattachmentsOrderByWithAggregationInput[]
    by: ApplicationattachmentsScalarFieldEnum[] | ApplicationattachmentsScalarFieldEnum
    having?: applicationattachmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationattachmentsCountAggregateInputType | true
    _avg?: ApplicationattachmentsAvgAggregateInputType
    _sum?: ApplicationattachmentsSumAggregateInputType
    _min?: ApplicationattachmentsMinAggregateInputType
    _max?: ApplicationattachmentsMaxAggregateInputType
  }

  export type ApplicationattachmentsGroupByOutputType = {
    AttachmentID: number
    ApplicationID: number | null
    FileType: string | null
    FilePath: string | null
    UploadedAt: Date | null
    _count: ApplicationattachmentsCountAggregateOutputType | null
    _avg: ApplicationattachmentsAvgAggregateOutputType | null
    _sum: ApplicationattachmentsSumAggregateOutputType | null
    _min: ApplicationattachmentsMinAggregateOutputType | null
    _max: ApplicationattachmentsMaxAggregateOutputType | null
  }

  type GetApplicationattachmentsGroupByPayload<T extends applicationattachmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationattachmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationattachmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationattachmentsGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationattachmentsGroupByOutputType[P]>
        }
      >
    >


  export type applicationattachmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    AttachmentID?: boolean
    ApplicationID?: boolean
    FileType?: boolean
    FilePath?: boolean
    UploadedAt?: boolean
    application?: boolean | applicationattachments$applicationArgs<ExtArgs>
  }, ExtArgs["result"]["applicationattachments"]>



  export type applicationattachmentsSelectScalar = {
    AttachmentID?: boolean
    ApplicationID?: boolean
    FileType?: boolean
    FilePath?: boolean
    UploadedAt?: boolean
  }

  export type applicationattachmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"AttachmentID" | "ApplicationID" | "FileType" | "FilePath" | "UploadedAt", ExtArgs["result"]["applicationattachments"]>
  export type applicationattachmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | applicationattachments$applicationArgs<ExtArgs>
  }

  export type $applicationattachmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "applicationattachments"
    objects: {
      application: Prisma.$applicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      AttachmentID: number
      ApplicationID: number | null
      FileType: string | null
      FilePath: string | null
      UploadedAt: Date | null
    }, ExtArgs["result"]["applicationattachments"]>
    composites: {}
  }

  type applicationattachmentsGetPayload<S extends boolean | null | undefined | applicationattachmentsDefaultArgs> = $Result.GetResult<Prisma.$applicationattachmentsPayload, S>

  type applicationattachmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<applicationattachmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicationattachmentsCountAggregateInputType | true
    }

  export interface applicationattachmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['applicationattachments'], meta: { name: 'applicationattachments' } }
    /**
     * Find zero or one Applicationattachments that matches the filter.
     * @param {applicationattachmentsFindUniqueArgs} args - Arguments to find a Applicationattachments
     * @example
     * // Get one Applicationattachments
     * const applicationattachments = await prisma.applicationattachments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends applicationattachmentsFindUniqueArgs>(args: SelectSubset<T, applicationattachmentsFindUniqueArgs<ExtArgs>>): Prisma__applicationattachmentsClient<$Result.GetResult<Prisma.$applicationattachmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Applicationattachments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {applicationattachmentsFindUniqueOrThrowArgs} args - Arguments to find a Applicationattachments
     * @example
     * // Get one Applicationattachments
     * const applicationattachments = await prisma.applicationattachments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends applicationattachmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, applicationattachmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__applicationattachmentsClient<$Result.GetResult<Prisma.$applicationattachmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Applicationattachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationattachmentsFindFirstArgs} args - Arguments to find a Applicationattachments
     * @example
     * // Get one Applicationattachments
     * const applicationattachments = await prisma.applicationattachments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends applicationattachmentsFindFirstArgs>(args?: SelectSubset<T, applicationattachmentsFindFirstArgs<ExtArgs>>): Prisma__applicationattachmentsClient<$Result.GetResult<Prisma.$applicationattachmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Applicationattachments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationattachmentsFindFirstOrThrowArgs} args - Arguments to find a Applicationattachments
     * @example
     * // Get one Applicationattachments
     * const applicationattachments = await prisma.applicationattachments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends applicationattachmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, applicationattachmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__applicationattachmentsClient<$Result.GetResult<Prisma.$applicationattachmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Applicationattachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationattachmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applicationattachments
     * const applicationattachments = await prisma.applicationattachments.findMany()
     * 
     * // Get first 10 Applicationattachments
     * const applicationattachments = await prisma.applicationattachments.findMany({ take: 10 })
     * 
     * // Only select the `AttachmentID`
     * const applicationattachmentsWithAttachmentIDOnly = await prisma.applicationattachments.findMany({ select: { AttachmentID: true } })
     * 
     */
    findMany<T extends applicationattachmentsFindManyArgs>(args?: SelectSubset<T, applicationattachmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationattachmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Applicationattachments.
     * @param {applicationattachmentsCreateArgs} args - Arguments to create a Applicationattachments.
     * @example
     * // Create one Applicationattachments
     * const Applicationattachments = await prisma.applicationattachments.create({
     *   data: {
     *     // ... data to create a Applicationattachments
     *   }
     * })
     * 
     */
    create<T extends applicationattachmentsCreateArgs>(args: SelectSubset<T, applicationattachmentsCreateArgs<ExtArgs>>): Prisma__applicationattachmentsClient<$Result.GetResult<Prisma.$applicationattachmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Applicationattachments.
     * @param {applicationattachmentsCreateManyArgs} args - Arguments to create many Applicationattachments.
     * @example
     * // Create many Applicationattachments
     * const applicationattachments = await prisma.applicationattachments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends applicationattachmentsCreateManyArgs>(args?: SelectSubset<T, applicationattachmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Applicationattachments.
     * @param {applicationattachmentsDeleteArgs} args - Arguments to delete one Applicationattachments.
     * @example
     * // Delete one Applicationattachments
     * const Applicationattachments = await prisma.applicationattachments.delete({
     *   where: {
     *     // ... filter to delete one Applicationattachments
     *   }
     * })
     * 
     */
    delete<T extends applicationattachmentsDeleteArgs>(args: SelectSubset<T, applicationattachmentsDeleteArgs<ExtArgs>>): Prisma__applicationattachmentsClient<$Result.GetResult<Prisma.$applicationattachmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Applicationattachments.
     * @param {applicationattachmentsUpdateArgs} args - Arguments to update one Applicationattachments.
     * @example
     * // Update one Applicationattachments
     * const applicationattachments = await prisma.applicationattachments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends applicationattachmentsUpdateArgs>(args: SelectSubset<T, applicationattachmentsUpdateArgs<ExtArgs>>): Prisma__applicationattachmentsClient<$Result.GetResult<Prisma.$applicationattachmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Applicationattachments.
     * @param {applicationattachmentsDeleteManyArgs} args - Arguments to filter Applicationattachments to delete.
     * @example
     * // Delete a few Applicationattachments
     * const { count } = await prisma.applicationattachments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends applicationattachmentsDeleteManyArgs>(args?: SelectSubset<T, applicationattachmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applicationattachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationattachmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applicationattachments
     * const applicationattachments = await prisma.applicationattachments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends applicationattachmentsUpdateManyArgs>(args: SelectSubset<T, applicationattachmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Applicationattachments.
     * @param {applicationattachmentsUpsertArgs} args - Arguments to update or create a Applicationattachments.
     * @example
     * // Update or create a Applicationattachments
     * const applicationattachments = await prisma.applicationattachments.upsert({
     *   create: {
     *     // ... data to create a Applicationattachments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Applicationattachments we want to update
     *   }
     * })
     */
    upsert<T extends applicationattachmentsUpsertArgs>(args: SelectSubset<T, applicationattachmentsUpsertArgs<ExtArgs>>): Prisma__applicationattachmentsClient<$Result.GetResult<Prisma.$applicationattachmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Applicationattachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationattachmentsCountArgs} args - Arguments to filter Applicationattachments to count.
     * @example
     * // Count the number of Applicationattachments
     * const count = await prisma.applicationattachments.count({
     *   where: {
     *     // ... the filter for the Applicationattachments we want to count
     *   }
     * })
    **/
    count<T extends applicationattachmentsCountArgs>(
      args?: Subset<T, applicationattachmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationattachmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Applicationattachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationattachmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationattachmentsAggregateArgs>(args: Subset<T, ApplicationattachmentsAggregateArgs>): Prisma.PrismaPromise<GetApplicationattachmentsAggregateType<T>>

    /**
     * Group by Applicationattachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationattachmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends applicationattachmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: applicationattachmentsGroupByArgs['orderBy'] }
        : { orderBy?: applicationattachmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, applicationattachmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationattachmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the applicationattachments model
   */
  readonly fields: applicationattachmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for applicationattachments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__applicationattachmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends applicationattachments$applicationArgs<ExtArgs> = {}>(args?: Subset<T, applicationattachments$applicationArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the applicationattachments model
   */
  interface applicationattachmentsFieldRefs {
    readonly AttachmentID: FieldRef<"applicationattachments", 'Int'>
    readonly ApplicationID: FieldRef<"applicationattachments", 'Int'>
    readonly FileType: FieldRef<"applicationattachments", 'String'>
    readonly FilePath: FieldRef<"applicationattachments", 'String'>
    readonly UploadedAt: FieldRef<"applicationattachments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * applicationattachments findUnique
   */
  export type applicationattachmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationattachments
     */
    select?: applicationattachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationattachments
     */
    omit?: applicationattachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationattachmentsInclude<ExtArgs> | null
    /**
     * Filter, which applicationattachments to fetch.
     */
    where: applicationattachmentsWhereUniqueInput
  }

  /**
   * applicationattachments findUniqueOrThrow
   */
  export type applicationattachmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationattachments
     */
    select?: applicationattachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationattachments
     */
    omit?: applicationattachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationattachmentsInclude<ExtArgs> | null
    /**
     * Filter, which applicationattachments to fetch.
     */
    where: applicationattachmentsWhereUniqueInput
  }

  /**
   * applicationattachments findFirst
   */
  export type applicationattachmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationattachments
     */
    select?: applicationattachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationattachments
     */
    omit?: applicationattachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationattachmentsInclude<ExtArgs> | null
    /**
     * Filter, which applicationattachments to fetch.
     */
    where?: applicationattachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationattachments to fetch.
     */
    orderBy?: applicationattachmentsOrderByWithRelationInput | applicationattachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applicationattachments.
     */
    cursor?: applicationattachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationattachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationattachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applicationattachments.
     */
    distinct?: ApplicationattachmentsScalarFieldEnum | ApplicationattachmentsScalarFieldEnum[]
  }

  /**
   * applicationattachments findFirstOrThrow
   */
  export type applicationattachmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationattachments
     */
    select?: applicationattachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationattachments
     */
    omit?: applicationattachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationattachmentsInclude<ExtArgs> | null
    /**
     * Filter, which applicationattachments to fetch.
     */
    where?: applicationattachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationattachments to fetch.
     */
    orderBy?: applicationattachmentsOrderByWithRelationInput | applicationattachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applicationattachments.
     */
    cursor?: applicationattachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationattachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationattachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applicationattachments.
     */
    distinct?: ApplicationattachmentsScalarFieldEnum | ApplicationattachmentsScalarFieldEnum[]
  }

  /**
   * applicationattachments findMany
   */
  export type applicationattachmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationattachments
     */
    select?: applicationattachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationattachments
     */
    omit?: applicationattachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationattachmentsInclude<ExtArgs> | null
    /**
     * Filter, which applicationattachments to fetch.
     */
    where?: applicationattachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationattachments to fetch.
     */
    orderBy?: applicationattachmentsOrderByWithRelationInput | applicationattachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing applicationattachments.
     */
    cursor?: applicationattachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationattachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationattachments.
     */
    skip?: number
    distinct?: ApplicationattachmentsScalarFieldEnum | ApplicationattachmentsScalarFieldEnum[]
  }

  /**
   * applicationattachments create
   */
  export type applicationattachmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationattachments
     */
    select?: applicationattachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationattachments
     */
    omit?: applicationattachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationattachmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a applicationattachments.
     */
    data?: XOR<applicationattachmentsCreateInput, applicationattachmentsUncheckedCreateInput>
  }

  /**
   * applicationattachments createMany
   */
  export type applicationattachmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many applicationattachments.
     */
    data: applicationattachmentsCreateManyInput | applicationattachmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * applicationattachments update
   */
  export type applicationattachmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationattachments
     */
    select?: applicationattachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationattachments
     */
    omit?: applicationattachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationattachmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a applicationattachments.
     */
    data: XOR<applicationattachmentsUpdateInput, applicationattachmentsUncheckedUpdateInput>
    /**
     * Choose, which applicationattachments to update.
     */
    where: applicationattachmentsWhereUniqueInput
  }

  /**
   * applicationattachments updateMany
   */
  export type applicationattachmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update applicationattachments.
     */
    data: XOR<applicationattachmentsUpdateManyMutationInput, applicationattachmentsUncheckedUpdateManyInput>
    /**
     * Filter which applicationattachments to update
     */
    where?: applicationattachmentsWhereInput
    /**
     * Limit how many applicationattachments to update.
     */
    limit?: number
  }

  /**
   * applicationattachments upsert
   */
  export type applicationattachmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationattachments
     */
    select?: applicationattachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationattachments
     */
    omit?: applicationattachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationattachmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the applicationattachments to update in case it exists.
     */
    where: applicationattachmentsWhereUniqueInput
    /**
     * In case the applicationattachments found by the `where` argument doesn't exist, create a new applicationattachments with this data.
     */
    create: XOR<applicationattachmentsCreateInput, applicationattachmentsUncheckedCreateInput>
    /**
     * In case the applicationattachments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<applicationattachmentsUpdateInput, applicationattachmentsUncheckedUpdateInput>
  }

  /**
   * applicationattachments delete
   */
  export type applicationattachmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationattachments
     */
    select?: applicationattachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationattachments
     */
    omit?: applicationattachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationattachmentsInclude<ExtArgs> | null
    /**
     * Filter which applicationattachments to delete.
     */
    where: applicationattachmentsWhereUniqueInput
  }

  /**
   * applicationattachments deleteMany
   */
  export type applicationattachmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applicationattachments to delete
     */
    where?: applicationattachmentsWhereInput
    /**
     * Limit how many applicationattachments to delete.
     */
    limit?: number
  }

  /**
   * applicationattachments.application
   */
  export type applicationattachments$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    where?: applicationWhereInput
  }

  /**
   * applicationattachments without action
   */
  export type applicationattachmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationattachments
     */
    select?: applicationattachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationattachments
     */
    omit?: applicationattachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationattachmentsInclude<ExtArgs> | null
  }


  /**
   * Model applicationgeneraldetails
   */

  export type AggregateApplicationgeneraldetails = {
    _count: ApplicationgeneraldetailsCountAggregateOutputType | null
    _avg: ApplicationgeneraldetailsAvgAggregateOutputType | null
    _sum: ApplicationgeneraldetailsSumAggregateOutputType | null
    _min: ApplicationgeneraldetailsMinAggregateOutputType | null
    _max: ApplicationgeneraldetailsMaxAggregateOutputType | null
  }

  export type ApplicationgeneraldetailsAvgAggregateOutputType = {
    ApplicationID: number | null
  }

  export type ApplicationgeneraldetailsSumAggregateOutputType = {
    ApplicationID: number | null
  }

  export type ApplicationgeneraldetailsMinAggregateOutputType = {
    ApplicationID: number | null
    PostApplied: string | null
    FullName: string | null
    NameWithInitials: string | null
    NIC: string | null
    DOB: Date | null
    Gender: $Enums.applicationgeneraldetails_Gender | null
    PhoneNumber: string | null
    Email: string | null
    PresentAddress: string | null
    PermanentAddress: string | null
    CivilStatus: string | null
    CitizenshipType: $Enums.applicationgeneraldetails_CitizenshipType | null
    CitizenshipDetails: string | null
    EthnicityOrReligion: string | null
  }

  export type ApplicationgeneraldetailsMaxAggregateOutputType = {
    ApplicationID: number | null
    PostApplied: string | null
    FullName: string | null
    NameWithInitials: string | null
    NIC: string | null
    DOB: Date | null
    Gender: $Enums.applicationgeneraldetails_Gender | null
    PhoneNumber: string | null
    Email: string | null
    PresentAddress: string | null
    PermanentAddress: string | null
    CivilStatus: string | null
    CitizenshipType: $Enums.applicationgeneraldetails_CitizenshipType | null
    CitizenshipDetails: string | null
    EthnicityOrReligion: string | null
  }

  export type ApplicationgeneraldetailsCountAggregateOutputType = {
    ApplicationID: number
    PostApplied: number
    FullName: number
    NameWithInitials: number
    NIC: number
    DOB: number
    Gender: number
    PhoneNumber: number
    Email: number
    PresentAddress: number
    PermanentAddress: number
    CivilStatus: number
    CitizenshipType: number
    CitizenshipDetails: number
    EthnicityOrReligion: number
    _all: number
  }


  export type ApplicationgeneraldetailsAvgAggregateInputType = {
    ApplicationID?: true
  }

  export type ApplicationgeneraldetailsSumAggregateInputType = {
    ApplicationID?: true
  }

  export type ApplicationgeneraldetailsMinAggregateInputType = {
    ApplicationID?: true
    PostApplied?: true
    FullName?: true
    NameWithInitials?: true
    NIC?: true
    DOB?: true
    Gender?: true
    PhoneNumber?: true
    Email?: true
    PresentAddress?: true
    PermanentAddress?: true
    CivilStatus?: true
    CitizenshipType?: true
    CitizenshipDetails?: true
    EthnicityOrReligion?: true
  }

  export type ApplicationgeneraldetailsMaxAggregateInputType = {
    ApplicationID?: true
    PostApplied?: true
    FullName?: true
    NameWithInitials?: true
    NIC?: true
    DOB?: true
    Gender?: true
    PhoneNumber?: true
    Email?: true
    PresentAddress?: true
    PermanentAddress?: true
    CivilStatus?: true
    CitizenshipType?: true
    CitizenshipDetails?: true
    EthnicityOrReligion?: true
  }

  export type ApplicationgeneraldetailsCountAggregateInputType = {
    ApplicationID?: true
    PostApplied?: true
    FullName?: true
    NameWithInitials?: true
    NIC?: true
    DOB?: true
    Gender?: true
    PhoneNumber?: true
    Email?: true
    PresentAddress?: true
    PermanentAddress?: true
    CivilStatus?: true
    CitizenshipType?: true
    CitizenshipDetails?: true
    EthnicityOrReligion?: true
    _all?: true
  }

  export type ApplicationgeneraldetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applicationgeneraldetails to aggregate.
     */
    where?: applicationgeneraldetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationgeneraldetails to fetch.
     */
    orderBy?: applicationgeneraldetailsOrderByWithRelationInput | applicationgeneraldetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: applicationgeneraldetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationgeneraldetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationgeneraldetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned applicationgeneraldetails
    **/
    _count?: true | ApplicationgeneraldetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApplicationgeneraldetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApplicationgeneraldetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationgeneraldetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationgeneraldetailsMaxAggregateInputType
  }

  export type GetApplicationgeneraldetailsAggregateType<T extends ApplicationgeneraldetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateApplicationgeneraldetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplicationgeneraldetails[P]>
      : GetScalarType<T[P], AggregateApplicationgeneraldetails[P]>
  }




  export type applicationgeneraldetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicationgeneraldetailsWhereInput
    orderBy?: applicationgeneraldetailsOrderByWithAggregationInput | applicationgeneraldetailsOrderByWithAggregationInput[]
    by: ApplicationgeneraldetailsScalarFieldEnum[] | ApplicationgeneraldetailsScalarFieldEnum
    having?: applicationgeneraldetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationgeneraldetailsCountAggregateInputType | true
    _avg?: ApplicationgeneraldetailsAvgAggregateInputType
    _sum?: ApplicationgeneraldetailsSumAggregateInputType
    _min?: ApplicationgeneraldetailsMinAggregateInputType
    _max?: ApplicationgeneraldetailsMaxAggregateInputType
  }

  export type ApplicationgeneraldetailsGroupByOutputType = {
    ApplicationID: number
    PostApplied: string | null
    FullName: string | null
    NameWithInitials: string | null
    NIC: string | null
    DOB: Date | null
    Gender: $Enums.applicationgeneraldetails_Gender | null
    PhoneNumber: string | null
    Email: string | null
    PresentAddress: string | null
    PermanentAddress: string | null
    CivilStatus: string | null
    CitizenshipType: $Enums.applicationgeneraldetails_CitizenshipType | null
    CitizenshipDetails: string | null
    EthnicityOrReligion: string | null
    _count: ApplicationgeneraldetailsCountAggregateOutputType | null
    _avg: ApplicationgeneraldetailsAvgAggregateOutputType | null
    _sum: ApplicationgeneraldetailsSumAggregateOutputType | null
    _min: ApplicationgeneraldetailsMinAggregateOutputType | null
    _max: ApplicationgeneraldetailsMaxAggregateOutputType | null
  }

  type GetApplicationgeneraldetailsGroupByPayload<T extends applicationgeneraldetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationgeneraldetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationgeneraldetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationgeneraldetailsGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationgeneraldetailsGroupByOutputType[P]>
        }
      >
    >


  export type applicationgeneraldetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ApplicationID?: boolean
    PostApplied?: boolean
    FullName?: boolean
    NameWithInitials?: boolean
    NIC?: boolean
    DOB?: boolean
    Gender?: boolean
    PhoneNumber?: boolean
    Email?: boolean
    PresentAddress?: boolean
    PermanentAddress?: boolean
    CivilStatus?: boolean
    CitizenshipType?: boolean
    CitizenshipDetails?: boolean
    EthnicityOrReligion?: boolean
    application?: boolean | applicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicationgeneraldetails"]>



  export type applicationgeneraldetailsSelectScalar = {
    ApplicationID?: boolean
    PostApplied?: boolean
    FullName?: boolean
    NameWithInitials?: boolean
    NIC?: boolean
    DOB?: boolean
    Gender?: boolean
    PhoneNumber?: boolean
    Email?: boolean
    PresentAddress?: boolean
    PermanentAddress?: boolean
    CivilStatus?: boolean
    CitizenshipType?: boolean
    CitizenshipDetails?: boolean
    EthnicityOrReligion?: boolean
  }

  export type applicationgeneraldetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ApplicationID" | "PostApplied" | "FullName" | "NameWithInitials" | "NIC" | "DOB" | "Gender" | "PhoneNumber" | "Email" | "PresentAddress" | "PermanentAddress" | "CivilStatus" | "CitizenshipType" | "CitizenshipDetails" | "EthnicityOrReligion", ExtArgs["result"]["applicationgeneraldetails"]>
  export type applicationgeneraldetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | applicationDefaultArgs<ExtArgs>
  }

  export type $applicationgeneraldetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "applicationgeneraldetails"
    objects: {
      application: Prisma.$applicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ApplicationID: number
      PostApplied: string | null
      FullName: string | null
      NameWithInitials: string | null
      NIC: string | null
      DOB: Date | null
      Gender: $Enums.applicationgeneraldetails_Gender | null
      PhoneNumber: string | null
      Email: string | null
      PresentAddress: string | null
      PermanentAddress: string | null
      CivilStatus: string | null
      CitizenshipType: $Enums.applicationgeneraldetails_CitizenshipType | null
      CitizenshipDetails: string | null
      EthnicityOrReligion: string | null
    }, ExtArgs["result"]["applicationgeneraldetails"]>
    composites: {}
  }

  type applicationgeneraldetailsGetPayload<S extends boolean | null | undefined | applicationgeneraldetailsDefaultArgs> = $Result.GetResult<Prisma.$applicationgeneraldetailsPayload, S>

  type applicationgeneraldetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<applicationgeneraldetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicationgeneraldetailsCountAggregateInputType | true
    }

  export interface applicationgeneraldetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['applicationgeneraldetails'], meta: { name: 'applicationgeneraldetails' } }
    /**
     * Find zero or one Applicationgeneraldetails that matches the filter.
     * @param {applicationgeneraldetailsFindUniqueArgs} args - Arguments to find a Applicationgeneraldetails
     * @example
     * // Get one Applicationgeneraldetails
     * const applicationgeneraldetails = await prisma.applicationgeneraldetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends applicationgeneraldetailsFindUniqueArgs>(args: SelectSubset<T, applicationgeneraldetailsFindUniqueArgs<ExtArgs>>): Prisma__applicationgeneraldetailsClient<$Result.GetResult<Prisma.$applicationgeneraldetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Applicationgeneraldetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {applicationgeneraldetailsFindUniqueOrThrowArgs} args - Arguments to find a Applicationgeneraldetails
     * @example
     * // Get one Applicationgeneraldetails
     * const applicationgeneraldetails = await prisma.applicationgeneraldetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends applicationgeneraldetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, applicationgeneraldetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__applicationgeneraldetailsClient<$Result.GetResult<Prisma.$applicationgeneraldetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Applicationgeneraldetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationgeneraldetailsFindFirstArgs} args - Arguments to find a Applicationgeneraldetails
     * @example
     * // Get one Applicationgeneraldetails
     * const applicationgeneraldetails = await prisma.applicationgeneraldetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends applicationgeneraldetailsFindFirstArgs>(args?: SelectSubset<T, applicationgeneraldetailsFindFirstArgs<ExtArgs>>): Prisma__applicationgeneraldetailsClient<$Result.GetResult<Prisma.$applicationgeneraldetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Applicationgeneraldetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationgeneraldetailsFindFirstOrThrowArgs} args - Arguments to find a Applicationgeneraldetails
     * @example
     * // Get one Applicationgeneraldetails
     * const applicationgeneraldetails = await prisma.applicationgeneraldetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends applicationgeneraldetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, applicationgeneraldetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__applicationgeneraldetailsClient<$Result.GetResult<Prisma.$applicationgeneraldetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Applicationgeneraldetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationgeneraldetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applicationgeneraldetails
     * const applicationgeneraldetails = await prisma.applicationgeneraldetails.findMany()
     * 
     * // Get first 10 Applicationgeneraldetails
     * const applicationgeneraldetails = await prisma.applicationgeneraldetails.findMany({ take: 10 })
     * 
     * // Only select the `ApplicationID`
     * const applicationgeneraldetailsWithApplicationIDOnly = await prisma.applicationgeneraldetails.findMany({ select: { ApplicationID: true } })
     * 
     */
    findMany<T extends applicationgeneraldetailsFindManyArgs>(args?: SelectSubset<T, applicationgeneraldetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationgeneraldetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Applicationgeneraldetails.
     * @param {applicationgeneraldetailsCreateArgs} args - Arguments to create a Applicationgeneraldetails.
     * @example
     * // Create one Applicationgeneraldetails
     * const Applicationgeneraldetails = await prisma.applicationgeneraldetails.create({
     *   data: {
     *     // ... data to create a Applicationgeneraldetails
     *   }
     * })
     * 
     */
    create<T extends applicationgeneraldetailsCreateArgs>(args: SelectSubset<T, applicationgeneraldetailsCreateArgs<ExtArgs>>): Prisma__applicationgeneraldetailsClient<$Result.GetResult<Prisma.$applicationgeneraldetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Applicationgeneraldetails.
     * @param {applicationgeneraldetailsCreateManyArgs} args - Arguments to create many Applicationgeneraldetails.
     * @example
     * // Create many Applicationgeneraldetails
     * const applicationgeneraldetails = await prisma.applicationgeneraldetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends applicationgeneraldetailsCreateManyArgs>(args?: SelectSubset<T, applicationgeneraldetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Applicationgeneraldetails.
     * @param {applicationgeneraldetailsDeleteArgs} args - Arguments to delete one Applicationgeneraldetails.
     * @example
     * // Delete one Applicationgeneraldetails
     * const Applicationgeneraldetails = await prisma.applicationgeneraldetails.delete({
     *   where: {
     *     // ... filter to delete one Applicationgeneraldetails
     *   }
     * })
     * 
     */
    delete<T extends applicationgeneraldetailsDeleteArgs>(args: SelectSubset<T, applicationgeneraldetailsDeleteArgs<ExtArgs>>): Prisma__applicationgeneraldetailsClient<$Result.GetResult<Prisma.$applicationgeneraldetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Applicationgeneraldetails.
     * @param {applicationgeneraldetailsUpdateArgs} args - Arguments to update one Applicationgeneraldetails.
     * @example
     * // Update one Applicationgeneraldetails
     * const applicationgeneraldetails = await prisma.applicationgeneraldetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends applicationgeneraldetailsUpdateArgs>(args: SelectSubset<T, applicationgeneraldetailsUpdateArgs<ExtArgs>>): Prisma__applicationgeneraldetailsClient<$Result.GetResult<Prisma.$applicationgeneraldetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Applicationgeneraldetails.
     * @param {applicationgeneraldetailsDeleteManyArgs} args - Arguments to filter Applicationgeneraldetails to delete.
     * @example
     * // Delete a few Applicationgeneraldetails
     * const { count } = await prisma.applicationgeneraldetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends applicationgeneraldetailsDeleteManyArgs>(args?: SelectSubset<T, applicationgeneraldetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applicationgeneraldetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationgeneraldetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applicationgeneraldetails
     * const applicationgeneraldetails = await prisma.applicationgeneraldetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends applicationgeneraldetailsUpdateManyArgs>(args: SelectSubset<T, applicationgeneraldetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Applicationgeneraldetails.
     * @param {applicationgeneraldetailsUpsertArgs} args - Arguments to update or create a Applicationgeneraldetails.
     * @example
     * // Update or create a Applicationgeneraldetails
     * const applicationgeneraldetails = await prisma.applicationgeneraldetails.upsert({
     *   create: {
     *     // ... data to create a Applicationgeneraldetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Applicationgeneraldetails we want to update
     *   }
     * })
     */
    upsert<T extends applicationgeneraldetailsUpsertArgs>(args: SelectSubset<T, applicationgeneraldetailsUpsertArgs<ExtArgs>>): Prisma__applicationgeneraldetailsClient<$Result.GetResult<Prisma.$applicationgeneraldetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Applicationgeneraldetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationgeneraldetailsCountArgs} args - Arguments to filter Applicationgeneraldetails to count.
     * @example
     * // Count the number of Applicationgeneraldetails
     * const count = await prisma.applicationgeneraldetails.count({
     *   where: {
     *     // ... the filter for the Applicationgeneraldetails we want to count
     *   }
     * })
    **/
    count<T extends applicationgeneraldetailsCountArgs>(
      args?: Subset<T, applicationgeneraldetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationgeneraldetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Applicationgeneraldetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationgeneraldetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationgeneraldetailsAggregateArgs>(args: Subset<T, ApplicationgeneraldetailsAggregateArgs>): Prisma.PrismaPromise<GetApplicationgeneraldetailsAggregateType<T>>

    /**
     * Group by Applicationgeneraldetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationgeneraldetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends applicationgeneraldetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: applicationgeneraldetailsGroupByArgs['orderBy'] }
        : { orderBy?: applicationgeneraldetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, applicationgeneraldetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationgeneraldetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the applicationgeneraldetails model
   */
  readonly fields: applicationgeneraldetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for applicationgeneraldetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__applicationgeneraldetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends applicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, applicationDefaultArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the applicationgeneraldetails model
   */
  interface applicationgeneraldetailsFieldRefs {
    readonly ApplicationID: FieldRef<"applicationgeneraldetails", 'Int'>
    readonly PostApplied: FieldRef<"applicationgeneraldetails", 'String'>
    readonly FullName: FieldRef<"applicationgeneraldetails", 'String'>
    readonly NameWithInitials: FieldRef<"applicationgeneraldetails", 'String'>
    readonly NIC: FieldRef<"applicationgeneraldetails", 'String'>
    readonly DOB: FieldRef<"applicationgeneraldetails", 'DateTime'>
    readonly Gender: FieldRef<"applicationgeneraldetails", 'applicationgeneraldetails_Gender'>
    readonly PhoneNumber: FieldRef<"applicationgeneraldetails", 'String'>
    readonly Email: FieldRef<"applicationgeneraldetails", 'String'>
    readonly PresentAddress: FieldRef<"applicationgeneraldetails", 'String'>
    readonly PermanentAddress: FieldRef<"applicationgeneraldetails", 'String'>
    readonly CivilStatus: FieldRef<"applicationgeneraldetails", 'String'>
    readonly CitizenshipType: FieldRef<"applicationgeneraldetails", 'applicationgeneraldetails_CitizenshipType'>
    readonly CitizenshipDetails: FieldRef<"applicationgeneraldetails", 'String'>
    readonly EthnicityOrReligion: FieldRef<"applicationgeneraldetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * applicationgeneraldetails findUnique
   */
  export type applicationgeneraldetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationgeneraldetails
     */
    select?: applicationgeneraldetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationgeneraldetails
     */
    omit?: applicationgeneraldetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationgeneraldetailsInclude<ExtArgs> | null
    /**
     * Filter, which applicationgeneraldetails to fetch.
     */
    where: applicationgeneraldetailsWhereUniqueInput
  }

  /**
   * applicationgeneraldetails findUniqueOrThrow
   */
  export type applicationgeneraldetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationgeneraldetails
     */
    select?: applicationgeneraldetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationgeneraldetails
     */
    omit?: applicationgeneraldetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationgeneraldetailsInclude<ExtArgs> | null
    /**
     * Filter, which applicationgeneraldetails to fetch.
     */
    where: applicationgeneraldetailsWhereUniqueInput
  }

  /**
   * applicationgeneraldetails findFirst
   */
  export type applicationgeneraldetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationgeneraldetails
     */
    select?: applicationgeneraldetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationgeneraldetails
     */
    omit?: applicationgeneraldetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationgeneraldetailsInclude<ExtArgs> | null
    /**
     * Filter, which applicationgeneraldetails to fetch.
     */
    where?: applicationgeneraldetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationgeneraldetails to fetch.
     */
    orderBy?: applicationgeneraldetailsOrderByWithRelationInput | applicationgeneraldetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applicationgeneraldetails.
     */
    cursor?: applicationgeneraldetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationgeneraldetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationgeneraldetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applicationgeneraldetails.
     */
    distinct?: ApplicationgeneraldetailsScalarFieldEnum | ApplicationgeneraldetailsScalarFieldEnum[]
  }

  /**
   * applicationgeneraldetails findFirstOrThrow
   */
  export type applicationgeneraldetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationgeneraldetails
     */
    select?: applicationgeneraldetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationgeneraldetails
     */
    omit?: applicationgeneraldetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationgeneraldetailsInclude<ExtArgs> | null
    /**
     * Filter, which applicationgeneraldetails to fetch.
     */
    where?: applicationgeneraldetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationgeneraldetails to fetch.
     */
    orderBy?: applicationgeneraldetailsOrderByWithRelationInput | applicationgeneraldetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applicationgeneraldetails.
     */
    cursor?: applicationgeneraldetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationgeneraldetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationgeneraldetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applicationgeneraldetails.
     */
    distinct?: ApplicationgeneraldetailsScalarFieldEnum | ApplicationgeneraldetailsScalarFieldEnum[]
  }

  /**
   * applicationgeneraldetails findMany
   */
  export type applicationgeneraldetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationgeneraldetails
     */
    select?: applicationgeneraldetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationgeneraldetails
     */
    omit?: applicationgeneraldetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationgeneraldetailsInclude<ExtArgs> | null
    /**
     * Filter, which applicationgeneraldetails to fetch.
     */
    where?: applicationgeneraldetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationgeneraldetails to fetch.
     */
    orderBy?: applicationgeneraldetailsOrderByWithRelationInput | applicationgeneraldetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing applicationgeneraldetails.
     */
    cursor?: applicationgeneraldetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationgeneraldetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationgeneraldetails.
     */
    skip?: number
    distinct?: ApplicationgeneraldetailsScalarFieldEnum | ApplicationgeneraldetailsScalarFieldEnum[]
  }

  /**
   * applicationgeneraldetails create
   */
  export type applicationgeneraldetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationgeneraldetails
     */
    select?: applicationgeneraldetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationgeneraldetails
     */
    omit?: applicationgeneraldetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationgeneraldetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a applicationgeneraldetails.
     */
    data: XOR<applicationgeneraldetailsCreateInput, applicationgeneraldetailsUncheckedCreateInput>
  }

  /**
   * applicationgeneraldetails createMany
   */
  export type applicationgeneraldetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many applicationgeneraldetails.
     */
    data: applicationgeneraldetailsCreateManyInput | applicationgeneraldetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * applicationgeneraldetails update
   */
  export type applicationgeneraldetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationgeneraldetails
     */
    select?: applicationgeneraldetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationgeneraldetails
     */
    omit?: applicationgeneraldetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationgeneraldetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a applicationgeneraldetails.
     */
    data: XOR<applicationgeneraldetailsUpdateInput, applicationgeneraldetailsUncheckedUpdateInput>
    /**
     * Choose, which applicationgeneraldetails to update.
     */
    where: applicationgeneraldetailsWhereUniqueInput
  }

  /**
   * applicationgeneraldetails updateMany
   */
  export type applicationgeneraldetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update applicationgeneraldetails.
     */
    data: XOR<applicationgeneraldetailsUpdateManyMutationInput, applicationgeneraldetailsUncheckedUpdateManyInput>
    /**
     * Filter which applicationgeneraldetails to update
     */
    where?: applicationgeneraldetailsWhereInput
    /**
     * Limit how many applicationgeneraldetails to update.
     */
    limit?: number
  }

  /**
   * applicationgeneraldetails upsert
   */
  export type applicationgeneraldetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationgeneraldetails
     */
    select?: applicationgeneraldetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationgeneraldetails
     */
    omit?: applicationgeneraldetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationgeneraldetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the applicationgeneraldetails to update in case it exists.
     */
    where: applicationgeneraldetailsWhereUniqueInput
    /**
     * In case the applicationgeneraldetails found by the `where` argument doesn't exist, create a new applicationgeneraldetails with this data.
     */
    create: XOR<applicationgeneraldetailsCreateInput, applicationgeneraldetailsUncheckedCreateInput>
    /**
     * In case the applicationgeneraldetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<applicationgeneraldetailsUpdateInput, applicationgeneraldetailsUncheckedUpdateInput>
  }

  /**
   * applicationgeneraldetails delete
   */
  export type applicationgeneraldetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationgeneraldetails
     */
    select?: applicationgeneraldetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationgeneraldetails
     */
    omit?: applicationgeneraldetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationgeneraldetailsInclude<ExtArgs> | null
    /**
     * Filter which applicationgeneraldetails to delete.
     */
    where: applicationgeneraldetailsWhereUniqueInput
  }

  /**
   * applicationgeneraldetails deleteMany
   */
  export type applicationgeneraldetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applicationgeneraldetails to delete
     */
    where?: applicationgeneraldetailsWhereInput
    /**
     * Limit how many applicationgeneraldetails to delete.
     */
    limit?: number
  }

  /**
   * applicationgeneraldetails without action
   */
  export type applicationgeneraldetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationgeneraldetails
     */
    select?: applicationgeneraldetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationgeneraldetails
     */
    omit?: applicationgeneraldetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationgeneraldetailsInclude<ExtArgs> | null
  }


  /**
   * Model applicationreferences
   */

  export type AggregateApplicationreferences = {
    _count: ApplicationreferencesCountAggregateOutputType | null
    _avg: ApplicationreferencesAvgAggregateOutputType | null
    _sum: ApplicationreferencesSumAggregateOutputType | null
    _min: ApplicationreferencesMinAggregateOutputType | null
    _max: ApplicationreferencesMaxAggregateOutputType | null
  }

  export type ApplicationreferencesAvgAggregateOutputType = {
    ReferenceID: number | null
    ApplicationID: number | null
  }

  export type ApplicationreferencesSumAggregateOutputType = {
    ReferenceID: number | null
    ApplicationID: number | null
  }

  export type ApplicationreferencesMinAggregateOutputType = {
    ReferenceID: number | null
    ApplicationID: number | null
    Name: string | null
    Designation: string | null
    Address: string | null
  }

  export type ApplicationreferencesMaxAggregateOutputType = {
    ReferenceID: number | null
    ApplicationID: number | null
    Name: string | null
    Designation: string | null
    Address: string | null
  }

  export type ApplicationreferencesCountAggregateOutputType = {
    ReferenceID: number
    ApplicationID: number
    Name: number
    Designation: number
    Address: number
    _all: number
  }


  export type ApplicationreferencesAvgAggregateInputType = {
    ReferenceID?: true
    ApplicationID?: true
  }

  export type ApplicationreferencesSumAggregateInputType = {
    ReferenceID?: true
    ApplicationID?: true
  }

  export type ApplicationreferencesMinAggregateInputType = {
    ReferenceID?: true
    ApplicationID?: true
    Name?: true
    Designation?: true
    Address?: true
  }

  export type ApplicationreferencesMaxAggregateInputType = {
    ReferenceID?: true
    ApplicationID?: true
    Name?: true
    Designation?: true
    Address?: true
  }

  export type ApplicationreferencesCountAggregateInputType = {
    ReferenceID?: true
    ApplicationID?: true
    Name?: true
    Designation?: true
    Address?: true
    _all?: true
  }

  export type ApplicationreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applicationreferences to aggregate.
     */
    where?: applicationreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationreferences to fetch.
     */
    orderBy?: applicationreferencesOrderByWithRelationInput | applicationreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: applicationreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned applicationreferences
    **/
    _count?: true | ApplicationreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApplicationreferencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApplicationreferencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationreferencesMaxAggregateInputType
  }

  export type GetApplicationreferencesAggregateType<T extends ApplicationreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateApplicationreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplicationreferences[P]>
      : GetScalarType<T[P], AggregateApplicationreferences[P]>
  }




  export type applicationreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicationreferencesWhereInput
    orderBy?: applicationreferencesOrderByWithAggregationInput | applicationreferencesOrderByWithAggregationInput[]
    by: ApplicationreferencesScalarFieldEnum[] | ApplicationreferencesScalarFieldEnum
    having?: applicationreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationreferencesCountAggregateInputType | true
    _avg?: ApplicationreferencesAvgAggregateInputType
    _sum?: ApplicationreferencesSumAggregateInputType
    _min?: ApplicationreferencesMinAggregateInputType
    _max?: ApplicationreferencesMaxAggregateInputType
  }

  export type ApplicationreferencesGroupByOutputType = {
    ReferenceID: number
    ApplicationID: number | null
    Name: string | null
    Designation: string | null
    Address: string | null
    _count: ApplicationreferencesCountAggregateOutputType | null
    _avg: ApplicationreferencesAvgAggregateOutputType | null
    _sum: ApplicationreferencesSumAggregateOutputType | null
    _min: ApplicationreferencesMinAggregateOutputType | null
    _max: ApplicationreferencesMaxAggregateOutputType | null
  }

  type GetApplicationreferencesGroupByPayload<T extends applicationreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationreferencesGroupByOutputType[P]>
        }
      >
    >


  export type applicationreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ReferenceID?: boolean
    ApplicationID?: boolean
    Name?: boolean
    Designation?: boolean
    Address?: boolean
    application?: boolean | applicationreferences$applicationArgs<ExtArgs>
  }, ExtArgs["result"]["applicationreferences"]>



  export type applicationreferencesSelectScalar = {
    ReferenceID?: boolean
    ApplicationID?: boolean
    Name?: boolean
    Designation?: boolean
    Address?: boolean
  }

  export type applicationreferencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ReferenceID" | "ApplicationID" | "Name" | "Designation" | "Address", ExtArgs["result"]["applicationreferences"]>
  export type applicationreferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | applicationreferences$applicationArgs<ExtArgs>
  }

  export type $applicationreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "applicationreferences"
    objects: {
      application: Prisma.$applicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ReferenceID: number
      ApplicationID: number | null
      Name: string | null
      Designation: string | null
      Address: string | null
    }, ExtArgs["result"]["applicationreferences"]>
    composites: {}
  }

  type applicationreferencesGetPayload<S extends boolean | null | undefined | applicationreferencesDefaultArgs> = $Result.GetResult<Prisma.$applicationreferencesPayload, S>

  type applicationreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<applicationreferencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicationreferencesCountAggregateInputType | true
    }

  export interface applicationreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['applicationreferences'], meta: { name: 'applicationreferences' } }
    /**
     * Find zero or one Applicationreferences that matches the filter.
     * @param {applicationreferencesFindUniqueArgs} args - Arguments to find a Applicationreferences
     * @example
     * // Get one Applicationreferences
     * const applicationreferences = await prisma.applicationreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends applicationreferencesFindUniqueArgs>(args: SelectSubset<T, applicationreferencesFindUniqueArgs<ExtArgs>>): Prisma__applicationreferencesClient<$Result.GetResult<Prisma.$applicationreferencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Applicationreferences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {applicationreferencesFindUniqueOrThrowArgs} args - Arguments to find a Applicationreferences
     * @example
     * // Get one Applicationreferences
     * const applicationreferences = await prisma.applicationreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends applicationreferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, applicationreferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__applicationreferencesClient<$Result.GetResult<Prisma.$applicationreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Applicationreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationreferencesFindFirstArgs} args - Arguments to find a Applicationreferences
     * @example
     * // Get one Applicationreferences
     * const applicationreferences = await prisma.applicationreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends applicationreferencesFindFirstArgs>(args?: SelectSubset<T, applicationreferencesFindFirstArgs<ExtArgs>>): Prisma__applicationreferencesClient<$Result.GetResult<Prisma.$applicationreferencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Applicationreferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationreferencesFindFirstOrThrowArgs} args - Arguments to find a Applicationreferences
     * @example
     * // Get one Applicationreferences
     * const applicationreferences = await prisma.applicationreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends applicationreferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, applicationreferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__applicationreferencesClient<$Result.GetResult<Prisma.$applicationreferencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Applicationreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationreferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applicationreferences
     * const applicationreferences = await prisma.applicationreferences.findMany()
     * 
     * // Get first 10 Applicationreferences
     * const applicationreferences = await prisma.applicationreferences.findMany({ take: 10 })
     * 
     * // Only select the `ReferenceID`
     * const applicationreferencesWithReferenceIDOnly = await prisma.applicationreferences.findMany({ select: { ReferenceID: true } })
     * 
     */
    findMany<T extends applicationreferencesFindManyArgs>(args?: SelectSubset<T, applicationreferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationreferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Applicationreferences.
     * @param {applicationreferencesCreateArgs} args - Arguments to create a Applicationreferences.
     * @example
     * // Create one Applicationreferences
     * const Applicationreferences = await prisma.applicationreferences.create({
     *   data: {
     *     // ... data to create a Applicationreferences
     *   }
     * })
     * 
     */
    create<T extends applicationreferencesCreateArgs>(args: SelectSubset<T, applicationreferencesCreateArgs<ExtArgs>>): Prisma__applicationreferencesClient<$Result.GetResult<Prisma.$applicationreferencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Applicationreferences.
     * @param {applicationreferencesCreateManyArgs} args - Arguments to create many Applicationreferences.
     * @example
     * // Create many Applicationreferences
     * const applicationreferences = await prisma.applicationreferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends applicationreferencesCreateManyArgs>(args?: SelectSubset<T, applicationreferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Applicationreferences.
     * @param {applicationreferencesDeleteArgs} args - Arguments to delete one Applicationreferences.
     * @example
     * // Delete one Applicationreferences
     * const Applicationreferences = await prisma.applicationreferences.delete({
     *   where: {
     *     // ... filter to delete one Applicationreferences
     *   }
     * })
     * 
     */
    delete<T extends applicationreferencesDeleteArgs>(args: SelectSubset<T, applicationreferencesDeleteArgs<ExtArgs>>): Prisma__applicationreferencesClient<$Result.GetResult<Prisma.$applicationreferencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Applicationreferences.
     * @param {applicationreferencesUpdateArgs} args - Arguments to update one Applicationreferences.
     * @example
     * // Update one Applicationreferences
     * const applicationreferences = await prisma.applicationreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends applicationreferencesUpdateArgs>(args: SelectSubset<T, applicationreferencesUpdateArgs<ExtArgs>>): Prisma__applicationreferencesClient<$Result.GetResult<Prisma.$applicationreferencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Applicationreferences.
     * @param {applicationreferencesDeleteManyArgs} args - Arguments to filter Applicationreferences to delete.
     * @example
     * // Delete a few Applicationreferences
     * const { count } = await prisma.applicationreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends applicationreferencesDeleteManyArgs>(args?: SelectSubset<T, applicationreferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applicationreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applicationreferences
     * const applicationreferences = await prisma.applicationreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends applicationreferencesUpdateManyArgs>(args: SelectSubset<T, applicationreferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Applicationreferences.
     * @param {applicationreferencesUpsertArgs} args - Arguments to update or create a Applicationreferences.
     * @example
     * // Update or create a Applicationreferences
     * const applicationreferences = await prisma.applicationreferences.upsert({
     *   create: {
     *     // ... data to create a Applicationreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Applicationreferences we want to update
     *   }
     * })
     */
    upsert<T extends applicationreferencesUpsertArgs>(args: SelectSubset<T, applicationreferencesUpsertArgs<ExtArgs>>): Prisma__applicationreferencesClient<$Result.GetResult<Prisma.$applicationreferencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Applicationreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationreferencesCountArgs} args - Arguments to filter Applicationreferences to count.
     * @example
     * // Count the number of Applicationreferences
     * const count = await prisma.applicationreferences.count({
     *   where: {
     *     // ... the filter for the Applicationreferences we want to count
     *   }
     * })
    **/
    count<T extends applicationreferencesCountArgs>(
      args?: Subset<T, applicationreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Applicationreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationreferencesAggregateArgs>(args: Subset<T, ApplicationreferencesAggregateArgs>): Prisma.PrismaPromise<GetApplicationreferencesAggregateType<T>>

    /**
     * Group by Applicationreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends applicationreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: applicationreferencesGroupByArgs['orderBy'] }
        : { orderBy?: applicationreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, applicationreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the applicationreferences model
   */
  readonly fields: applicationreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for applicationreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__applicationreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends applicationreferences$applicationArgs<ExtArgs> = {}>(args?: Subset<T, applicationreferences$applicationArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the applicationreferences model
   */
  interface applicationreferencesFieldRefs {
    readonly ReferenceID: FieldRef<"applicationreferences", 'Int'>
    readonly ApplicationID: FieldRef<"applicationreferences", 'Int'>
    readonly Name: FieldRef<"applicationreferences", 'String'>
    readonly Designation: FieldRef<"applicationreferences", 'String'>
    readonly Address: FieldRef<"applicationreferences", 'String'>
  }
    

  // Custom InputTypes
  /**
   * applicationreferences findUnique
   */
  export type applicationreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationreferences
     */
    select?: applicationreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationreferences
     */
    omit?: applicationreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationreferencesInclude<ExtArgs> | null
    /**
     * Filter, which applicationreferences to fetch.
     */
    where: applicationreferencesWhereUniqueInput
  }

  /**
   * applicationreferences findUniqueOrThrow
   */
  export type applicationreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationreferences
     */
    select?: applicationreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationreferences
     */
    omit?: applicationreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationreferencesInclude<ExtArgs> | null
    /**
     * Filter, which applicationreferences to fetch.
     */
    where: applicationreferencesWhereUniqueInput
  }

  /**
   * applicationreferences findFirst
   */
  export type applicationreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationreferences
     */
    select?: applicationreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationreferences
     */
    omit?: applicationreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationreferencesInclude<ExtArgs> | null
    /**
     * Filter, which applicationreferences to fetch.
     */
    where?: applicationreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationreferences to fetch.
     */
    orderBy?: applicationreferencesOrderByWithRelationInput | applicationreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applicationreferences.
     */
    cursor?: applicationreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applicationreferences.
     */
    distinct?: ApplicationreferencesScalarFieldEnum | ApplicationreferencesScalarFieldEnum[]
  }

  /**
   * applicationreferences findFirstOrThrow
   */
  export type applicationreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationreferences
     */
    select?: applicationreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationreferences
     */
    omit?: applicationreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationreferencesInclude<ExtArgs> | null
    /**
     * Filter, which applicationreferences to fetch.
     */
    where?: applicationreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationreferences to fetch.
     */
    orderBy?: applicationreferencesOrderByWithRelationInput | applicationreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applicationreferences.
     */
    cursor?: applicationreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applicationreferences.
     */
    distinct?: ApplicationreferencesScalarFieldEnum | ApplicationreferencesScalarFieldEnum[]
  }

  /**
   * applicationreferences findMany
   */
  export type applicationreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationreferences
     */
    select?: applicationreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationreferences
     */
    omit?: applicationreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationreferencesInclude<ExtArgs> | null
    /**
     * Filter, which applicationreferences to fetch.
     */
    where?: applicationreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationreferences to fetch.
     */
    orderBy?: applicationreferencesOrderByWithRelationInput | applicationreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing applicationreferences.
     */
    cursor?: applicationreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationreferences.
     */
    skip?: number
    distinct?: ApplicationreferencesScalarFieldEnum | ApplicationreferencesScalarFieldEnum[]
  }

  /**
   * applicationreferences create
   */
  export type applicationreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationreferences
     */
    select?: applicationreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationreferences
     */
    omit?: applicationreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationreferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a applicationreferences.
     */
    data?: XOR<applicationreferencesCreateInput, applicationreferencesUncheckedCreateInput>
  }

  /**
   * applicationreferences createMany
   */
  export type applicationreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many applicationreferences.
     */
    data: applicationreferencesCreateManyInput | applicationreferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * applicationreferences update
   */
  export type applicationreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationreferences
     */
    select?: applicationreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationreferences
     */
    omit?: applicationreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationreferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a applicationreferences.
     */
    data: XOR<applicationreferencesUpdateInput, applicationreferencesUncheckedUpdateInput>
    /**
     * Choose, which applicationreferences to update.
     */
    where: applicationreferencesWhereUniqueInput
  }

  /**
   * applicationreferences updateMany
   */
  export type applicationreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update applicationreferences.
     */
    data: XOR<applicationreferencesUpdateManyMutationInput, applicationreferencesUncheckedUpdateManyInput>
    /**
     * Filter which applicationreferences to update
     */
    where?: applicationreferencesWhereInput
    /**
     * Limit how many applicationreferences to update.
     */
    limit?: number
  }

  /**
   * applicationreferences upsert
   */
  export type applicationreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationreferences
     */
    select?: applicationreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationreferences
     */
    omit?: applicationreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationreferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the applicationreferences to update in case it exists.
     */
    where: applicationreferencesWhereUniqueInput
    /**
     * In case the applicationreferences found by the `where` argument doesn't exist, create a new applicationreferences with this data.
     */
    create: XOR<applicationreferencesCreateInput, applicationreferencesUncheckedCreateInput>
    /**
     * In case the applicationreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<applicationreferencesUpdateInput, applicationreferencesUncheckedUpdateInput>
  }

  /**
   * applicationreferences delete
   */
  export type applicationreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationreferences
     */
    select?: applicationreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationreferences
     */
    omit?: applicationreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationreferencesInclude<ExtArgs> | null
    /**
     * Filter which applicationreferences to delete.
     */
    where: applicationreferencesWhereUniqueInput
  }

  /**
   * applicationreferences deleteMany
   */
  export type applicationreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applicationreferences to delete
     */
    where?: applicationreferencesWhereInput
    /**
     * Limit how many applicationreferences to delete.
     */
    limit?: number
  }

  /**
   * applicationreferences.application
   */
  export type applicationreferences$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    where?: applicationWhereInput
  }

  /**
   * applicationreferences without action
   */
  export type applicationreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationreferences
     */
    select?: applicationreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationreferences
     */
    omit?: applicationreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationreferencesInclude<ExtArgs> | null
  }


  /**
   * Model applicationtemplate
   */

  export type AggregateApplicationtemplate = {
    _count: ApplicationtemplateCountAggregateOutputType | null
    _avg: ApplicationtemplateAvgAggregateOutputType | null
    _sum: ApplicationtemplateSumAggregateOutputType | null
    _min: ApplicationtemplateMinAggregateOutputType | null
    _max: ApplicationtemplateMaxAggregateOutputType | null
  }

  export type ApplicationtemplateAvgAggregateOutputType = {
    TemplateID: number | null
    UploadedBy: number | null
  }

  export type ApplicationtemplateSumAggregateOutputType = {
    TemplateID: number | null
    UploadedBy: number | null
  }

  export type ApplicationtemplateMinAggregateOutputType = {
    TemplateID: number | null
    Type: $Enums.applicationtemplate_Type | null
    FilePath: string | null
    UploadedBy: number | null
    UploadDate: Date | null
  }

  export type ApplicationtemplateMaxAggregateOutputType = {
    TemplateID: number | null
    Type: $Enums.applicationtemplate_Type | null
    FilePath: string | null
    UploadedBy: number | null
    UploadDate: Date | null
  }

  export type ApplicationtemplateCountAggregateOutputType = {
    TemplateID: number
    Type: number
    FilePath: number
    UploadedBy: number
    UploadDate: number
    _all: number
  }


  export type ApplicationtemplateAvgAggregateInputType = {
    TemplateID?: true
    UploadedBy?: true
  }

  export type ApplicationtemplateSumAggregateInputType = {
    TemplateID?: true
    UploadedBy?: true
  }

  export type ApplicationtemplateMinAggregateInputType = {
    TemplateID?: true
    Type?: true
    FilePath?: true
    UploadedBy?: true
    UploadDate?: true
  }

  export type ApplicationtemplateMaxAggregateInputType = {
    TemplateID?: true
    Type?: true
    FilePath?: true
    UploadedBy?: true
    UploadDate?: true
  }

  export type ApplicationtemplateCountAggregateInputType = {
    TemplateID?: true
    Type?: true
    FilePath?: true
    UploadedBy?: true
    UploadDate?: true
    _all?: true
  }

  export type ApplicationtemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applicationtemplate to aggregate.
     */
    where?: applicationtemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationtemplates to fetch.
     */
    orderBy?: applicationtemplateOrderByWithRelationInput | applicationtemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: applicationtemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationtemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationtemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned applicationtemplates
    **/
    _count?: true | ApplicationtemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApplicationtemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApplicationtemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationtemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationtemplateMaxAggregateInputType
  }

  export type GetApplicationtemplateAggregateType<T extends ApplicationtemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateApplicationtemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplicationtemplate[P]>
      : GetScalarType<T[P], AggregateApplicationtemplate[P]>
  }




  export type applicationtemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicationtemplateWhereInput
    orderBy?: applicationtemplateOrderByWithAggregationInput | applicationtemplateOrderByWithAggregationInput[]
    by: ApplicationtemplateScalarFieldEnum[] | ApplicationtemplateScalarFieldEnum
    having?: applicationtemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationtemplateCountAggregateInputType | true
    _avg?: ApplicationtemplateAvgAggregateInputType
    _sum?: ApplicationtemplateSumAggregateInputType
    _min?: ApplicationtemplateMinAggregateInputType
    _max?: ApplicationtemplateMaxAggregateInputType
  }

  export type ApplicationtemplateGroupByOutputType = {
    TemplateID: number
    Type: $Enums.applicationtemplate_Type | null
    FilePath: string | null
    UploadedBy: number | null
    UploadDate: Date | null
    _count: ApplicationtemplateCountAggregateOutputType | null
    _avg: ApplicationtemplateAvgAggregateOutputType | null
    _sum: ApplicationtemplateSumAggregateOutputType | null
    _min: ApplicationtemplateMinAggregateOutputType | null
    _max: ApplicationtemplateMaxAggregateOutputType | null
  }

  type GetApplicationtemplateGroupByPayload<T extends applicationtemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationtemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationtemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationtemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationtemplateGroupByOutputType[P]>
        }
      >
    >


  export type applicationtemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TemplateID?: boolean
    Type?: boolean
    FilePath?: boolean
    UploadedBy?: boolean
    UploadDate?: boolean
    admin?: boolean | applicationtemplate$adminArgs<ExtArgs>
    jobvacancy?: boolean | applicationtemplate$jobvacancyArgs<ExtArgs>
    _count?: boolean | ApplicationtemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicationtemplate"]>



  export type applicationtemplateSelectScalar = {
    TemplateID?: boolean
    Type?: boolean
    FilePath?: boolean
    UploadedBy?: boolean
    UploadDate?: boolean
  }

  export type applicationtemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"TemplateID" | "Type" | "FilePath" | "UploadedBy" | "UploadDate", ExtArgs["result"]["applicationtemplate"]>
  export type applicationtemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | applicationtemplate$adminArgs<ExtArgs>
    jobvacancy?: boolean | applicationtemplate$jobvacancyArgs<ExtArgs>
    _count?: boolean | ApplicationtemplateCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $applicationtemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "applicationtemplate"
    objects: {
      admin: Prisma.$adminPayload<ExtArgs> | null
      jobvacancy: Prisma.$jobvacancyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      TemplateID: number
      Type: $Enums.applicationtemplate_Type | null
      FilePath: string | null
      UploadedBy: number | null
      UploadDate: Date | null
    }, ExtArgs["result"]["applicationtemplate"]>
    composites: {}
  }

  type applicationtemplateGetPayload<S extends boolean | null | undefined | applicationtemplateDefaultArgs> = $Result.GetResult<Prisma.$applicationtemplatePayload, S>

  type applicationtemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<applicationtemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicationtemplateCountAggregateInputType | true
    }

  export interface applicationtemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['applicationtemplate'], meta: { name: 'applicationtemplate' } }
    /**
     * Find zero or one Applicationtemplate that matches the filter.
     * @param {applicationtemplateFindUniqueArgs} args - Arguments to find a Applicationtemplate
     * @example
     * // Get one Applicationtemplate
     * const applicationtemplate = await prisma.applicationtemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends applicationtemplateFindUniqueArgs>(args: SelectSubset<T, applicationtemplateFindUniqueArgs<ExtArgs>>): Prisma__applicationtemplateClient<$Result.GetResult<Prisma.$applicationtemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Applicationtemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {applicationtemplateFindUniqueOrThrowArgs} args - Arguments to find a Applicationtemplate
     * @example
     * // Get one Applicationtemplate
     * const applicationtemplate = await prisma.applicationtemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends applicationtemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, applicationtemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__applicationtemplateClient<$Result.GetResult<Prisma.$applicationtemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Applicationtemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationtemplateFindFirstArgs} args - Arguments to find a Applicationtemplate
     * @example
     * // Get one Applicationtemplate
     * const applicationtemplate = await prisma.applicationtemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends applicationtemplateFindFirstArgs>(args?: SelectSubset<T, applicationtemplateFindFirstArgs<ExtArgs>>): Prisma__applicationtemplateClient<$Result.GetResult<Prisma.$applicationtemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Applicationtemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationtemplateFindFirstOrThrowArgs} args - Arguments to find a Applicationtemplate
     * @example
     * // Get one Applicationtemplate
     * const applicationtemplate = await prisma.applicationtemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends applicationtemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, applicationtemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__applicationtemplateClient<$Result.GetResult<Prisma.$applicationtemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Applicationtemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationtemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applicationtemplates
     * const applicationtemplates = await prisma.applicationtemplate.findMany()
     * 
     * // Get first 10 Applicationtemplates
     * const applicationtemplates = await prisma.applicationtemplate.findMany({ take: 10 })
     * 
     * // Only select the `TemplateID`
     * const applicationtemplateWithTemplateIDOnly = await prisma.applicationtemplate.findMany({ select: { TemplateID: true } })
     * 
     */
    findMany<T extends applicationtemplateFindManyArgs>(args?: SelectSubset<T, applicationtemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationtemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Applicationtemplate.
     * @param {applicationtemplateCreateArgs} args - Arguments to create a Applicationtemplate.
     * @example
     * // Create one Applicationtemplate
     * const Applicationtemplate = await prisma.applicationtemplate.create({
     *   data: {
     *     // ... data to create a Applicationtemplate
     *   }
     * })
     * 
     */
    create<T extends applicationtemplateCreateArgs>(args: SelectSubset<T, applicationtemplateCreateArgs<ExtArgs>>): Prisma__applicationtemplateClient<$Result.GetResult<Prisma.$applicationtemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Applicationtemplates.
     * @param {applicationtemplateCreateManyArgs} args - Arguments to create many Applicationtemplates.
     * @example
     * // Create many Applicationtemplates
     * const applicationtemplate = await prisma.applicationtemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends applicationtemplateCreateManyArgs>(args?: SelectSubset<T, applicationtemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Applicationtemplate.
     * @param {applicationtemplateDeleteArgs} args - Arguments to delete one Applicationtemplate.
     * @example
     * // Delete one Applicationtemplate
     * const Applicationtemplate = await prisma.applicationtemplate.delete({
     *   where: {
     *     // ... filter to delete one Applicationtemplate
     *   }
     * })
     * 
     */
    delete<T extends applicationtemplateDeleteArgs>(args: SelectSubset<T, applicationtemplateDeleteArgs<ExtArgs>>): Prisma__applicationtemplateClient<$Result.GetResult<Prisma.$applicationtemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Applicationtemplate.
     * @param {applicationtemplateUpdateArgs} args - Arguments to update one Applicationtemplate.
     * @example
     * // Update one Applicationtemplate
     * const applicationtemplate = await prisma.applicationtemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends applicationtemplateUpdateArgs>(args: SelectSubset<T, applicationtemplateUpdateArgs<ExtArgs>>): Prisma__applicationtemplateClient<$Result.GetResult<Prisma.$applicationtemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Applicationtemplates.
     * @param {applicationtemplateDeleteManyArgs} args - Arguments to filter Applicationtemplates to delete.
     * @example
     * // Delete a few Applicationtemplates
     * const { count } = await prisma.applicationtemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends applicationtemplateDeleteManyArgs>(args?: SelectSubset<T, applicationtemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applicationtemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationtemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applicationtemplates
     * const applicationtemplate = await prisma.applicationtemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends applicationtemplateUpdateManyArgs>(args: SelectSubset<T, applicationtemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Applicationtemplate.
     * @param {applicationtemplateUpsertArgs} args - Arguments to update or create a Applicationtemplate.
     * @example
     * // Update or create a Applicationtemplate
     * const applicationtemplate = await prisma.applicationtemplate.upsert({
     *   create: {
     *     // ... data to create a Applicationtemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Applicationtemplate we want to update
     *   }
     * })
     */
    upsert<T extends applicationtemplateUpsertArgs>(args: SelectSubset<T, applicationtemplateUpsertArgs<ExtArgs>>): Prisma__applicationtemplateClient<$Result.GetResult<Prisma.$applicationtemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Applicationtemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationtemplateCountArgs} args - Arguments to filter Applicationtemplates to count.
     * @example
     * // Count the number of Applicationtemplates
     * const count = await prisma.applicationtemplate.count({
     *   where: {
     *     // ... the filter for the Applicationtemplates we want to count
     *   }
     * })
    **/
    count<T extends applicationtemplateCountArgs>(
      args?: Subset<T, applicationtemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationtemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Applicationtemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationtemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationtemplateAggregateArgs>(args: Subset<T, ApplicationtemplateAggregateArgs>): Prisma.PrismaPromise<GetApplicationtemplateAggregateType<T>>

    /**
     * Group by Applicationtemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationtemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends applicationtemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: applicationtemplateGroupByArgs['orderBy'] }
        : { orderBy?: applicationtemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, applicationtemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationtemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the applicationtemplate model
   */
  readonly fields: applicationtemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for applicationtemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__applicationtemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends applicationtemplate$adminArgs<ExtArgs> = {}>(args?: Subset<T, applicationtemplate$adminArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    jobvacancy<T extends applicationtemplate$jobvacancyArgs<ExtArgs> = {}>(args?: Subset<T, applicationtemplate$jobvacancyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobvacancyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the applicationtemplate model
   */
  interface applicationtemplateFieldRefs {
    readonly TemplateID: FieldRef<"applicationtemplate", 'Int'>
    readonly Type: FieldRef<"applicationtemplate", 'applicationtemplate_Type'>
    readonly FilePath: FieldRef<"applicationtemplate", 'String'>
    readonly UploadedBy: FieldRef<"applicationtemplate", 'Int'>
    readonly UploadDate: FieldRef<"applicationtemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * applicationtemplate findUnique
   */
  export type applicationtemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtemplate
     */
    select?: applicationtemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationtemplate
     */
    omit?: applicationtemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationtemplateInclude<ExtArgs> | null
    /**
     * Filter, which applicationtemplate to fetch.
     */
    where: applicationtemplateWhereUniqueInput
  }

  /**
   * applicationtemplate findUniqueOrThrow
   */
  export type applicationtemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtemplate
     */
    select?: applicationtemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationtemplate
     */
    omit?: applicationtemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationtemplateInclude<ExtArgs> | null
    /**
     * Filter, which applicationtemplate to fetch.
     */
    where: applicationtemplateWhereUniqueInput
  }

  /**
   * applicationtemplate findFirst
   */
  export type applicationtemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtemplate
     */
    select?: applicationtemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationtemplate
     */
    omit?: applicationtemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationtemplateInclude<ExtArgs> | null
    /**
     * Filter, which applicationtemplate to fetch.
     */
    where?: applicationtemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationtemplates to fetch.
     */
    orderBy?: applicationtemplateOrderByWithRelationInput | applicationtemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applicationtemplates.
     */
    cursor?: applicationtemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationtemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationtemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applicationtemplates.
     */
    distinct?: ApplicationtemplateScalarFieldEnum | ApplicationtemplateScalarFieldEnum[]
  }

  /**
   * applicationtemplate findFirstOrThrow
   */
  export type applicationtemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtemplate
     */
    select?: applicationtemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationtemplate
     */
    omit?: applicationtemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationtemplateInclude<ExtArgs> | null
    /**
     * Filter, which applicationtemplate to fetch.
     */
    where?: applicationtemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationtemplates to fetch.
     */
    orderBy?: applicationtemplateOrderByWithRelationInput | applicationtemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applicationtemplates.
     */
    cursor?: applicationtemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationtemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationtemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applicationtemplates.
     */
    distinct?: ApplicationtemplateScalarFieldEnum | ApplicationtemplateScalarFieldEnum[]
  }

  /**
   * applicationtemplate findMany
   */
  export type applicationtemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtemplate
     */
    select?: applicationtemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationtemplate
     */
    omit?: applicationtemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationtemplateInclude<ExtArgs> | null
    /**
     * Filter, which applicationtemplates to fetch.
     */
    where?: applicationtemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationtemplates to fetch.
     */
    orderBy?: applicationtemplateOrderByWithRelationInput | applicationtemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing applicationtemplates.
     */
    cursor?: applicationtemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationtemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationtemplates.
     */
    skip?: number
    distinct?: ApplicationtemplateScalarFieldEnum | ApplicationtemplateScalarFieldEnum[]
  }

  /**
   * applicationtemplate create
   */
  export type applicationtemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtemplate
     */
    select?: applicationtemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationtemplate
     */
    omit?: applicationtemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationtemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a applicationtemplate.
     */
    data?: XOR<applicationtemplateCreateInput, applicationtemplateUncheckedCreateInput>
  }

  /**
   * applicationtemplate createMany
   */
  export type applicationtemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many applicationtemplates.
     */
    data: applicationtemplateCreateManyInput | applicationtemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * applicationtemplate update
   */
  export type applicationtemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtemplate
     */
    select?: applicationtemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationtemplate
     */
    omit?: applicationtemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationtemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a applicationtemplate.
     */
    data: XOR<applicationtemplateUpdateInput, applicationtemplateUncheckedUpdateInput>
    /**
     * Choose, which applicationtemplate to update.
     */
    where: applicationtemplateWhereUniqueInput
  }

  /**
   * applicationtemplate updateMany
   */
  export type applicationtemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update applicationtemplates.
     */
    data: XOR<applicationtemplateUpdateManyMutationInput, applicationtemplateUncheckedUpdateManyInput>
    /**
     * Filter which applicationtemplates to update
     */
    where?: applicationtemplateWhereInput
    /**
     * Limit how many applicationtemplates to update.
     */
    limit?: number
  }

  /**
   * applicationtemplate upsert
   */
  export type applicationtemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtemplate
     */
    select?: applicationtemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationtemplate
     */
    omit?: applicationtemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationtemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the applicationtemplate to update in case it exists.
     */
    where: applicationtemplateWhereUniqueInput
    /**
     * In case the applicationtemplate found by the `where` argument doesn't exist, create a new applicationtemplate with this data.
     */
    create: XOR<applicationtemplateCreateInput, applicationtemplateUncheckedCreateInput>
    /**
     * In case the applicationtemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<applicationtemplateUpdateInput, applicationtemplateUncheckedUpdateInput>
  }

  /**
   * applicationtemplate delete
   */
  export type applicationtemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtemplate
     */
    select?: applicationtemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationtemplate
     */
    omit?: applicationtemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationtemplateInclude<ExtArgs> | null
    /**
     * Filter which applicationtemplate to delete.
     */
    where: applicationtemplateWhereUniqueInput
  }

  /**
   * applicationtemplate deleteMany
   */
  export type applicationtemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applicationtemplates to delete
     */
    where?: applicationtemplateWhereInput
    /**
     * Limit how many applicationtemplates to delete.
     */
    limit?: number
  }

  /**
   * applicationtemplate.admin
   */
  export type applicationtemplate$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    where?: adminWhereInput
  }

  /**
   * applicationtemplate.jobvacancy
   */
  export type applicationtemplate$jobvacancyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobvacancy
     */
    select?: jobvacancySelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobvacancy
     */
    omit?: jobvacancyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobvacancyInclude<ExtArgs> | null
    where?: jobvacancyWhereInput
    orderBy?: jobvacancyOrderByWithRelationInput | jobvacancyOrderByWithRelationInput[]
    cursor?: jobvacancyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobvacancyScalarFieldEnum | JobvacancyScalarFieldEnum[]
  }

  /**
   * applicationtemplate without action
   */
  export type applicationtemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtemplate
     */
    select?: applicationtemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationtemplate
     */
    omit?: applicationtemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationtemplateInclude<ExtArgs> | null
  }


  /**
   * Model auditlog
   */

  export type AggregateAuditlog = {
    _count: AuditlogCountAggregateOutputType | null
    _avg: AuditlogAvgAggregateOutputType | null
    _sum: AuditlogSumAggregateOutputType | null
    _min: AuditlogMinAggregateOutputType | null
    _max: AuditlogMaxAggregateOutputType | null
  }

  export type AuditlogAvgAggregateOutputType = {
    LogID: number | null
    ActorID: number | null
  }

  export type AuditlogSumAggregateOutputType = {
    LogID: number | null
    ActorID: number | null
  }

  export type AuditlogMinAggregateOutputType = {
    LogID: number | null
    ActorID: number | null
    ActorRole: $Enums.auditlog_ActorRole | null
    Action: string | null
    Timestamp: Date | null
    Details: string | null
  }

  export type AuditlogMaxAggregateOutputType = {
    LogID: number | null
    ActorID: number | null
    ActorRole: $Enums.auditlog_ActorRole | null
    Action: string | null
    Timestamp: Date | null
    Details: string | null
  }

  export type AuditlogCountAggregateOutputType = {
    LogID: number
    ActorID: number
    ActorRole: number
    Action: number
    Timestamp: number
    Details: number
    _all: number
  }


  export type AuditlogAvgAggregateInputType = {
    LogID?: true
    ActorID?: true
  }

  export type AuditlogSumAggregateInputType = {
    LogID?: true
    ActorID?: true
  }

  export type AuditlogMinAggregateInputType = {
    LogID?: true
    ActorID?: true
    ActorRole?: true
    Action?: true
    Timestamp?: true
    Details?: true
  }

  export type AuditlogMaxAggregateInputType = {
    LogID?: true
    ActorID?: true
    ActorRole?: true
    Action?: true
    Timestamp?: true
    Details?: true
  }

  export type AuditlogCountAggregateInputType = {
    LogID?: true
    ActorID?: true
    ActorRole?: true
    Action?: true
    Timestamp?: true
    Details?: true
    _all?: true
  }

  export type AuditlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auditlog to aggregate.
     */
    where?: auditlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditlogs to fetch.
     */
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auditlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auditlogs
    **/
    _count?: true | AuditlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditlogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditlogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditlogMaxAggregateInputType
  }

  export type GetAuditlogAggregateType<T extends AuditlogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditlog[P]>
      : GetScalarType<T[P], AggregateAuditlog[P]>
  }




  export type auditlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditlogWhereInput
    orderBy?: auditlogOrderByWithAggregationInput | auditlogOrderByWithAggregationInput[]
    by: AuditlogScalarFieldEnum[] | AuditlogScalarFieldEnum
    having?: auditlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditlogCountAggregateInputType | true
    _avg?: AuditlogAvgAggregateInputType
    _sum?: AuditlogSumAggregateInputType
    _min?: AuditlogMinAggregateInputType
    _max?: AuditlogMaxAggregateInputType
  }

  export type AuditlogGroupByOutputType = {
    LogID: number
    ActorID: number | null
    ActorRole: $Enums.auditlog_ActorRole | null
    Action: string | null
    Timestamp: Date | null
    Details: string | null
    _count: AuditlogCountAggregateOutputType | null
    _avg: AuditlogAvgAggregateOutputType | null
    _sum: AuditlogSumAggregateOutputType | null
    _min: AuditlogMinAggregateOutputType | null
    _max: AuditlogMaxAggregateOutputType | null
  }

  type GetAuditlogGroupByPayload<T extends auditlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditlogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditlogGroupByOutputType[P]>
        }
      >
    >


  export type auditlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    LogID?: boolean
    ActorID?: boolean
    ActorRole?: boolean
    Action?: boolean
    Timestamp?: boolean
    Details?: boolean
  }, ExtArgs["result"]["auditlog"]>



  export type auditlogSelectScalar = {
    LogID?: boolean
    ActorID?: boolean
    ActorRole?: boolean
    Action?: boolean
    Timestamp?: boolean
    Details?: boolean
  }

  export type auditlogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"LogID" | "ActorID" | "ActorRole" | "Action" | "Timestamp" | "Details", ExtArgs["result"]["auditlog"]>

  export type $auditlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "auditlog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      LogID: number
      ActorID: number | null
      ActorRole: $Enums.auditlog_ActorRole | null
      Action: string | null
      Timestamp: Date | null
      Details: string | null
    }, ExtArgs["result"]["auditlog"]>
    composites: {}
  }

  type auditlogGetPayload<S extends boolean | null | undefined | auditlogDefaultArgs> = $Result.GetResult<Prisma.$auditlogPayload, S>

  type auditlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<auditlogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditlogCountAggregateInputType | true
    }

  export interface auditlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auditlog'], meta: { name: 'auditlog' } }
    /**
     * Find zero or one Auditlog that matches the filter.
     * @param {auditlogFindUniqueArgs} args - Arguments to find a Auditlog
     * @example
     * // Get one Auditlog
     * const auditlog = await prisma.auditlog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends auditlogFindUniqueArgs>(args: SelectSubset<T, auditlogFindUniqueArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Auditlog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {auditlogFindUniqueOrThrowArgs} args - Arguments to find a Auditlog
     * @example
     * // Get one Auditlog
     * const auditlog = await prisma.auditlog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends auditlogFindUniqueOrThrowArgs>(args: SelectSubset<T, auditlogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auditlog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogFindFirstArgs} args - Arguments to find a Auditlog
     * @example
     * // Get one Auditlog
     * const auditlog = await prisma.auditlog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends auditlogFindFirstArgs>(args?: SelectSubset<T, auditlogFindFirstArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auditlog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogFindFirstOrThrowArgs} args - Arguments to find a Auditlog
     * @example
     * // Get one Auditlog
     * const auditlog = await prisma.auditlog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends auditlogFindFirstOrThrowArgs>(args?: SelectSubset<T, auditlogFindFirstOrThrowArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Auditlogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auditlogs
     * const auditlogs = await prisma.auditlog.findMany()
     * 
     * // Get first 10 Auditlogs
     * const auditlogs = await prisma.auditlog.findMany({ take: 10 })
     * 
     * // Only select the `LogID`
     * const auditlogWithLogIDOnly = await prisma.auditlog.findMany({ select: { LogID: true } })
     * 
     */
    findMany<T extends auditlogFindManyArgs>(args?: SelectSubset<T, auditlogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Auditlog.
     * @param {auditlogCreateArgs} args - Arguments to create a Auditlog.
     * @example
     * // Create one Auditlog
     * const Auditlog = await prisma.auditlog.create({
     *   data: {
     *     // ... data to create a Auditlog
     *   }
     * })
     * 
     */
    create<T extends auditlogCreateArgs>(args: SelectSubset<T, auditlogCreateArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Auditlogs.
     * @param {auditlogCreateManyArgs} args - Arguments to create many Auditlogs.
     * @example
     * // Create many Auditlogs
     * const auditlog = await prisma.auditlog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends auditlogCreateManyArgs>(args?: SelectSubset<T, auditlogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Auditlog.
     * @param {auditlogDeleteArgs} args - Arguments to delete one Auditlog.
     * @example
     * // Delete one Auditlog
     * const Auditlog = await prisma.auditlog.delete({
     *   where: {
     *     // ... filter to delete one Auditlog
     *   }
     * })
     * 
     */
    delete<T extends auditlogDeleteArgs>(args: SelectSubset<T, auditlogDeleteArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Auditlog.
     * @param {auditlogUpdateArgs} args - Arguments to update one Auditlog.
     * @example
     * // Update one Auditlog
     * const auditlog = await prisma.auditlog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends auditlogUpdateArgs>(args: SelectSubset<T, auditlogUpdateArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Auditlogs.
     * @param {auditlogDeleteManyArgs} args - Arguments to filter Auditlogs to delete.
     * @example
     * // Delete a few Auditlogs
     * const { count } = await prisma.auditlog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends auditlogDeleteManyArgs>(args?: SelectSubset<T, auditlogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auditlogs
     * const auditlog = await prisma.auditlog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends auditlogUpdateManyArgs>(args: SelectSubset<T, auditlogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Auditlog.
     * @param {auditlogUpsertArgs} args - Arguments to update or create a Auditlog.
     * @example
     * // Update or create a Auditlog
     * const auditlog = await prisma.auditlog.upsert({
     *   create: {
     *     // ... data to create a Auditlog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auditlog we want to update
     *   }
     * })
     */
    upsert<T extends auditlogUpsertArgs>(args: SelectSubset<T, auditlogUpsertArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Auditlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogCountArgs} args - Arguments to filter Auditlogs to count.
     * @example
     * // Count the number of Auditlogs
     * const count = await prisma.auditlog.count({
     *   where: {
     *     // ... the filter for the Auditlogs we want to count
     *   }
     * })
    **/
    count<T extends auditlogCountArgs>(
      args?: Subset<T, auditlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auditlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditlogAggregateArgs>(args: Subset<T, AuditlogAggregateArgs>): Prisma.PrismaPromise<GetAuditlogAggregateType<T>>

    /**
     * Group by Auditlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auditlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auditlogGroupByArgs['orderBy'] }
        : { orderBy?: auditlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auditlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auditlog model
   */
  readonly fields: auditlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auditlog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auditlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the auditlog model
   */
  interface auditlogFieldRefs {
    readonly LogID: FieldRef<"auditlog", 'Int'>
    readonly ActorID: FieldRef<"auditlog", 'Int'>
    readonly ActorRole: FieldRef<"auditlog", 'auditlog_ActorRole'>
    readonly Action: FieldRef<"auditlog", 'String'>
    readonly Timestamp: FieldRef<"auditlog", 'DateTime'>
    readonly Details: FieldRef<"auditlog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * auditlog findUnique
   */
  export type auditlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * Filter, which auditlog to fetch.
     */
    where: auditlogWhereUniqueInput
  }

  /**
   * auditlog findUniqueOrThrow
   */
  export type auditlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * Filter, which auditlog to fetch.
     */
    where: auditlogWhereUniqueInput
  }

  /**
   * auditlog findFirst
   */
  export type auditlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * Filter, which auditlog to fetch.
     */
    where?: auditlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditlogs to fetch.
     */
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditlogs.
     */
    cursor?: auditlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditlogs.
     */
    distinct?: AuditlogScalarFieldEnum | AuditlogScalarFieldEnum[]
  }

  /**
   * auditlog findFirstOrThrow
   */
  export type auditlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * Filter, which auditlog to fetch.
     */
    where?: auditlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditlogs to fetch.
     */
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditlogs.
     */
    cursor?: auditlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditlogs.
     */
    distinct?: AuditlogScalarFieldEnum | AuditlogScalarFieldEnum[]
  }

  /**
   * auditlog findMany
   */
  export type auditlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * Filter, which auditlogs to fetch.
     */
    where?: auditlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditlogs to fetch.
     */
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auditlogs.
     */
    cursor?: auditlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditlogs.
     */
    skip?: number
    distinct?: AuditlogScalarFieldEnum | AuditlogScalarFieldEnum[]
  }

  /**
   * auditlog create
   */
  export type auditlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * The data needed to create a auditlog.
     */
    data?: XOR<auditlogCreateInput, auditlogUncheckedCreateInput>
  }

  /**
   * auditlog createMany
   */
  export type auditlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auditlogs.
     */
    data: auditlogCreateManyInput | auditlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * auditlog update
   */
  export type auditlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * The data needed to update a auditlog.
     */
    data: XOR<auditlogUpdateInput, auditlogUncheckedUpdateInput>
    /**
     * Choose, which auditlog to update.
     */
    where: auditlogWhereUniqueInput
  }

  /**
   * auditlog updateMany
   */
  export type auditlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auditlogs.
     */
    data: XOR<auditlogUpdateManyMutationInput, auditlogUncheckedUpdateManyInput>
    /**
     * Filter which auditlogs to update
     */
    where?: auditlogWhereInput
    /**
     * Limit how many auditlogs to update.
     */
    limit?: number
  }

  /**
   * auditlog upsert
   */
  export type auditlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * The filter to search for the auditlog to update in case it exists.
     */
    where: auditlogWhereUniqueInput
    /**
     * In case the auditlog found by the `where` argument doesn't exist, create a new auditlog with this data.
     */
    create: XOR<auditlogCreateInput, auditlogUncheckedCreateInput>
    /**
     * In case the auditlog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auditlogUpdateInput, auditlogUncheckedUpdateInput>
  }

  /**
   * auditlog delete
   */
  export type auditlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * Filter which auditlog to delete.
     */
    where: auditlogWhereUniqueInput
  }

  /**
   * auditlog deleteMany
   */
  export type auditlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auditlogs to delete
     */
    where?: auditlogWhereInput
    /**
     * Limit how many auditlogs to delete.
     */
    limit?: number
  }

  /**
   * auditlog without action
   */
  export type auditlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
  }


  /**
   * Model employmenthistories
   */

  export type AggregateEmploymenthistories = {
    _count: EmploymenthistoriesCountAggregateOutputType | null
    _avg: EmploymenthistoriesAvgAggregateOutputType | null
    _sum: EmploymenthistoriesSumAggregateOutputType | null
    _min: EmploymenthistoriesMinAggregateOutputType | null
    _max: EmploymenthistoriesMaxAggregateOutputType | null
  }

  export type EmploymenthistoriesAvgAggregateOutputType = {
    EmploymentID: number | null
    ApplicationID: number | null
    LastSalary: Decimal | null
  }

  export type EmploymenthistoriesSumAggregateOutputType = {
    EmploymentID: number | null
    ApplicationID: number | null
    LastSalary: Decimal | null
  }

  export type EmploymenthistoriesMinAggregateOutputType = {
    EmploymentID: number | null
    ApplicationID: number | null
    PostHeld: string | null
    Institution: string | null
    FromDate: Date | null
    ToDate: Date | null
    LastSalary: Decimal | null
  }

  export type EmploymenthistoriesMaxAggregateOutputType = {
    EmploymentID: number | null
    ApplicationID: number | null
    PostHeld: string | null
    Institution: string | null
    FromDate: Date | null
    ToDate: Date | null
    LastSalary: Decimal | null
  }

  export type EmploymenthistoriesCountAggregateOutputType = {
    EmploymentID: number
    ApplicationID: number
    PostHeld: number
    Institution: number
    FromDate: number
    ToDate: number
    LastSalary: number
    _all: number
  }


  export type EmploymenthistoriesAvgAggregateInputType = {
    EmploymentID?: true
    ApplicationID?: true
    LastSalary?: true
  }

  export type EmploymenthistoriesSumAggregateInputType = {
    EmploymentID?: true
    ApplicationID?: true
    LastSalary?: true
  }

  export type EmploymenthistoriesMinAggregateInputType = {
    EmploymentID?: true
    ApplicationID?: true
    PostHeld?: true
    Institution?: true
    FromDate?: true
    ToDate?: true
    LastSalary?: true
  }

  export type EmploymenthistoriesMaxAggregateInputType = {
    EmploymentID?: true
    ApplicationID?: true
    PostHeld?: true
    Institution?: true
    FromDate?: true
    ToDate?: true
    LastSalary?: true
  }

  export type EmploymenthistoriesCountAggregateInputType = {
    EmploymentID?: true
    ApplicationID?: true
    PostHeld?: true
    Institution?: true
    FromDate?: true
    ToDate?: true
    LastSalary?: true
    _all?: true
  }

  export type EmploymenthistoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employmenthistories to aggregate.
     */
    where?: employmenthistoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employmenthistories to fetch.
     */
    orderBy?: employmenthistoriesOrderByWithRelationInput | employmenthistoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: employmenthistoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employmenthistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employmenthistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employmenthistories
    **/
    _count?: true | EmploymenthistoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmploymenthistoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmploymenthistoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmploymenthistoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmploymenthistoriesMaxAggregateInputType
  }

  export type GetEmploymenthistoriesAggregateType<T extends EmploymenthistoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateEmploymenthistories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmploymenthistories[P]>
      : GetScalarType<T[P], AggregateEmploymenthistories[P]>
  }




  export type employmenthistoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employmenthistoriesWhereInput
    orderBy?: employmenthistoriesOrderByWithAggregationInput | employmenthistoriesOrderByWithAggregationInput[]
    by: EmploymenthistoriesScalarFieldEnum[] | EmploymenthistoriesScalarFieldEnum
    having?: employmenthistoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmploymenthistoriesCountAggregateInputType | true
    _avg?: EmploymenthistoriesAvgAggregateInputType
    _sum?: EmploymenthistoriesSumAggregateInputType
    _min?: EmploymenthistoriesMinAggregateInputType
    _max?: EmploymenthistoriesMaxAggregateInputType
  }

  export type EmploymenthistoriesGroupByOutputType = {
    EmploymentID: number
    ApplicationID: number | null
    PostHeld: string | null
    Institution: string | null
    FromDate: Date | null
    ToDate: Date | null
    LastSalary: Decimal | null
    _count: EmploymenthistoriesCountAggregateOutputType | null
    _avg: EmploymenthistoriesAvgAggregateOutputType | null
    _sum: EmploymenthistoriesSumAggregateOutputType | null
    _min: EmploymenthistoriesMinAggregateOutputType | null
    _max: EmploymenthistoriesMaxAggregateOutputType | null
  }

  type GetEmploymenthistoriesGroupByPayload<T extends employmenthistoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmploymenthistoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmploymenthistoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmploymenthistoriesGroupByOutputType[P]>
            : GetScalarType<T[P], EmploymenthistoriesGroupByOutputType[P]>
        }
      >
    >


  export type employmenthistoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    EmploymentID?: boolean
    ApplicationID?: boolean
    PostHeld?: boolean
    Institution?: boolean
    FromDate?: boolean
    ToDate?: boolean
    LastSalary?: boolean
    application?: boolean | employmenthistories$applicationArgs<ExtArgs>
  }, ExtArgs["result"]["employmenthistories"]>



  export type employmenthistoriesSelectScalar = {
    EmploymentID?: boolean
    ApplicationID?: boolean
    PostHeld?: boolean
    Institution?: boolean
    FromDate?: boolean
    ToDate?: boolean
    LastSalary?: boolean
  }

  export type employmenthistoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"EmploymentID" | "ApplicationID" | "PostHeld" | "Institution" | "FromDate" | "ToDate" | "LastSalary", ExtArgs["result"]["employmenthistories"]>
  export type employmenthistoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | employmenthistories$applicationArgs<ExtArgs>
  }

  export type $employmenthistoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "employmenthistories"
    objects: {
      application: Prisma.$applicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      EmploymentID: number
      ApplicationID: number | null
      PostHeld: string | null
      Institution: string | null
      FromDate: Date | null
      ToDate: Date | null
      LastSalary: Prisma.Decimal | null
    }, ExtArgs["result"]["employmenthistories"]>
    composites: {}
  }

  type employmenthistoriesGetPayload<S extends boolean | null | undefined | employmenthistoriesDefaultArgs> = $Result.GetResult<Prisma.$employmenthistoriesPayload, S>

  type employmenthistoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<employmenthistoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmploymenthistoriesCountAggregateInputType | true
    }

  export interface employmenthistoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['employmenthistories'], meta: { name: 'employmenthistories' } }
    /**
     * Find zero or one Employmenthistories that matches the filter.
     * @param {employmenthistoriesFindUniqueArgs} args - Arguments to find a Employmenthistories
     * @example
     * // Get one Employmenthistories
     * const employmenthistories = await prisma.employmenthistories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends employmenthistoriesFindUniqueArgs>(args: SelectSubset<T, employmenthistoriesFindUniqueArgs<ExtArgs>>): Prisma__employmenthistoriesClient<$Result.GetResult<Prisma.$employmenthistoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employmenthistories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {employmenthistoriesFindUniqueOrThrowArgs} args - Arguments to find a Employmenthistories
     * @example
     * // Get one Employmenthistories
     * const employmenthistories = await prisma.employmenthistories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends employmenthistoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, employmenthistoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__employmenthistoriesClient<$Result.GetResult<Prisma.$employmenthistoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employmenthistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employmenthistoriesFindFirstArgs} args - Arguments to find a Employmenthistories
     * @example
     * // Get one Employmenthistories
     * const employmenthistories = await prisma.employmenthistories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends employmenthistoriesFindFirstArgs>(args?: SelectSubset<T, employmenthistoriesFindFirstArgs<ExtArgs>>): Prisma__employmenthistoriesClient<$Result.GetResult<Prisma.$employmenthistoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employmenthistories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employmenthistoriesFindFirstOrThrowArgs} args - Arguments to find a Employmenthistories
     * @example
     * // Get one Employmenthistories
     * const employmenthistories = await prisma.employmenthistories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends employmenthistoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, employmenthistoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__employmenthistoriesClient<$Result.GetResult<Prisma.$employmenthistoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employmenthistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employmenthistoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employmenthistories
     * const employmenthistories = await prisma.employmenthistories.findMany()
     * 
     * // Get first 10 Employmenthistories
     * const employmenthistories = await prisma.employmenthistories.findMany({ take: 10 })
     * 
     * // Only select the `EmploymentID`
     * const employmenthistoriesWithEmploymentIDOnly = await prisma.employmenthistories.findMany({ select: { EmploymentID: true } })
     * 
     */
    findMany<T extends employmenthistoriesFindManyArgs>(args?: SelectSubset<T, employmenthistoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employmenthistoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employmenthistories.
     * @param {employmenthistoriesCreateArgs} args - Arguments to create a Employmenthistories.
     * @example
     * // Create one Employmenthistories
     * const Employmenthistories = await prisma.employmenthistories.create({
     *   data: {
     *     // ... data to create a Employmenthistories
     *   }
     * })
     * 
     */
    create<T extends employmenthistoriesCreateArgs>(args: SelectSubset<T, employmenthistoriesCreateArgs<ExtArgs>>): Prisma__employmenthistoriesClient<$Result.GetResult<Prisma.$employmenthistoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employmenthistories.
     * @param {employmenthistoriesCreateManyArgs} args - Arguments to create many Employmenthistories.
     * @example
     * // Create many Employmenthistories
     * const employmenthistories = await prisma.employmenthistories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends employmenthistoriesCreateManyArgs>(args?: SelectSubset<T, employmenthistoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Employmenthistories.
     * @param {employmenthistoriesDeleteArgs} args - Arguments to delete one Employmenthistories.
     * @example
     * // Delete one Employmenthistories
     * const Employmenthistories = await prisma.employmenthistories.delete({
     *   where: {
     *     // ... filter to delete one Employmenthistories
     *   }
     * })
     * 
     */
    delete<T extends employmenthistoriesDeleteArgs>(args: SelectSubset<T, employmenthistoriesDeleteArgs<ExtArgs>>): Prisma__employmenthistoriesClient<$Result.GetResult<Prisma.$employmenthistoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employmenthistories.
     * @param {employmenthistoriesUpdateArgs} args - Arguments to update one Employmenthistories.
     * @example
     * // Update one Employmenthistories
     * const employmenthistories = await prisma.employmenthistories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends employmenthistoriesUpdateArgs>(args: SelectSubset<T, employmenthistoriesUpdateArgs<ExtArgs>>): Prisma__employmenthistoriesClient<$Result.GetResult<Prisma.$employmenthistoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employmenthistories.
     * @param {employmenthistoriesDeleteManyArgs} args - Arguments to filter Employmenthistories to delete.
     * @example
     * // Delete a few Employmenthistories
     * const { count } = await prisma.employmenthistories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends employmenthistoriesDeleteManyArgs>(args?: SelectSubset<T, employmenthistoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employmenthistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employmenthistoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employmenthistories
     * const employmenthistories = await prisma.employmenthistories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends employmenthistoriesUpdateManyArgs>(args: SelectSubset<T, employmenthistoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employmenthistories.
     * @param {employmenthistoriesUpsertArgs} args - Arguments to update or create a Employmenthistories.
     * @example
     * // Update or create a Employmenthistories
     * const employmenthistories = await prisma.employmenthistories.upsert({
     *   create: {
     *     // ... data to create a Employmenthistories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employmenthistories we want to update
     *   }
     * })
     */
    upsert<T extends employmenthistoriesUpsertArgs>(args: SelectSubset<T, employmenthistoriesUpsertArgs<ExtArgs>>): Prisma__employmenthistoriesClient<$Result.GetResult<Prisma.$employmenthistoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employmenthistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employmenthistoriesCountArgs} args - Arguments to filter Employmenthistories to count.
     * @example
     * // Count the number of Employmenthistories
     * const count = await prisma.employmenthistories.count({
     *   where: {
     *     // ... the filter for the Employmenthistories we want to count
     *   }
     * })
    **/
    count<T extends employmenthistoriesCountArgs>(
      args?: Subset<T, employmenthistoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmploymenthistoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employmenthistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymenthistoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmploymenthistoriesAggregateArgs>(args: Subset<T, EmploymenthistoriesAggregateArgs>): Prisma.PrismaPromise<GetEmploymenthistoriesAggregateType<T>>

    /**
     * Group by Employmenthistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employmenthistoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends employmenthistoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: employmenthistoriesGroupByArgs['orderBy'] }
        : { orderBy?: employmenthistoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, employmenthistoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmploymenthistoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the employmenthistories model
   */
  readonly fields: employmenthistoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for employmenthistories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__employmenthistoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends employmenthistories$applicationArgs<ExtArgs> = {}>(args?: Subset<T, employmenthistories$applicationArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the employmenthistories model
   */
  interface employmenthistoriesFieldRefs {
    readonly EmploymentID: FieldRef<"employmenthistories", 'Int'>
    readonly ApplicationID: FieldRef<"employmenthistories", 'Int'>
    readonly PostHeld: FieldRef<"employmenthistories", 'String'>
    readonly Institution: FieldRef<"employmenthistories", 'String'>
    readonly FromDate: FieldRef<"employmenthistories", 'DateTime'>
    readonly ToDate: FieldRef<"employmenthistories", 'DateTime'>
    readonly LastSalary: FieldRef<"employmenthistories", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * employmenthistories findUnique
   */
  export type employmenthistoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenthistories
     */
    select?: employmenthistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenthistories
     */
    omit?: employmenthistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenthistoriesInclude<ExtArgs> | null
    /**
     * Filter, which employmenthistories to fetch.
     */
    where: employmenthistoriesWhereUniqueInput
  }

  /**
   * employmenthistories findUniqueOrThrow
   */
  export type employmenthistoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenthistories
     */
    select?: employmenthistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenthistories
     */
    omit?: employmenthistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenthistoriesInclude<ExtArgs> | null
    /**
     * Filter, which employmenthistories to fetch.
     */
    where: employmenthistoriesWhereUniqueInput
  }

  /**
   * employmenthistories findFirst
   */
  export type employmenthistoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenthistories
     */
    select?: employmenthistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenthistories
     */
    omit?: employmenthistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenthistoriesInclude<ExtArgs> | null
    /**
     * Filter, which employmenthistories to fetch.
     */
    where?: employmenthistoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employmenthistories to fetch.
     */
    orderBy?: employmenthistoriesOrderByWithRelationInput | employmenthistoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employmenthistories.
     */
    cursor?: employmenthistoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employmenthistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employmenthistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employmenthistories.
     */
    distinct?: EmploymenthistoriesScalarFieldEnum | EmploymenthistoriesScalarFieldEnum[]
  }

  /**
   * employmenthistories findFirstOrThrow
   */
  export type employmenthistoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenthistories
     */
    select?: employmenthistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenthistories
     */
    omit?: employmenthistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenthistoriesInclude<ExtArgs> | null
    /**
     * Filter, which employmenthistories to fetch.
     */
    where?: employmenthistoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employmenthistories to fetch.
     */
    orderBy?: employmenthistoriesOrderByWithRelationInput | employmenthistoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employmenthistories.
     */
    cursor?: employmenthistoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employmenthistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employmenthistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employmenthistories.
     */
    distinct?: EmploymenthistoriesScalarFieldEnum | EmploymenthistoriesScalarFieldEnum[]
  }

  /**
   * employmenthistories findMany
   */
  export type employmenthistoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenthistories
     */
    select?: employmenthistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenthistories
     */
    omit?: employmenthistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenthistoriesInclude<ExtArgs> | null
    /**
     * Filter, which employmenthistories to fetch.
     */
    where?: employmenthistoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employmenthistories to fetch.
     */
    orderBy?: employmenthistoriesOrderByWithRelationInput | employmenthistoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employmenthistories.
     */
    cursor?: employmenthistoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employmenthistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employmenthistories.
     */
    skip?: number
    distinct?: EmploymenthistoriesScalarFieldEnum | EmploymenthistoriesScalarFieldEnum[]
  }

  /**
   * employmenthistories create
   */
  export type employmenthistoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenthistories
     */
    select?: employmenthistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenthistories
     */
    omit?: employmenthistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenthistoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a employmenthistories.
     */
    data?: XOR<employmenthistoriesCreateInput, employmenthistoriesUncheckedCreateInput>
  }

  /**
   * employmenthistories createMany
   */
  export type employmenthistoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many employmenthistories.
     */
    data: employmenthistoriesCreateManyInput | employmenthistoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * employmenthistories update
   */
  export type employmenthistoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenthistories
     */
    select?: employmenthistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenthistories
     */
    omit?: employmenthistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenthistoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a employmenthistories.
     */
    data: XOR<employmenthistoriesUpdateInput, employmenthistoriesUncheckedUpdateInput>
    /**
     * Choose, which employmenthistories to update.
     */
    where: employmenthistoriesWhereUniqueInput
  }

  /**
   * employmenthistories updateMany
   */
  export type employmenthistoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update employmenthistories.
     */
    data: XOR<employmenthistoriesUpdateManyMutationInput, employmenthistoriesUncheckedUpdateManyInput>
    /**
     * Filter which employmenthistories to update
     */
    where?: employmenthistoriesWhereInput
    /**
     * Limit how many employmenthistories to update.
     */
    limit?: number
  }

  /**
   * employmenthistories upsert
   */
  export type employmenthistoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenthistories
     */
    select?: employmenthistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenthistories
     */
    omit?: employmenthistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenthistoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the employmenthistories to update in case it exists.
     */
    where: employmenthistoriesWhereUniqueInput
    /**
     * In case the employmenthistories found by the `where` argument doesn't exist, create a new employmenthistories with this data.
     */
    create: XOR<employmenthistoriesCreateInput, employmenthistoriesUncheckedCreateInput>
    /**
     * In case the employmenthistories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<employmenthistoriesUpdateInput, employmenthistoriesUncheckedUpdateInput>
  }

  /**
   * employmenthistories delete
   */
  export type employmenthistoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenthistories
     */
    select?: employmenthistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenthistories
     */
    omit?: employmenthistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenthistoriesInclude<ExtArgs> | null
    /**
     * Filter which employmenthistories to delete.
     */
    where: employmenthistoriesWhereUniqueInput
  }

  /**
   * employmenthistories deleteMany
   */
  export type employmenthistoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employmenthistories to delete
     */
    where?: employmenthistoriesWhereInput
    /**
     * Limit how many employmenthistories to delete.
     */
    limit?: number
  }

  /**
   * employmenthistories.application
   */
  export type employmenthistories$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    where?: applicationWhereInput
  }

  /**
   * employmenthistories without action
   */
  export type employmenthistoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenthistories
     */
    select?: employmenthistoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenthistories
     */
    omit?: employmenthistoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenthistoriesInclude<ExtArgs> | null
  }


  /**
   * Model experiencedetails
   */

  export type AggregateExperiencedetails = {
    _count: ExperiencedetailsCountAggregateOutputType | null
    _avg: ExperiencedetailsAvgAggregateOutputType | null
    _sum: ExperiencedetailsSumAggregateOutputType | null
    _min: ExperiencedetailsMinAggregateOutputType | null
    _max: ExperiencedetailsMaxAggregateOutputType | null
  }

  export type ExperiencedetailsAvgAggregateOutputType = {
    ExperienceID: number | null
    ApplicationID: number | null
  }

  export type ExperiencedetailsSumAggregateOutputType = {
    ExperienceID: number | null
    ApplicationID: number | null
  }

  export type ExperiencedetailsMinAggregateOutputType = {
    ExperienceID: number | null
    ApplicationID: number | null
    Description: string | null
  }

  export type ExperiencedetailsMaxAggregateOutputType = {
    ExperienceID: number | null
    ApplicationID: number | null
    Description: string | null
  }

  export type ExperiencedetailsCountAggregateOutputType = {
    ExperienceID: number
    ApplicationID: number
    Description: number
    _all: number
  }


  export type ExperiencedetailsAvgAggregateInputType = {
    ExperienceID?: true
    ApplicationID?: true
  }

  export type ExperiencedetailsSumAggregateInputType = {
    ExperienceID?: true
    ApplicationID?: true
  }

  export type ExperiencedetailsMinAggregateInputType = {
    ExperienceID?: true
    ApplicationID?: true
    Description?: true
  }

  export type ExperiencedetailsMaxAggregateInputType = {
    ExperienceID?: true
    ApplicationID?: true
    Description?: true
  }

  export type ExperiencedetailsCountAggregateInputType = {
    ExperienceID?: true
    ApplicationID?: true
    Description?: true
    _all?: true
  }

  export type ExperiencedetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which experiencedetails to aggregate.
     */
    where?: experiencedetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of experiencedetails to fetch.
     */
    orderBy?: experiencedetailsOrderByWithRelationInput | experiencedetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: experiencedetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` experiencedetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` experiencedetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned experiencedetails
    **/
    _count?: true | ExperiencedetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExperiencedetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExperiencedetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExperiencedetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExperiencedetailsMaxAggregateInputType
  }

  export type GetExperiencedetailsAggregateType<T extends ExperiencedetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateExperiencedetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExperiencedetails[P]>
      : GetScalarType<T[P], AggregateExperiencedetails[P]>
  }




  export type experiencedetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: experiencedetailsWhereInput
    orderBy?: experiencedetailsOrderByWithAggregationInput | experiencedetailsOrderByWithAggregationInput[]
    by: ExperiencedetailsScalarFieldEnum[] | ExperiencedetailsScalarFieldEnum
    having?: experiencedetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExperiencedetailsCountAggregateInputType | true
    _avg?: ExperiencedetailsAvgAggregateInputType
    _sum?: ExperiencedetailsSumAggregateInputType
    _min?: ExperiencedetailsMinAggregateInputType
    _max?: ExperiencedetailsMaxAggregateInputType
  }

  export type ExperiencedetailsGroupByOutputType = {
    ExperienceID: number
    ApplicationID: number | null
    Description: string | null
    _count: ExperiencedetailsCountAggregateOutputType | null
    _avg: ExperiencedetailsAvgAggregateOutputType | null
    _sum: ExperiencedetailsSumAggregateOutputType | null
    _min: ExperiencedetailsMinAggregateOutputType | null
    _max: ExperiencedetailsMaxAggregateOutputType | null
  }

  type GetExperiencedetailsGroupByPayload<T extends experiencedetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExperiencedetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExperiencedetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExperiencedetailsGroupByOutputType[P]>
            : GetScalarType<T[P], ExperiencedetailsGroupByOutputType[P]>
        }
      >
    >


  export type experiencedetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ExperienceID?: boolean
    ApplicationID?: boolean
    Description?: boolean
    application?: boolean | experiencedetails$applicationArgs<ExtArgs>
  }, ExtArgs["result"]["experiencedetails"]>



  export type experiencedetailsSelectScalar = {
    ExperienceID?: boolean
    ApplicationID?: boolean
    Description?: boolean
  }

  export type experiencedetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ExperienceID" | "ApplicationID" | "Description", ExtArgs["result"]["experiencedetails"]>
  export type experiencedetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | experiencedetails$applicationArgs<ExtArgs>
  }

  export type $experiencedetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "experiencedetails"
    objects: {
      application: Prisma.$applicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ExperienceID: number
      ApplicationID: number | null
      Description: string | null
    }, ExtArgs["result"]["experiencedetails"]>
    composites: {}
  }

  type experiencedetailsGetPayload<S extends boolean | null | undefined | experiencedetailsDefaultArgs> = $Result.GetResult<Prisma.$experiencedetailsPayload, S>

  type experiencedetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<experiencedetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExperiencedetailsCountAggregateInputType | true
    }

  export interface experiencedetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['experiencedetails'], meta: { name: 'experiencedetails' } }
    /**
     * Find zero or one Experiencedetails that matches the filter.
     * @param {experiencedetailsFindUniqueArgs} args - Arguments to find a Experiencedetails
     * @example
     * // Get one Experiencedetails
     * const experiencedetails = await prisma.experiencedetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends experiencedetailsFindUniqueArgs>(args: SelectSubset<T, experiencedetailsFindUniqueArgs<ExtArgs>>): Prisma__experiencedetailsClient<$Result.GetResult<Prisma.$experiencedetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Experiencedetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {experiencedetailsFindUniqueOrThrowArgs} args - Arguments to find a Experiencedetails
     * @example
     * // Get one Experiencedetails
     * const experiencedetails = await prisma.experiencedetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends experiencedetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, experiencedetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__experiencedetailsClient<$Result.GetResult<Prisma.$experiencedetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Experiencedetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {experiencedetailsFindFirstArgs} args - Arguments to find a Experiencedetails
     * @example
     * // Get one Experiencedetails
     * const experiencedetails = await prisma.experiencedetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends experiencedetailsFindFirstArgs>(args?: SelectSubset<T, experiencedetailsFindFirstArgs<ExtArgs>>): Prisma__experiencedetailsClient<$Result.GetResult<Prisma.$experiencedetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Experiencedetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {experiencedetailsFindFirstOrThrowArgs} args - Arguments to find a Experiencedetails
     * @example
     * // Get one Experiencedetails
     * const experiencedetails = await prisma.experiencedetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends experiencedetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, experiencedetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__experiencedetailsClient<$Result.GetResult<Prisma.$experiencedetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Experiencedetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {experiencedetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Experiencedetails
     * const experiencedetails = await prisma.experiencedetails.findMany()
     * 
     * // Get first 10 Experiencedetails
     * const experiencedetails = await prisma.experiencedetails.findMany({ take: 10 })
     * 
     * // Only select the `ExperienceID`
     * const experiencedetailsWithExperienceIDOnly = await prisma.experiencedetails.findMany({ select: { ExperienceID: true } })
     * 
     */
    findMany<T extends experiencedetailsFindManyArgs>(args?: SelectSubset<T, experiencedetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$experiencedetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Experiencedetails.
     * @param {experiencedetailsCreateArgs} args - Arguments to create a Experiencedetails.
     * @example
     * // Create one Experiencedetails
     * const Experiencedetails = await prisma.experiencedetails.create({
     *   data: {
     *     // ... data to create a Experiencedetails
     *   }
     * })
     * 
     */
    create<T extends experiencedetailsCreateArgs>(args: SelectSubset<T, experiencedetailsCreateArgs<ExtArgs>>): Prisma__experiencedetailsClient<$Result.GetResult<Prisma.$experiencedetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Experiencedetails.
     * @param {experiencedetailsCreateManyArgs} args - Arguments to create many Experiencedetails.
     * @example
     * // Create many Experiencedetails
     * const experiencedetails = await prisma.experiencedetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends experiencedetailsCreateManyArgs>(args?: SelectSubset<T, experiencedetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Experiencedetails.
     * @param {experiencedetailsDeleteArgs} args - Arguments to delete one Experiencedetails.
     * @example
     * // Delete one Experiencedetails
     * const Experiencedetails = await prisma.experiencedetails.delete({
     *   where: {
     *     // ... filter to delete one Experiencedetails
     *   }
     * })
     * 
     */
    delete<T extends experiencedetailsDeleteArgs>(args: SelectSubset<T, experiencedetailsDeleteArgs<ExtArgs>>): Prisma__experiencedetailsClient<$Result.GetResult<Prisma.$experiencedetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Experiencedetails.
     * @param {experiencedetailsUpdateArgs} args - Arguments to update one Experiencedetails.
     * @example
     * // Update one Experiencedetails
     * const experiencedetails = await prisma.experiencedetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends experiencedetailsUpdateArgs>(args: SelectSubset<T, experiencedetailsUpdateArgs<ExtArgs>>): Prisma__experiencedetailsClient<$Result.GetResult<Prisma.$experiencedetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Experiencedetails.
     * @param {experiencedetailsDeleteManyArgs} args - Arguments to filter Experiencedetails to delete.
     * @example
     * // Delete a few Experiencedetails
     * const { count } = await prisma.experiencedetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends experiencedetailsDeleteManyArgs>(args?: SelectSubset<T, experiencedetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Experiencedetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {experiencedetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Experiencedetails
     * const experiencedetails = await prisma.experiencedetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends experiencedetailsUpdateManyArgs>(args: SelectSubset<T, experiencedetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Experiencedetails.
     * @param {experiencedetailsUpsertArgs} args - Arguments to update or create a Experiencedetails.
     * @example
     * // Update or create a Experiencedetails
     * const experiencedetails = await prisma.experiencedetails.upsert({
     *   create: {
     *     // ... data to create a Experiencedetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Experiencedetails we want to update
     *   }
     * })
     */
    upsert<T extends experiencedetailsUpsertArgs>(args: SelectSubset<T, experiencedetailsUpsertArgs<ExtArgs>>): Prisma__experiencedetailsClient<$Result.GetResult<Prisma.$experiencedetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Experiencedetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {experiencedetailsCountArgs} args - Arguments to filter Experiencedetails to count.
     * @example
     * // Count the number of Experiencedetails
     * const count = await prisma.experiencedetails.count({
     *   where: {
     *     // ... the filter for the Experiencedetails we want to count
     *   }
     * })
    **/
    count<T extends experiencedetailsCountArgs>(
      args?: Subset<T, experiencedetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExperiencedetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Experiencedetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperiencedetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExperiencedetailsAggregateArgs>(args: Subset<T, ExperiencedetailsAggregateArgs>): Prisma.PrismaPromise<GetExperiencedetailsAggregateType<T>>

    /**
     * Group by Experiencedetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {experiencedetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends experiencedetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: experiencedetailsGroupByArgs['orderBy'] }
        : { orderBy?: experiencedetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, experiencedetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExperiencedetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the experiencedetails model
   */
  readonly fields: experiencedetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for experiencedetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__experiencedetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends experiencedetails$applicationArgs<ExtArgs> = {}>(args?: Subset<T, experiencedetails$applicationArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the experiencedetails model
   */
  interface experiencedetailsFieldRefs {
    readonly ExperienceID: FieldRef<"experiencedetails", 'Int'>
    readonly ApplicationID: FieldRef<"experiencedetails", 'Int'>
    readonly Description: FieldRef<"experiencedetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * experiencedetails findUnique
   */
  export type experiencedetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiencedetails
     */
    select?: experiencedetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiencedetails
     */
    omit?: experiencedetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencedetailsInclude<ExtArgs> | null
    /**
     * Filter, which experiencedetails to fetch.
     */
    where: experiencedetailsWhereUniqueInput
  }

  /**
   * experiencedetails findUniqueOrThrow
   */
  export type experiencedetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiencedetails
     */
    select?: experiencedetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiencedetails
     */
    omit?: experiencedetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencedetailsInclude<ExtArgs> | null
    /**
     * Filter, which experiencedetails to fetch.
     */
    where: experiencedetailsWhereUniqueInput
  }

  /**
   * experiencedetails findFirst
   */
  export type experiencedetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiencedetails
     */
    select?: experiencedetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiencedetails
     */
    omit?: experiencedetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencedetailsInclude<ExtArgs> | null
    /**
     * Filter, which experiencedetails to fetch.
     */
    where?: experiencedetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of experiencedetails to fetch.
     */
    orderBy?: experiencedetailsOrderByWithRelationInput | experiencedetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for experiencedetails.
     */
    cursor?: experiencedetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` experiencedetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` experiencedetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of experiencedetails.
     */
    distinct?: ExperiencedetailsScalarFieldEnum | ExperiencedetailsScalarFieldEnum[]
  }

  /**
   * experiencedetails findFirstOrThrow
   */
  export type experiencedetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiencedetails
     */
    select?: experiencedetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiencedetails
     */
    omit?: experiencedetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencedetailsInclude<ExtArgs> | null
    /**
     * Filter, which experiencedetails to fetch.
     */
    where?: experiencedetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of experiencedetails to fetch.
     */
    orderBy?: experiencedetailsOrderByWithRelationInput | experiencedetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for experiencedetails.
     */
    cursor?: experiencedetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` experiencedetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` experiencedetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of experiencedetails.
     */
    distinct?: ExperiencedetailsScalarFieldEnum | ExperiencedetailsScalarFieldEnum[]
  }

  /**
   * experiencedetails findMany
   */
  export type experiencedetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiencedetails
     */
    select?: experiencedetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiencedetails
     */
    omit?: experiencedetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencedetailsInclude<ExtArgs> | null
    /**
     * Filter, which experiencedetails to fetch.
     */
    where?: experiencedetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of experiencedetails to fetch.
     */
    orderBy?: experiencedetailsOrderByWithRelationInput | experiencedetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing experiencedetails.
     */
    cursor?: experiencedetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` experiencedetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` experiencedetails.
     */
    skip?: number
    distinct?: ExperiencedetailsScalarFieldEnum | ExperiencedetailsScalarFieldEnum[]
  }

  /**
   * experiencedetails create
   */
  export type experiencedetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiencedetails
     */
    select?: experiencedetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiencedetails
     */
    omit?: experiencedetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencedetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a experiencedetails.
     */
    data?: XOR<experiencedetailsCreateInput, experiencedetailsUncheckedCreateInput>
  }

  /**
   * experiencedetails createMany
   */
  export type experiencedetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many experiencedetails.
     */
    data: experiencedetailsCreateManyInput | experiencedetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * experiencedetails update
   */
  export type experiencedetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiencedetails
     */
    select?: experiencedetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiencedetails
     */
    omit?: experiencedetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencedetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a experiencedetails.
     */
    data: XOR<experiencedetailsUpdateInput, experiencedetailsUncheckedUpdateInput>
    /**
     * Choose, which experiencedetails to update.
     */
    where: experiencedetailsWhereUniqueInput
  }

  /**
   * experiencedetails updateMany
   */
  export type experiencedetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update experiencedetails.
     */
    data: XOR<experiencedetailsUpdateManyMutationInput, experiencedetailsUncheckedUpdateManyInput>
    /**
     * Filter which experiencedetails to update
     */
    where?: experiencedetailsWhereInput
    /**
     * Limit how many experiencedetails to update.
     */
    limit?: number
  }

  /**
   * experiencedetails upsert
   */
  export type experiencedetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiencedetails
     */
    select?: experiencedetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiencedetails
     */
    omit?: experiencedetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencedetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the experiencedetails to update in case it exists.
     */
    where: experiencedetailsWhereUniqueInput
    /**
     * In case the experiencedetails found by the `where` argument doesn't exist, create a new experiencedetails with this data.
     */
    create: XOR<experiencedetailsCreateInput, experiencedetailsUncheckedCreateInput>
    /**
     * In case the experiencedetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<experiencedetailsUpdateInput, experiencedetailsUncheckedUpdateInput>
  }

  /**
   * experiencedetails delete
   */
  export type experiencedetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiencedetails
     */
    select?: experiencedetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiencedetails
     */
    omit?: experiencedetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencedetailsInclude<ExtArgs> | null
    /**
     * Filter which experiencedetails to delete.
     */
    where: experiencedetailsWhereUniqueInput
  }

  /**
   * experiencedetails deleteMany
   */
  export type experiencedetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which experiencedetails to delete
     */
    where?: experiencedetailsWhereInput
    /**
     * Limit how many experiencedetails to delete.
     */
    limit?: number
  }

  /**
   * experiencedetails.application
   */
  export type experiencedetails$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    where?: applicationWhereInput
  }

  /**
   * experiencedetails without action
   */
  export type experiencedetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiencedetails
     */
    select?: experiencedetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiencedetails
     */
    omit?: experiencedetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencedetailsInclude<ExtArgs> | null
  }


  /**
   * Model gce_al_results
   */

  export type AggregateGce_al_results = {
    _count: Gce_al_resultsCountAggregateOutputType | null
    _avg: Gce_al_resultsAvgAggregateOutputType | null
    _sum: Gce_al_resultsSumAggregateOutputType | null
    _min: Gce_al_resultsMinAggregateOutputType | null
    _max: Gce_al_resultsMaxAggregateOutputType | null
  }

  export type Gce_al_resultsAvgAggregateOutputType = {
    AL_ID: number | null
    ApplicationID: number | null
  }

  export type Gce_al_resultsSumAggregateOutputType = {
    AL_ID: number | null
    ApplicationID: number | null
  }

  export type Gce_al_resultsMinAggregateOutputType = {
    AL_ID: number | null
    ApplicationID: number | null
    Subject: string | null
    Grade: string | null
  }

  export type Gce_al_resultsMaxAggregateOutputType = {
    AL_ID: number | null
    ApplicationID: number | null
    Subject: string | null
    Grade: string | null
  }

  export type Gce_al_resultsCountAggregateOutputType = {
    AL_ID: number
    ApplicationID: number
    Subject: number
    Grade: number
    _all: number
  }


  export type Gce_al_resultsAvgAggregateInputType = {
    AL_ID?: true
    ApplicationID?: true
  }

  export type Gce_al_resultsSumAggregateInputType = {
    AL_ID?: true
    ApplicationID?: true
  }

  export type Gce_al_resultsMinAggregateInputType = {
    AL_ID?: true
    ApplicationID?: true
    Subject?: true
    Grade?: true
  }

  export type Gce_al_resultsMaxAggregateInputType = {
    AL_ID?: true
    ApplicationID?: true
    Subject?: true
    Grade?: true
  }

  export type Gce_al_resultsCountAggregateInputType = {
    AL_ID?: true
    ApplicationID?: true
    Subject?: true
    Grade?: true
    _all?: true
  }

  export type Gce_al_resultsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gce_al_results to aggregate.
     */
    where?: gce_al_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gce_al_results to fetch.
     */
    orderBy?: gce_al_resultsOrderByWithRelationInput | gce_al_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gce_al_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gce_al_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gce_al_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gce_al_results
    **/
    _count?: true | Gce_al_resultsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Gce_al_resultsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Gce_al_resultsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gce_al_resultsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gce_al_resultsMaxAggregateInputType
  }

  export type GetGce_al_resultsAggregateType<T extends Gce_al_resultsAggregateArgs> = {
        [P in keyof T & keyof AggregateGce_al_results]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGce_al_results[P]>
      : GetScalarType<T[P], AggregateGce_al_results[P]>
  }




  export type gce_al_resultsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gce_al_resultsWhereInput
    orderBy?: gce_al_resultsOrderByWithAggregationInput | gce_al_resultsOrderByWithAggregationInput[]
    by: Gce_al_resultsScalarFieldEnum[] | Gce_al_resultsScalarFieldEnum
    having?: gce_al_resultsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gce_al_resultsCountAggregateInputType | true
    _avg?: Gce_al_resultsAvgAggregateInputType
    _sum?: Gce_al_resultsSumAggregateInputType
    _min?: Gce_al_resultsMinAggregateInputType
    _max?: Gce_al_resultsMaxAggregateInputType
  }

  export type Gce_al_resultsGroupByOutputType = {
    AL_ID: number
    ApplicationID: number | null
    Subject: string | null
    Grade: string | null
    _count: Gce_al_resultsCountAggregateOutputType | null
    _avg: Gce_al_resultsAvgAggregateOutputType | null
    _sum: Gce_al_resultsSumAggregateOutputType | null
    _min: Gce_al_resultsMinAggregateOutputType | null
    _max: Gce_al_resultsMaxAggregateOutputType | null
  }

  type GetGce_al_resultsGroupByPayload<T extends gce_al_resultsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Gce_al_resultsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gce_al_resultsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gce_al_resultsGroupByOutputType[P]>
            : GetScalarType<T[P], Gce_al_resultsGroupByOutputType[P]>
        }
      >
    >


  export type gce_al_resultsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    AL_ID?: boolean
    ApplicationID?: boolean
    Subject?: boolean
    Grade?: boolean
    application?: boolean | gce_al_results$applicationArgs<ExtArgs>
  }, ExtArgs["result"]["gce_al_results"]>



  export type gce_al_resultsSelectScalar = {
    AL_ID?: boolean
    ApplicationID?: boolean
    Subject?: boolean
    Grade?: boolean
  }

  export type gce_al_resultsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"AL_ID" | "ApplicationID" | "Subject" | "Grade", ExtArgs["result"]["gce_al_results"]>
  export type gce_al_resultsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | gce_al_results$applicationArgs<ExtArgs>
  }

  export type $gce_al_resultsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "gce_al_results"
    objects: {
      application: Prisma.$applicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      AL_ID: number
      ApplicationID: number | null
      Subject: string | null
      Grade: string | null
    }, ExtArgs["result"]["gce_al_results"]>
    composites: {}
  }

  type gce_al_resultsGetPayload<S extends boolean | null | undefined | gce_al_resultsDefaultArgs> = $Result.GetResult<Prisma.$gce_al_resultsPayload, S>

  type gce_al_resultsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<gce_al_resultsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Gce_al_resultsCountAggregateInputType | true
    }

  export interface gce_al_resultsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['gce_al_results'], meta: { name: 'gce_al_results' } }
    /**
     * Find zero or one Gce_al_results that matches the filter.
     * @param {gce_al_resultsFindUniqueArgs} args - Arguments to find a Gce_al_results
     * @example
     * // Get one Gce_al_results
     * const gce_al_results = await prisma.gce_al_results.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends gce_al_resultsFindUniqueArgs>(args: SelectSubset<T, gce_al_resultsFindUniqueArgs<ExtArgs>>): Prisma__gce_al_resultsClient<$Result.GetResult<Prisma.$gce_al_resultsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gce_al_results that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {gce_al_resultsFindUniqueOrThrowArgs} args - Arguments to find a Gce_al_results
     * @example
     * // Get one Gce_al_results
     * const gce_al_results = await prisma.gce_al_results.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends gce_al_resultsFindUniqueOrThrowArgs>(args: SelectSubset<T, gce_al_resultsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__gce_al_resultsClient<$Result.GetResult<Prisma.$gce_al_resultsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gce_al_results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gce_al_resultsFindFirstArgs} args - Arguments to find a Gce_al_results
     * @example
     * // Get one Gce_al_results
     * const gce_al_results = await prisma.gce_al_results.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends gce_al_resultsFindFirstArgs>(args?: SelectSubset<T, gce_al_resultsFindFirstArgs<ExtArgs>>): Prisma__gce_al_resultsClient<$Result.GetResult<Prisma.$gce_al_resultsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gce_al_results that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gce_al_resultsFindFirstOrThrowArgs} args - Arguments to find a Gce_al_results
     * @example
     * // Get one Gce_al_results
     * const gce_al_results = await prisma.gce_al_results.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends gce_al_resultsFindFirstOrThrowArgs>(args?: SelectSubset<T, gce_al_resultsFindFirstOrThrowArgs<ExtArgs>>): Prisma__gce_al_resultsClient<$Result.GetResult<Prisma.$gce_al_resultsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gce_al_results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gce_al_resultsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gce_al_results
     * const gce_al_results = await prisma.gce_al_results.findMany()
     * 
     * // Get first 10 Gce_al_results
     * const gce_al_results = await prisma.gce_al_results.findMany({ take: 10 })
     * 
     * // Only select the `AL_ID`
     * const gce_al_resultsWithAL_IDOnly = await prisma.gce_al_results.findMany({ select: { AL_ID: true } })
     * 
     */
    findMany<T extends gce_al_resultsFindManyArgs>(args?: SelectSubset<T, gce_al_resultsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gce_al_resultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gce_al_results.
     * @param {gce_al_resultsCreateArgs} args - Arguments to create a Gce_al_results.
     * @example
     * // Create one Gce_al_results
     * const Gce_al_results = await prisma.gce_al_results.create({
     *   data: {
     *     // ... data to create a Gce_al_results
     *   }
     * })
     * 
     */
    create<T extends gce_al_resultsCreateArgs>(args: SelectSubset<T, gce_al_resultsCreateArgs<ExtArgs>>): Prisma__gce_al_resultsClient<$Result.GetResult<Prisma.$gce_al_resultsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gce_al_results.
     * @param {gce_al_resultsCreateManyArgs} args - Arguments to create many Gce_al_results.
     * @example
     * // Create many Gce_al_results
     * const gce_al_results = await prisma.gce_al_results.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends gce_al_resultsCreateManyArgs>(args?: SelectSubset<T, gce_al_resultsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gce_al_results.
     * @param {gce_al_resultsDeleteArgs} args - Arguments to delete one Gce_al_results.
     * @example
     * // Delete one Gce_al_results
     * const Gce_al_results = await prisma.gce_al_results.delete({
     *   where: {
     *     // ... filter to delete one Gce_al_results
     *   }
     * })
     * 
     */
    delete<T extends gce_al_resultsDeleteArgs>(args: SelectSubset<T, gce_al_resultsDeleteArgs<ExtArgs>>): Prisma__gce_al_resultsClient<$Result.GetResult<Prisma.$gce_al_resultsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gce_al_results.
     * @param {gce_al_resultsUpdateArgs} args - Arguments to update one Gce_al_results.
     * @example
     * // Update one Gce_al_results
     * const gce_al_results = await prisma.gce_al_results.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends gce_al_resultsUpdateArgs>(args: SelectSubset<T, gce_al_resultsUpdateArgs<ExtArgs>>): Prisma__gce_al_resultsClient<$Result.GetResult<Prisma.$gce_al_resultsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gce_al_results.
     * @param {gce_al_resultsDeleteManyArgs} args - Arguments to filter Gce_al_results to delete.
     * @example
     * // Delete a few Gce_al_results
     * const { count } = await prisma.gce_al_results.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends gce_al_resultsDeleteManyArgs>(args?: SelectSubset<T, gce_al_resultsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gce_al_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gce_al_resultsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gce_al_results
     * const gce_al_results = await prisma.gce_al_results.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends gce_al_resultsUpdateManyArgs>(args: SelectSubset<T, gce_al_resultsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gce_al_results.
     * @param {gce_al_resultsUpsertArgs} args - Arguments to update or create a Gce_al_results.
     * @example
     * // Update or create a Gce_al_results
     * const gce_al_results = await prisma.gce_al_results.upsert({
     *   create: {
     *     // ... data to create a Gce_al_results
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gce_al_results we want to update
     *   }
     * })
     */
    upsert<T extends gce_al_resultsUpsertArgs>(args: SelectSubset<T, gce_al_resultsUpsertArgs<ExtArgs>>): Prisma__gce_al_resultsClient<$Result.GetResult<Prisma.$gce_al_resultsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gce_al_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gce_al_resultsCountArgs} args - Arguments to filter Gce_al_results to count.
     * @example
     * // Count the number of Gce_al_results
     * const count = await prisma.gce_al_results.count({
     *   where: {
     *     // ... the filter for the Gce_al_results we want to count
     *   }
     * })
    **/
    count<T extends gce_al_resultsCountArgs>(
      args?: Subset<T, gce_al_resultsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gce_al_resultsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gce_al_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gce_al_resultsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gce_al_resultsAggregateArgs>(args: Subset<T, Gce_al_resultsAggregateArgs>): Prisma.PrismaPromise<GetGce_al_resultsAggregateType<T>>

    /**
     * Group by Gce_al_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gce_al_resultsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gce_al_resultsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gce_al_resultsGroupByArgs['orderBy'] }
        : { orderBy?: gce_al_resultsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gce_al_resultsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGce_al_resultsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the gce_al_results model
   */
  readonly fields: gce_al_resultsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for gce_al_results.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__gce_al_resultsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends gce_al_results$applicationArgs<ExtArgs> = {}>(args?: Subset<T, gce_al_results$applicationArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the gce_al_results model
   */
  interface gce_al_resultsFieldRefs {
    readonly AL_ID: FieldRef<"gce_al_results", 'Int'>
    readonly ApplicationID: FieldRef<"gce_al_results", 'Int'>
    readonly Subject: FieldRef<"gce_al_results", 'String'>
    readonly Grade: FieldRef<"gce_al_results", 'String'>
  }
    

  // Custom InputTypes
  /**
   * gce_al_results findUnique
   */
  export type gce_al_resultsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_al_results
     */
    select?: gce_al_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_al_results
     */
    omit?: gce_al_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_al_resultsInclude<ExtArgs> | null
    /**
     * Filter, which gce_al_results to fetch.
     */
    where: gce_al_resultsWhereUniqueInput
  }

  /**
   * gce_al_results findUniqueOrThrow
   */
  export type gce_al_resultsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_al_results
     */
    select?: gce_al_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_al_results
     */
    omit?: gce_al_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_al_resultsInclude<ExtArgs> | null
    /**
     * Filter, which gce_al_results to fetch.
     */
    where: gce_al_resultsWhereUniqueInput
  }

  /**
   * gce_al_results findFirst
   */
  export type gce_al_resultsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_al_results
     */
    select?: gce_al_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_al_results
     */
    omit?: gce_al_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_al_resultsInclude<ExtArgs> | null
    /**
     * Filter, which gce_al_results to fetch.
     */
    where?: gce_al_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gce_al_results to fetch.
     */
    orderBy?: gce_al_resultsOrderByWithRelationInput | gce_al_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gce_al_results.
     */
    cursor?: gce_al_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gce_al_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gce_al_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gce_al_results.
     */
    distinct?: Gce_al_resultsScalarFieldEnum | Gce_al_resultsScalarFieldEnum[]
  }

  /**
   * gce_al_results findFirstOrThrow
   */
  export type gce_al_resultsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_al_results
     */
    select?: gce_al_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_al_results
     */
    omit?: gce_al_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_al_resultsInclude<ExtArgs> | null
    /**
     * Filter, which gce_al_results to fetch.
     */
    where?: gce_al_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gce_al_results to fetch.
     */
    orderBy?: gce_al_resultsOrderByWithRelationInput | gce_al_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gce_al_results.
     */
    cursor?: gce_al_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gce_al_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gce_al_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gce_al_results.
     */
    distinct?: Gce_al_resultsScalarFieldEnum | Gce_al_resultsScalarFieldEnum[]
  }

  /**
   * gce_al_results findMany
   */
  export type gce_al_resultsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_al_results
     */
    select?: gce_al_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_al_results
     */
    omit?: gce_al_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_al_resultsInclude<ExtArgs> | null
    /**
     * Filter, which gce_al_results to fetch.
     */
    where?: gce_al_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gce_al_results to fetch.
     */
    orderBy?: gce_al_resultsOrderByWithRelationInput | gce_al_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gce_al_results.
     */
    cursor?: gce_al_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gce_al_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gce_al_results.
     */
    skip?: number
    distinct?: Gce_al_resultsScalarFieldEnum | Gce_al_resultsScalarFieldEnum[]
  }

  /**
   * gce_al_results create
   */
  export type gce_al_resultsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_al_results
     */
    select?: gce_al_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_al_results
     */
    omit?: gce_al_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_al_resultsInclude<ExtArgs> | null
    /**
     * The data needed to create a gce_al_results.
     */
    data?: XOR<gce_al_resultsCreateInput, gce_al_resultsUncheckedCreateInput>
  }

  /**
   * gce_al_results createMany
   */
  export type gce_al_resultsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many gce_al_results.
     */
    data: gce_al_resultsCreateManyInput | gce_al_resultsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * gce_al_results update
   */
  export type gce_al_resultsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_al_results
     */
    select?: gce_al_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_al_results
     */
    omit?: gce_al_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_al_resultsInclude<ExtArgs> | null
    /**
     * The data needed to update a gce_al_results.
     */
    data: XOR<gce_al_resultsUpdateInput, gce_al_resultsUncheckedUpdateInput>
    /**
     * Choose, which gce_al_results to update.
     */
    where: gce_al_resultsWhereUniqueInput
  }

  /**
   * gce_al_results updateMany
   */
  export type gce_al_resultsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update gce_al_results.
     */
    data: XOR<gce_al_resultsUpdateManyMutationInput, gce_al_resultsUncheckedUpdateManyInput>
    /**
     * Filter which gce_al_results to update
     */
    where?: gce_al_resultsWhereInput
    /**
     * Limit how many gce_al_results to update.
     */
    limit?: number
  }

  /**
   * gce_al_results upsert
   */
  export type gce_al_resultsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_al_results
     */
    select?: gce_al_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_al_results
     */
    omit?: gce_al_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_al_resultsInclude<ExtArgs> | null
    /**
     * The filter to search for the gce_al_results to update in case it exists.
     */
    where: gce_al_resultsWhereUniqueInput
    /**
     * In case the gce_al_results found by the `where` argument doesn't exist, create a new gce_al_results with this data.
     */
    create: XOR<gce_al_resultsCreateInput, gce_al_resultsUncheckedCreateInput>
    /**
     * In case the gce_al_results was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gce_al_resultsUpdateInput, gce_al_resultsUncheckedUpdateInput>
  }

  /**
   * gce_al_results delete
   */
  export type gce_al_resultsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_al_results
     */
    select?: gce_al_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_al_results
     */
    omit?: gce_al_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_al_resultsInclude<ExtArgs> | null
    /**
     * Filter which gce_al_results to delete.
     */
    where: gce_al_resultsWhereUniqueInput
  }

  /**
   * gce_al_results deleteMany
   */
  export type gce_al_resultsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gce_al_results to delete
     */
    where?: gce_al_resultsWhereInput
    /**
     * Limit how many gce_al_results to delete.
     */
    limit?: number
  }

  /**
   * gce_al_results.application
   */
  export type gce_al_results$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    where?: applicationWhereInput
  }

  /**
   * gce_al_results without action
   */
  export type gce_al_resultsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_al_results
     */
    select?: gce_al_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_al_results
     */
    omit?: gce_al_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_al_resultsInclude<ExtArgs> | null
  }


  /**
   * Model gce_ol_results
   */

  export type AggregateGce_ol_results = {
    _count: Gce_ol_resultsCountAggregateOutputType | null
    _avg: Gce_ol_resultsAvgAggregateOutputType | null
    _sum: Gce_ol_resultsSumAggregateOutputType | null
    _min: Gce_ol_resultsMinAggregateOutputType | null
    _max: Gce_ol_resultsMaxAggregateOutputType | null
  }

  export type Gce_ol_resultsAvgAggregateOutputType = {
    OL_ID: number | null
    ApplicationID: number | null
  }

  export type Gce_ol_resultsSumAggregateOutputType = {
    OL_ID: number | null
    ApplicationID: number | null
  }

  export type Gce_ol_resultsMinAggregateOutputType = {
    OL_ID: number | null
    ApplicationID: number | null
    Subject: string | null
    Grade: string | null
  }

  export type Gce_ol_resultsMaxAggregateOutputType = {
    OL_ID: number | null
    ApplicationID: number | null
    Subject: string | null
    Grade: string | null
  }

  export type Gce_ol_resultsCountAggregateOutputType = {
    OL_ID: number
    ApplicationID: number
    Subject: number
    Grade: number
    _all: number
  }


  export type Gce_ol_resultsAvgAggregateInputType = {
    OL_ID?: true
    ApplicationID?: true
  }

  export type Gce_ol_resultsSumAggregateInputType = {
    OL_ID?: true
    ApplicationID?: true
  }

  export type Gce_ol_resultsMinAggregateInputType = {
    OL_ID?: true
    ApplicationID?: true
    Subject?: true
    Grade?: true
  }

  export type Gce_ol_resultsMaxAggregateInputType = {
    OL_ID?: true
    ApplicationID?: true
    Subject?: true
    Grade?: true
  }

  export type Gce_ol_resultsCountAggregateInputType = {
    OL_ID?: true
    ApplicationID?: true
    Subject?: true
    Grade?: true
    _all?: true
  }

  export type Gce_ol_resultsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gce_ol_results to aggregate.
     */
    where?: gce_ol_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gce_ol_results to fetch.
     */
    orderBy?: gce_ol_resultsOrderByWithRelationInput | gce_ol_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gce_ol_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gce_ol_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gce_ol_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gce_ol_results
    **/
    _count?: true | Gce_ol_resultsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Gce_ol_resultsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Gce_ol_resultsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gce_ol_resultsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gce_ol_resultsMaxAggregateInputType
  }

  export type GetGce_ol_resultsAggregateType<T extends Gce_ol_resultsAggregateArgs> = {
        [P in keyof T & keyof AggregateGce_ol_results]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGce_ol_results[P]>
      : GetScalarType<T[P], AggregateGce_ol_results[P]>
  }




  export type gce_ol_resultsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gce_ol_resultsWhereInput
    orderBy?: gce_ol_resultsOrderByWithAggregationInput | gce_ol_resultsOrderByWithAggregationInput[]
    by: Gce_ol_resultsScalarFieldEnum[] | Gce_ol_resultsScalarFieldEnum
    having?: gce_ol_resultsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gce_ol_resultsCountAggregateInputType | true
    _avg?: Gce_ol_resultsAvgAggregateInputType
    _sum?: Gce_ol_resultsSumAggregateInputType
    _min?: Gce_ol_resultsMinAggregateInputType
    _max?: Gce_ol_resultsMaxAggregateInputType
  }

  export type Gce_ol_resultsGroupByOutputType = {
    OL_ID: number
    ApplicationID: number | null
    Subject: string | null
    Grade: string | null
    _count: Gce_ol_resultsCountAggregateOutputType | null
    _avg: Gce_ol_resultsAvgAggregateOutputType | null
    _sum: Gce_ol_resultsSumAggregateOutputType | null
    _min: Gce_ol_resultsMinAggregateOutputType | null
    _max: Gce_ol_resultsMaxAggregateOutputType | null
  }

  type GetGce_ol_resultsGroupByPayload<T extends gce_ol_resultsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Gce_ol_resultsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gce_ol_resultsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gce_ol_resultsGroupByOutputType[P]>
            : GetScalarType<T[P], Gce_ol_resultsGroupByOutputType[P]>
        }
      >
    >


  export type gce_ol_resultsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    OL_ID?: boolean
    ApplicationID?: boolean
    Subject?: boolean
    Grade?: boolean
    application?: boolean | gce_ol_results$applicationArgs<ExtArgs>
  }, ExtArgs["result"]["gce_ol_results"]>



  export type gce_ol_resultsSelectScalar = {
    OL_ID?: boolean
    ApplicationID?: boolean
    Subject?: boolean
    Grade?: boolean
  }

  export type gce_ol_resultsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"OL_ID" | "ApplicationID" | "Subject" | "Grade", ExtArgs["result"]["gce_ol_results"]>
  export type gce_ol_resultsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | gce_ol_results$applicationArgs<ExtArgs>
  }

  export type $gce_ol_resultsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "gce_ol_results"
    objects: {
      application: Prisma.$applicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      OL_ID: number
      ApplicationID: number | null
      Subject: string | null
      Grade: string | null
    }, ExtArgs["result"]["gce_ol_results"]>
    composites: {}
  }

  type gce_ol_resultsGetPayload<S extends boolean | null | undefined | gce_ol_resultsDefaultArgs> = $Result.GetResult<Prisma.$gce_ol_resultsPayload, S>

  type gce_ol_resultsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<gce_ol_resultsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Gce_ol_resultsCountAggregateInputType | true
    }

  export interface gce_ol_resultsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['gce_ol_results'], meta: { name: 'gce_ol_results' } }
    /**
     * Find zero or one Gce_ol_results that matches the filter.
     * @param {gce_ol_resultsFindUniqueArgs} args - Arguments to find a Gce_ol_results
     * @example
     * // Get one Gce_ol_results
     * const gce_ol_results = await prisma.gce_ol_results.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends gce_ol_resultsFindUniqueArgs>(args: SelectSubset<T, gce_ol_resultsFindUniqueArgs<ExtArgs>>): Prisma__gce_ol_resultsClient<$Result.GetResult<Prisma.$gce_ol_resultsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gce_ol_results that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {gce_ol_resultsFindUniqueOrThrowArgs} args - Arguments to find a Gce_ol_results
     * @example
     * // Get one Gce_ol_results
     * const gce_ol_results = await prisma.gce_ol_results.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends gce_ol_resultsFindUniqueOrThrowArgs>(args: SelectSubset<T, gce_ol_resultsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__gce_ol_resultsClient<$Result.GetResult<Prisma.$gce_ol_resultsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gce_ol_results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gce_ol_resultsFindFirstArgs} args - Arguments to find a Gce_ol_results
     * @example
     * // Get one Gce_ol_results
     * const gce_ol_results = await prisma.gce_ol_results.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends gce_ol_resultsFindFirstArgs>(args?: SelectSubset<T, gce_ol_resultsFindFirstArgs<ExtArgs>>): Prisma__gce_ol_resultsClient<$Result.GetResult<Prisma.$gce_ol_resultsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gce_ol_results that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gce_ol_resultsFindFirstOrThrowArgs} args - Arguments to find a Gce_ol_results
     * @example
     * // Get one Gce_ol_results
     * const gce_ol_results = await prisma.gce_ol_results.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends gce_ol_resultsFindFirstOrThrowArgs>(args?: SelectSubset<T, gce_ol_resultsFindFirstOrThrowArgs<ExtArgs>>): Prisma__gce_ol_resultsClient<$Result.GetResult<Prisma.$gce_ol_resultsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gce_ol_results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gce_ol_resultsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gce_ol_results
     * const gce_ol_results = await prisma.gce_ol_results.findMany()
     * 
     * // Get first 10 Gce_ol_results
     * const gce_ol_results = await prisma.gce_ol_results.findMany({ take: 10 })
     * 
     * // Only select the `OL_ID`
     * const gce_ol_resultsWithOL_IDOnly = await prisma.gce_ol_results.findMany({ select: { OL_ID: true } })
     * 
     */
    findMany<T extends gce_ol_resultsFindManyArgs>(args?: SelectSubset<T, gce_ol_resultsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gce_ol_resultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gce_ol_results.
     * @param {gce_ol_resultsCreateArgs} args - Arguments to create a Gce_ol_results.
     * @example
     * // Create one Gce_ol_results
     * const Gce_ol_results = await prisma.gce_ol_results.create({
     *   data: {
     *     // ... data to create a Gce_ol_results
     *   }
     * })
     * 
     */
    create<T extends gce_ol_resultsCreateArgs>(args: SelectSubset<T, gce_ol_resultsCreateArgs<ExtArgs>>): Prisma__gce_ol_resultsClient<$Result.GetResult<Prisma.$gce_ol_resultsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gce_ol_results.
     * @param {gce_ol_resultsCreateManyArgs} args - Arguments to create many Gce_ol_results.
     * @example
     * // Create many Gce_ol_results
     * const gce_ol_results = await prisma.gce_ol_results.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends gce_ol_resultsCreateManyArgs>(args?: SelectSubset<T, gce_ol_resultsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gce_ol_results.
     * @param {gce_ol_resultsDeleteArgs} args - Arguments to delete one Gce_ol_results.
     * @example
     * // Delete one Gce_ol_results
     * const Gce_ol_results = await prisma.gce_ol_results.delete({
     *   where: {
     *     // ... filter to delete one Gce_ol_results
     *   }
     * })
     * 
     */
    delete<T extends gce_ol_resultsDeleteArgs>(args: SelectSubset<T, gce_ol_resultsDeleteArgs<ExtArgs>>): Prisma__gce_ol_resultsClient<$Result.GetResult<Prisma.$gce_ol_resultsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gce_ol_results.
     * @param {gce_ol_resultsUpdateArgs} args - Arguments to update one Gce_ol_results.
     * @example
     * // Update one Gce_ol_results
     * const gce_ol_results = await prisma.gce_ol_results.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends gce_ol_resultsUpdateArgs>(args: SelectSubset<T, gce_ol_resultsUpdateArgs<ExtArgs>>): Prisma__gce_ol_resultsClient<$Result.GetResult<Prisma.$gce_ol_resultsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gce_ol_results.
     * @param {gce_ol_resultsDeleteManyArgs} args - Arguments to filter Gce_ol_results to delete.
     * @example
     * // Delete a few Gce_ol_results
     * const { count } = await prisma.gce_ol_results.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends gce_ol_resultsDeleteManyArgs>(args?: SelectSubset<T, gce_ol_resultsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gce_ol_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gce_ol_resultsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gce_ol_results
     * const gce_ol_results = await prisma.gce_ol_results.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends gce_ol_resultsUpdateManyArgs>(args: SelectSubset<T, gce_ol_resultsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gce_ol_results.
     * @param {gce_ol_resultsUpsertArgs} args - Arguments to update or create a Gce_ol_results.
     * @example
     * // Update or create a Gce_ol_results
     * const gce_ol_results = await prisma.gce_ol_results.upsert({
     *   create: {
     *     // ... data to create a Gce_ol_results
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gce_ol_results we want to update
     *   }
     * })
     */
    upsert<T extends gce_ol_resultsUpsertArgs>(args: SelectSubset<T, gce_ol_resultsUpsertArgs<ExtArgs>>): Prisma__gce_ol_resultsClient<$Result.GetResult<Prisma.$gce_ol_resultsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gce_ol_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gce_ol_resultsCountArgs} args - Arguments to filter Gce_ol_results to count.
     * @example
     * // Count the number of Gce_ol_results
     * const count = await prisma.gce_ol_results.count({
     *   where: {
     *     // ... the filter for the Gce_ol_results we want to count
     *   }
     * })
    **/
    count<T extends gce_ol_resultsCountArgs>(
      args?: Subset<T, gce_ol_resultsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gce_ol_resultsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gce_ol_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gce_ol_resultsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gce_ol_resultsAggregateArgs>(args: Subset<T, Gce_ol_resultsAggregateArgs>): Prisma.PrismaPromise<GetGce_ol_resultsAggregateType<T>>

    /**
     * Group by Gce_ol_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gce_ol_resultsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gce_ol_resultsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gce_ol_resultsGroupByArgs['orderBy'] }
        : { orderBy?: gce_ol_resultsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gce_ol_resultsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGce_ol_resultsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the gce_ol_results model
   */
  readonly fields: gce_ol_resultsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for gce_ol_results.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__gce_ol_resultsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends gce_ol_results$applicationArgs<ExtArgs> = {}>(args?: Subset<T, gce_ol_results$applicationArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the gce_ol_results model
   */
  interface gce_ol_resultsFieldRefs {
    readonly OL_ID: FieldRef<"gce_ol_results", 'Int'>
    readonly ApplicationID: FieldRef<"gce_ol_results", 'Int'>
    readonly Subject: FieldRef<"gce_ol_results", 'String'>
    readonly Grade: FieldRef<"gce_ol_results", 'String'>
  }
    

  // Custom InputTypes
  /**
   * gce_ol_results findUnique
   */
  export type gce_ol_resultsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_ol_results
     */
    select?: gce_ol_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_ol_results
     */
    omit?: gce_ol_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_ol_resultsInclude<ExtArgs> | null
    /**
     * Filter, which gce_ol_results to fetch.
     */
    where: gce_ol_resultsWhereUniqueInput
  }

  /**
   * gce_ol_results findUniqueOrThrow
   */
  export type gce_ol_resultsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_ol_results
     */
    select?: gce_ol_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_ol_results
     */
    omit?: gce_ol_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_ol_resultsInclude<ExtArgs> | null
    /**
     * Filter, which gce_ol_results to fetch.
     */
    where: gce_ol_resultsWhereUniqueInput
  }

  /**
   * gce_ol_results findFirst
   */
  export type gce_ol_resultsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_ol_results
     */
    select?: gce_ol_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_ol_results
     */
    omit?: gce_ol_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_ol_resultsInclude<ExtArgs> | null
    /**
     * Filter, which gce_ol_results to fetch.
     */
    where?: gce_ol_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gce_ol_results to fetch.
     */
    orderBy?: gce_ol_resultsOrderByWithRelationInput | gce_ol_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gce_ol_results.
     */
    cursor?: gce_ol_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gce_ol_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gce_ol_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gce_ol_results.
     */
    distinct?: Gce_ol_resultsScalarFieldEnum | Gce_ol_resultsScalarFieldEnum[]
  }

  /**
   * gce_ol_results findFirstOrThrow
   */
  export type gce_ol_resultsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_ol_results
     */
    select?: gce_ol_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_ol_results
     */
    omit?: gce_ol_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_ol_resultsInclude<ExtArgs> | null
    /**
     * Filter, which gce_ol_results to fetch.
     */
    where?: gce_ol_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gce_ol_results to fetch.
     */
    orderBy?: gce_ol_resultsOrderByWithRelationInput | gce_ol_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gce_ol_results.
     */
    cursor?: gce_ol_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gce_ol_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gce_ol_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gce_ol_results.
     */
    distinct?: Gce_ol_resultsScalarFieldEnum | Gce_ol_resultsScalarFieldEnum[]
  }

  /**
   * gce_ol_results findMany
   */
  export type gce_ol_resultsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_ol_results
     */
    select?: gce_ol_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_ol_results
     */
    omit?: gce_ol_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_ol_resultsInclude<ExtArgs> | null
    /**
     * Filter, which gce_ol_results to fetch.
     */
    where?: gce_ol_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gce_ol_results to fetch.
     */
    orderBy?: gce_ol_resultsOrderByWithRelationInput | gce_ol_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gce_ol_results.
     */
    cursor?: gce_ol_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gce_ol_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gce_ol_results.
     */
    skip?: number
    distinct?: Gce_ol_resultsScalarFieldEnum | Gce_ol_resultsScalarFieldEnum[]
  }

  /**
   * gce_ol_results create
   */
  export type gce_ol_resultsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_ol_results
     */
    select?: gce_ol_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_ol_results
     */
    omit?: gce_ol_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_ol_resultsInclude<ExtArgs> | null
    /**
     * The data needed to create a gce_ol_results.
     */
    data?: XOR<gce_ol_resultsCreateInput, gce_ol_resultsUncheckedCreateInput>
  }

  /**
   * gce_ol_results createMany
   */
  export type gce_ol_resultsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many gce_ol_results.
     */
    data: gce_ol_resultsCreateManyInput | gce_ol_resultsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * gce_ol_results update
   */
  export type gce_ol_resultsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_ol_results
     */
    select?: gce_ol_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_ol_results
     */
    omit?: gce_ol_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_ol_resultsInclude<ExtArgs> | null
    /**
     * The data needed to update a gce_ol_results.
     */
    data: XOR<gce_ol_resultsUpdateInput, gce_ol_resultsUncheckedUpdateInput>
    /**
     * Choose, which gce_ol_results to update.
     */
    where: gce_ol_resultsWhereUniqueInput
  }

  /**
   * gce_ol_results updateMany
   */
  export type gce_ol_resultsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update gce_ol_results.
     */
    data: XOR<gce_ol_resultsUpdateManyMutationInput, gce_ol_resultsUncheckedUpdateManyInput>
    /**
     * Filter which gce_ol_results to update
     */
    where?: gce_ol_resultsWhereInput
    /**
     * Limit how many gce_ol_results to update.
     */
    limit?: number
  }

  /**
   * gce_ol_results upsert
   */
  export type gce_ol_resultsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_ol_results
     */
    select?: gce_ol_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_ol_results
     */
    omit?: gce_ol_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_ol_resultsInclude<ExtArgs> | null
    /**
     * The filter to search for the gce_ol_results to update in case it exists.
     */
    where: gce_ol_resultsWhereUniqueInput
    /**
     * In case the gce_ol_results found by the `where` argument doesn't exist, create a new gce_ol_results with this data.
     */
    create: XOR<gce_ol_resultsCreateInput, gce_ol_resultsUncheckedCreateInput>
    /**
     * In case the gce_ol_results was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gce_ol_resultsUpdateInput, gce_ol_resultsUncheckedUpdateInput>
  }

  /**
   * gce_ol_results delete
   */
  export type gce_ol_resultsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_ol_results
     */
    select?: gce_ol_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_ol_results
     */
    omit?: gce_ol_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_ol_resultsInclude<ExtArgs> | null
    /**
     * Filter which gce_ol_results to delete.
     */
    where: gce_ol_resultsWhereUniqueInput
  }

  /**
   * gce_ol_results deleteMany
   */
  export type gce_ol_resultsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gce_ol_results to delete
     */
    where?: gce_ol_resultsWhereInput
    /**
     * Limit how many gce_ol_results to delete.
     */
    limit?: number
  }

  /**
   * gce_ol_results.application
   */
  export type gce_ol_results$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    where?: applicationWhereInput
  }

  /**
   * gce_ol_results without action
   */
  export type gce_ol_resultsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gce_ol_results
     */
    select?: gce_ol_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gce_ol_results
     */
    omit?: gce_ol_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gce_ol_resultsInclude<ExtArgs> | null
  }


  /**
   * Model jobvacancy
   */

  export type AggregateJobvacancy = {
    _count: JobvacancyCountAggregateOutputType | null
    _avg: JobvacancyAvgAggregateOutputType | null
    _sum: JobvacancySumAggregateOutputType | null
    _min: JobvacancyMinAggregateOutputType | null
    _max: JobvacancyMaxAggregateOutputType | null
  }

  export type JobvacancyAvgAggregateOutputType = {
    JobID: number | null
    PostedBy: number | null
    TemplateID: number | null
  }

  export type JobvacancySumAggregateOutputType = {
    JobID: number | null
    PostedBy: number | null
    TemplateID: number | null
  }

  export type JobvacancyMinAggregateOutputType = {
    JobID: number | null
    Title: string | null
    Description: string | null
    Type: $Enums.jobvacancy_Type | null
    Department: string | null
    Level: string | null
    PostedBy: number | null
    PostedDate: Date | null
    ExpiryDate: Date | null
    Status: $Enums.jobvacancy_Status | null
    TemplateID: number | null
  }

  export type JobvacancyMaxAggregateOutputType = {
    JobID: number | null
    Title: string | null
    Description: string | null
    Type: $Enums.jobvacancy_Type | null
    Department: string | null
    Level: string | null
    PostedBy: number | null
    PostedDate: Date | null
    ExpiryDate: Date | null
    Status: $Enums.jobvacancy_Status | null
    TemplateID: number | null
  }

  export type JobvacancyCountAggregateOutputType = {
    JobID: number
    Title: number
    Description: number
    Type: number
    Department: number
    Level: number
    PostedBy: number
    PostedDate: number
    ExpiryDate: number
    Status: number
    TemplateID: number
    _all: number
  }


  export type JobvacancyAvgAggregateInputType = {
    JobID?: true
    PostedBy?: true
    TemplateID?: true
  }

  export type JobvacancySumAggregateInputType = {
    JobID?: true
    PostedBy?: true
    TemplateID?: true
  }

  export type JobvacancyMinAggregateInputType = {
    JobID?: true
    Title?: true
    Description?: true
    Type?: true
    Department?: true
    Level?: true
    PostedBy?: true
    PostedDate?: true
    ExpiryDate?: true
    Status?: true
    TemplateID?: true
  }

  export type JobvacancyMaxAggregateInputType = {
    JobID?: true
    Title?: true
    Description?: true
    Type?: true
    Department?: true
    Level?: true
    PostedBy?: true
    PostedDate?: true
    ExpiryDate?: true
    Status?: true
    TemplateID?: true
  }

  export type JobvacancyCountAggregateInputType = {
    JobID?: true
    Title?: true
    Description?: true
    Type?: true
    Department?: true
    Level?: true
    PostedBy?: true
    PostedDate?: true
    ExpiryDate?: true
    Status?: true
    TemplateID?: true
    _all?: true
  }

  export type JobvacancyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobvacancy to aggregate.
     */
    where?: jobvacancyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobvacancies to fetch.
     */
    orderBy?: jobvacancyOrderByWithRelationInput | jobvacancyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: jobvacancyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobvacancies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobvacancies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned jobvacancies
    **/
    _count?: true | JobvacancyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobvacancyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobvacancySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobvacancyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobvacancyMaxAggregateInputType
  }

  export type GetJobvacancyAggregateType<T extends JobvacancyAggregateArgs> = {
        [P in keyof T & keyof AggregateJobvacancy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobvacancy[P]>
      : GetScalarType<T[P], AggregateJobvacancy[P]>
  }




  export type jobvacancyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobvacancyWhereInput
    orderBy?: jobvacancyOrderByWithAggregationInput | jobvacancyOrderByWithAggregationInput[]
    by: JobvacancyScalarFieldEnum[] | JobvacancyScalarFieldEnum
    having?: jobvacancyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobvacancyCountAggregateInputType | true
    _avg?: JobvacancyAvgAggregateInputType
    _sum?: JobvacancySumAggregateInputType
    _min?: JobvacancyMinAggregateInputType
    _max?: JobvacancyMaxAggregateInputType
  }

  export type JobvacancyGroupByOutputType = {
    JobID: number
    Title: string | null
    Description: string | null
    Type: $Enums.jobvacancy_Type | null
    Department: string | null
    Level: string | null
    PostedBy: number | null
    PostedDate: Date | null
    ExpiryDate: Date | null
    Status: $Enums.jobvacancy_Status | null
    TemplateID: number | null
    _count: JobvacancyCountAggregateOutputType | null
    _avg: JobvacancyAvgAggregateOutputType | null
    _sum: JobvacancySumAggregateOutputType | null
    _min: JobvacancyMinAggregateOutputType | null
    _max: JobvacancyMaxAggregateOutputType | null
  }

  type GetJobvacancyGroupByPayload<T extends jobvacancyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobvacancyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobvacancyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobvacancyGroupByOutputType[P]>
            : GetScalarType<T[P], JobvacancyGroupByOutputType[P]>
        }
      >
    >


  export type jobvacancySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    JobID?: boolean
    Title?: boolean
    Description?: boolean
    Type?: boolean
    Department?: boolean
    Level?: boolean
    PostedBy?: boolean
    PostedDate?: boolean
    ExpiryDate?: boolean
    Status?: boolean
    TemplateID?: boolean
    application?: boolean | jobvacancy$applicationArgs<ExtArgs>
    admin?: boolean | jobvacancy$adminArgs<ExtArgs>
    applicationtemplate?: boolean | jobvacancy$applicationtemplateArgs<ExtArgs>
    _count?: boolean | JobvacancyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobvacancy"]>



  export type jobvacancySelectScalar = {
    JobID?: boolean
    Title?: boolean
    Description?: boolean
    Type?: boolean
    Department?: boolean
    Level?: boolean
    PostedBy?: boolean
    PostedDate?: boolean
    ExpiryDate?: boolean
    Status?: boolean
    TemplateID?: boolean
  }

  export type jobvacancyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"JobID" | "Title" | "Description" | "Type" | "Department" | "Level" | "PostedBy" | "PostedDate" | "ExpiryDate" | "Status" | "TemplateID", ExtArgs["result"]["jobvacancy"]>
  export type jobvacancyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | jobvacancy$applicationArgs<ExtArgs>
    admin?: boolean | jobvacancy$adminArgs<ExtArgs>
    applicationtemplate?: boolean | jobvacancy$applicationtemplateArgs<ExtArgs>
    _count?: boolean | JobvacancyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $jobvacancyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "jobvacancy"
    objects: {
      application: Prisma.$applicationPayload<ExtArgs>[]
      admin: Prisma.$adminPayload<ExtArgs> | null
      applicationtemplate: Prisma.$applicationtemplatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      JobID: number
      Title: string | null
      Description: string | null
      Type: $Enums.jobvacancy_Type | null
      Department: string | null
      Level: string | null
      PostedBy: number | null
      PostedDate: Date | null
      ExpiryDate: Date | null
      Status: $Enums.jobvacancy_Status | null
      TemplateID: number | null
    }, ExtArgs["result"]["jobvacancy"]>
    composites: {}
  }

  type jobvacancyGetPayload<S extends boolean | null | undefined | jobvacancyDefaultArgs> = $Result.GetResult<Prisma.$jobvacancyPayload, S>

  type jobvacancyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<jobvacancyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobvacancyCountAggregateInputType | true
    }

  export interface jobvacancyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['jobvacancy'], meta: { name: 'jobvacancy' } }
    /**
     * Find zero or one Jobvacancy that matches the filter.
     * @param {jobvacancyFindUniqueArgs} args - Arguments to find a Jobvacancy
     * @example
     * // Get one Jobvacancy
     * const jobvacancy = await prisma.jobvacancy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends jobvacancyFindUniqueArgs>(args: SelectSubset<T, jobvacancyFindUniqueArgs<ExtArgs>>): Prisma__jobvacancyClient<$Result.GetResult<Prisma.$jobvacancyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Jobvacancy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {jobvacancyFindUniqueOrThrowArgs} args - Arguments to find a Jobvacancy
     * @example
     * // Get one Jobvacancy
     * const jobvacancy = await prisma.jobvacancy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends jobvacancyFindUniqueOrThrowArgs>(args: SelectSubset<T, jobvacancyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__jobvacancyClient<$Result.GetResult<Prisma.$jobvacancyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobvacancy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobvacancyFindFirstArgs} args - Arguments to find a Jobvacancy
     * @example
     * // Get one Jobvacancy
     * const jobvacancy = await prisma.jobvacancy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends jobvacancyFindFirstArgs>(args?: SelectSubset<T, jobvacancyFindFirstArgs<ExtArgs>>): Prisma__jobvacancyClient<$Result.GetResult<Prisma.$jobvacancyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobvacancy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobvacancyFindFirstOrThrowArgs} args - Arguments to find a Jobvacancy
     * @example
     * // Get one Jobvacancy
     * const jobvacancy = await prisma.jobvacancy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends jobvacancyFindFirstOrThrowArgs>(args?: SelectSubset<T, jobvacancyFindFirstOrThrowArgs<ExtArgs>>): Prisma__jobvacancyClient<$Result.GetResult<Prisma.$jobvacancyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobvacancies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobvacancyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobvacancies
     * const jobvacancies = await prisma.jobvacancy.findMany()
     * 
     * // Get first 10 Jobvacancies
     * const jobvacancies = await prisma.jobvacancy.findMany({ take: 10 })
     * 
     * // Only select the `JobID`
     * const jobvacancyWithJobIDOnly = await prisma.jobvacancy.findMany({ select: { JobID: true } })
     * 
     */
    findMany<T extends jobvacancyFindManyArgs>(args?: SelectSubset<T, jobvacancyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobvacancyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Jobvacancy.
     * @param {jobvacancyCreateArgs} args - Arguments to create a Jobvacancy.
     * @example
     * // Create one Jobvacancy
     * const Jobvacancy = await prisma.jobvacancy.create({
     *   data: {
     *     // ... data to create a Jobvacancy
     *   }
     * })
     * 
     */
    create<T extends jobvacancyCreateArgs>(args: SelectSubset<T, jobvacancyCreateArgs<ExtArgs>>): Prisma__jobvacancyClient<$Result.GetResult<Prisma.$jobvacancyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobvacancies.
     * @param {jobvacancyCreateManyArgs} args - Arguments to create many Jobvacancies.
     * @example
     * // Create many Jobvacancies
     * const jobvacancy = await prisma.jobvacancy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends jobvacancyCreateManyArgs>(args?: SelectSubset<T, jobvacancyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Jobvacancy.
     * @param {jobvacancyDeleteArgs} args - Arguments to delete one Jobvacancy.
     * @example
     * // Delete one Jobvacancy
     * const Jobvacancy = await prisma.jobvacancy.delete({
     *   where: {
     *     // ... filter to delete one Jobvacancy
     *   }
     * })
     * 
     */
    delete<T extends jobvacancyDeleteArgs>(args: SelectSubset<T, jobvacancyDeleteArgs<ExtArgs>>): Prisma__jobvacancyClient<$Result.GetResult<Prisma.$jobvacancyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Jobvacancy.
     * @param {jobvacancyUpdateArgs} args - Arguments to update one Jobvacancy.
     * @example
     * // Update one Jobvacancy
     * const jobvacancy = await prisma.jobvacancy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends jobvacancyUpdateArgs>(args: SelectSubset<T, jobvacancyUpdateArgs<ExtArgs>>): Prisma__jobvacancyClient<$Result.GetResult<Prisma.$jobvacancyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobvacancies.
     * @param {jobvacancyDeleteManyArgs} args - Arguments to filter Jobvacancies to delete.
     * @example
     * // Delete a few Jobvacancies
     * const { count } = await prisma.jobvacancy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends jobvacancyDeleteManyArgs>(args?: SelectSubset<T, jobvacancyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobvacancies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobvacancyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobvacancies
     * const jobvacancy = await prisma.jobvacancy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends jobvacancyUpdateManyArgs>(args: SelectSubset<T, jobvacancyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Jobvacancy.
     * @param {jobvacancyUpsertArgs} args - Arguments to update or create a Jobvacancy.
     * @example
     * // Update or create a Jobvacancy
     * const jobvacancy = await prisma.jobvacancy.upsert({
     *   create: {
     *     // ... data to create a Jobvacancy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jobvacancy we want to update
     *   }
     * })
     */
    upsert<T extends jobvacancyUpsertArgs>(args: SelectSubset<T, jobvacancyUpsertArgs<ExtArgs>>): Prisma__jobvacancyClient<$Result.GetResult<Prisma.$jobvacancyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobvacancies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobvacancyCountArgs} args - Arguments to filter Jobvacancies to count.
     * @example
     * // Count the number of Jobvacancies
     * const count = await prisma.jobvacancy.count({
     *   where: {
     *     // ... the filter for the Jobvacancies we want to count
     *   }
     * })
    **/
    count<T extends jobvacancyCountArgs>(
      args?: Subset<T, jobvacancyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobvacancyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jobvacancy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobvacancyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobvacancyAggregateArgs>(args: Subset<T, JobvacancyAggregateArgs>): Prisma.PrismaPromise<GetJobvacancyAggregateType<T>>

    /**
     * Group by Jobvacancy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobvacancyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends jobvacancyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: jobvacancyGroupByArgs['orderBy'] }
        : { orderBy?: jobvacancyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, jobvacancyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobvacancyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the jobvacancy model
   */
  readonly fields: jobvacancyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for jobvacancy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__jobvacancyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends jobvacancy$applicationArgs<ExtArgs> = {}>(args?: Subset<T, jobvacancy$applicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admin<T extends jobvacancy$adminArgs<ExtArgs> = {}>(args?: Subset<T, jobvacancy$adminArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    applicationtemplate<T extends jobvacancy$applicationtemplateArgs<ExtArgs> = {}>(args?: Subset<T, jobvacancy$applicationtemplateArgs<ExtArgs>>): Prisma__applicationtemplateClient<$Result.GetResult<Prisma.$applicationtemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the jobvacancy model
   */
  interface jobvacancyFieldRefs {
    readonly JobID: FieldRef<"jobvacancy", 'Int'>
    readonly Title: FieldRef<"jobvacancy", 'String'>
    readonly Description: FieldRef<"jobvacancy", 'String'>
    readonly Type: FieldRef<"jobvacancy", 'jobvacancy_Type'>
    readonly Department: FieldRef<"jobvacancy", 'String'>
    readonly Level: FieldRef<"jobvacancy", 'String'>
    readonly PostedBy: FieldRef<"jobvacancy", 'Int'>
    readonly PostedDate: FieldRef<"jobvacancy", 'DateTime'>
    readonly ExpiryDate: FieldRef<"jobvacancy", 'DateTime'>
    readonly Status: FieldRef<"jobvacancy", 'jobvacancy_Status'>
    readonly TemplateID: FieldRef<"jobvacancy", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * jobvacancy findUnique
   */
  export type jobvacancyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobvacancy
     */
    select?: jobvacancySelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobvacancy
     */
    omit?: jobvacancyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobvacancyInclude<ExtArgs> | null
    /**
     * Filter, which jobvacancy to fetch.
     */
    where: jobvacancyWhereUniqueInput
  }

  /**
   * jobvacancy findUniqueOrThrow
   */
  export type jobvacancyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobvacancy
     */
    select?: jobvacancySelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobvacancy
     */
    omit?: jobvacancyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobvacancyInclude<ExtArgs> | null
    /**
     * Filter, which jobvacancy to fetch.
     */
    where: jobvacancyWhereUniqueInput
  }

  /**
   * jobvacancy findFirst
   */
  export type jobvacancyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobvacancy
     */
    select?: jobvacancySelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobvacancy
     */
    omit?: jobvacancyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobvacancyInclude<ExtArgs> | null
    /**
     * Filter, which jobvacancy to fetch.
     */
    where?: jobvacancyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobvacancies to fetch.
     */
    orderBy?: jobvacancyOrderByWithRelationInput | jobvacancyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobvacancies.
     */
    cursor?: jobvacancyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobvacancies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobvacancies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobvacancies.
     */
    distinct?: JobvacancyScalarFieldEnum | JobvacancyScalarFieldEnum[]
  }

  /**
   * jobvacancy findFirstOrThrow
   */
  export type jobvacancyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobvacancy
     */
    select?: jobvacancySelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobvacancy
     */
    omit?: jobvacancyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobvacancyInclude<ExtArgs> | null
    /**
     * Filter, which jobvacancy to fetch.
     */
    where?: jobvacancyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobvacancies to fetch.
     */
    orderBy?: jobvacancyOrderByWithRelationInput | jobvacancyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobvacancies.
     */
    cursor?: jobvacancyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobvacancies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobvacancies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobvacancies.
     */
    distinct?: JobvacancyScalarFieldEnum | JobvacancyScalarFieldEnum[]
  }

  /**
   * jobvacancy findMany
   */
  export type jobvacancyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobvacancy
     */
    select?: jobvacancySelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobvacancy
     */
    omit?: jobvacancyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobvacancyInclude<ExtArgs> | null
    /**
     * Filter, which jobvacancies to fetch.
     */
    where?: jobvacancyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobvacancies to fetch.
     */
    orderBy?: jobvacancyOrderByWithRelationInput | jobvacancyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing jobvacancies.
     */
    cursor?: jobvacancyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobvacancies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobvacancies.
     */
    skip?: number
    distinct?: JobvacancyScalarFieldEnum | JobvacancyScalarFieldEnum[]
  }

  /**
   * jobvacancy create
   */
  export type jobvacancyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobvacancy
     */
    select?: jobvacancySelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobvacancy
     */
    omit?: jobvacancyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobvacancyInclude<ExtArgs> | null
    /**
     * The data needed to create a jobvacancy.
     */
    data?: XOR<jobvacancyCreateInput, jobvacancyUncheckedCreateInput>
  }

  /**
   * jobvacancy createMany
   */
  export type jobvacancyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many jobvacancies.
     */
    data: jobvacancyCreateManyInput | jobvacancyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * jobvacancy update
   */
  export type jobvacancyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobvacancy
     */
    select?: jobvacancySelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobvacancy
     */
    omit?: jobvacancyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobvacancyInclude<ExtArgs> | null
    /**
     * The data needed to update a jobvacancy.
     */
    data: XOR<jobvacancyUpdateInput, jobvacancyUncheckedUpdateInput>
    /**
     * Choose, which jobvacancy to update.
     */
    where: jobvacancyWhereUniqueInput
  }

  /**
   * jobvacancy updateMany
   */
  export type jobvacancyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update jobvacancies.
     */
    data: XOR<jobvacancyUpdateManyMutationInput, jobvacancyUncheckedUpdateManyInput>
    /**
     * Filter which jobvacancies to update
     */
    where?: jobvacancyWhereInput
    /**
     * Limit how many jobvacancies to update.
     */
    limit?: number
  }

  /**
   * jobvacancy upsert
   */
  export type jobvacancyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobvacancy
     */
    select?: jobvacancySelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobvacancy
     */
    omit?: jobvacancyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobvacancyInclude<ExtArgs> | null
    /**
     * The filter to search for the jobvacancy to update in case it exists.
     */
    where: jobvacancyWhereUniqueInput
    /**
     * In case the jobvacancy found by the `where` argument doesn't exist, create a new jobvacancy with this data.
     */
    create: XOR<jobvacancyCreateInput, jobvacancyUncheckedCreateInput>
    /**
     * In case the jobvacancy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<jobvacancyUpdateInput, jobvacancyUncheckedUpdateInput>
  }

  /**
   * jobvacancy delete
   */
  export type jobvacancyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobvacancy
     */
    select?: jobvacancySelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobvacancy
     */
    omit?: jobvacancyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobvacancyInclude<ExtArgs> | null
    /**
     * Filter which jobvacancy to delete.
     */
    where: jobvacancyWhereUniqueInput
  }

  /**
   * jobvacancy deleteMany
   */
  export type jobvacancyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobvacancies to delete
     */
    where?: jobvacancyWhereInput
    /**
     * Limit how many jobvacancies to delete.
     */
    limit?: number
  }

  /**
   * jobvacancy.application
   */
  export type jobvacancy$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    where?: applicationWhereInput
    orderBy?: applicationOrderByWithRelationInput | applicationOrderByWithRelationInput[]
    cursor?: applicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * jobvacancy.admin
   */
  export type jobvacancy$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    where?: adminWhereInput
  }

  /**
   * jobvacancy.applicationtemplate
   */
  export type jobvacancy$applicationtemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtemplate
     */
    select?: applicationtemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicationtemplate
     */
    omit?: applicationtemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationtemplateInclude<ExtArgs> | null
    where?: applicationtemplateWhereInput
  }

  /**
   * jobvacancy without action
   */
  export type jobvacancyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobvacancy
     */
    select?: jobvacancySelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobvacancy
     */
    omit?: jobvacancyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobvacancyInclude<ExtArgs> | null
  }


  /**
   * Model languageproficiencies
   */

  export type AggregateLanguageproficiencies = {
    _count: LanguageproficienciesCountAggregateOutputType | null
    _avg: LanguageproficienciesAvgAggregateOutputType | null
    _sum: LanguageproficienciesSumAggregateOutputType | null
    _min: LanguageproficienciesMinAggregateOutputType | null
    _max: LanguageproficienciesMaxAggregateOutputType | null
  }

  export type LanguageproficienciesAvgAggregateOutputType = {
    LangProfID: number | null
    ApplicationID: number | null
  }

  export type LanguageproficienciesSumAggregateOutputType = {
    LangProfID: number | null
    ApplicationID: number | null
  }

  export type LanguageproficienciesMinAggregateOutputType = {
    LangProfID: number | null
    ApplicationID: number | null
    Language: string | null
    CanSpeak: $Enums.languageproficiencies_CanSpeak | null
    CanRead: $Enums.languageproficiencies_CanRead | null
    CanWrite: $Enums.languageproficiencies_CanWrite | null
    CanTeach: $Enums.languageproficiencies_CanTeach | null
  }

  export type LanguageproficienciesMaxAggregateOutputType = {
    LangProfID: number | null
    ApplicationID: number | null
    Language: string | null
    CanSpeak: $Enums.languageproficiencies_CanSpeak | null
    CanRead: $Enums.languageproficiencies_CanRead | null
    CanWrite: $Enums.languageproficiencies_CanWrite | null
    CanTeach: $Enums.languageproficiencies_CanTeach | null
  }

  export type LanguageproficienciesCountAggregateOutputType = {
    LangProfID: number
    ApplicationID: number
    Language: number
    CanSpeak: number
    CanRead: number
    CanWrite: number
    CanTeach: number
    _all: number
  }


  export type LanguageproficienciesAvgAggregateInputType = {
    LangProfID?: true
    ApplicationID?: true
  }

  export type LanguageproficienciesSumAggregateInputType = {
    LangProfID?: true
    ApplicationID?: true
  }

  export type LanguageproficienciesMinAggregateInputType = {
    LangProfID?: true
    ApplicationID?: true
    Language?: true
    CanSpeak?: true
    CanRead?: true
    CanWrite?: true
    CanTeach?: true
  }

  export type LanguageproficienciesMaxAggregateInputType = {
    LangProfID?: true
    ApplicationID?: true
    Language?: true
    CanSpeak?: true
    CanRead?: true
    CanWrite?: true
    CanTeach?: true
  }

  export type LanguageproficienciesCountAggregateInputType = {
    LangProfID?: true
    ApplicationID?: true
    Language?: true
    CanSpeak?: true
    CanRead?: true
    CanWrite?: true
    CanTeach?: true
    _all?: true
  }

  export type LanguageproficienciesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which languageproficiencies to aggregate.
     */
    where?: languageproficienciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of languageproficiencies to fetch.
     */
    orderBy?: languageproficienciesOrderByWithRelationInput | languageproficienciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: languageproficienciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` languageproficiencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` languageproficiencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned languageproficiencies
    **/
    _count?: true | LanguageproficienciesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LanguageproficienciesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LanguageproficienciesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageproficienciesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageproficienciesMaxAggregateInputType
  }

  export type GetLanguageproficienciesAggregateType<T extends LanguageproficienciesAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguageproficiencies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguageproficiencies[P]>
      : GetScalarType<T[P], AggregateLanguageproficiencies[P]>
  }




  export type languageproficienciesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: languageproficienciesWhereInput
    orderBy?: languageproficienciesOrderByWithAggregationInput | languageproficienciesOrderByWithAggregationInput[]
    by: LanguageproficienciesScalarFieldEnum[] | LanguageproficienciesScalarFieldEnum
    having?: languageproficienciesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageproficienciesCountAggregateInputType | true
    _avg?: LanguageproficienciesAvgAggregateInputType
    _sum?: LanguageproficienciesSumAggregateInputType
    _min?: LanguageproficienciesMinAggregateInputType
    _max?: LanguageproficienciesMaxAggregateInputType
  }

  export type LanguageproficienciesGroupByOutputType = {
    LangProfID: number
    ApplicationID: number | null
    Language: string | null
    CanSpeak: $Enums.languageproficiencies_CanSpeak | null
    CanRead: $Enums.languageproficiencies_CanRead | null
    CanWrite: $Enums.languageproficiencies_CanWrite | null
    CanTeach: $Enums.languageproficiencies_CanTeach | null
    _count: LanguageproficienciesCountAggregateOutputType | null
    _avg: LanguageproficienciesAvgAggregateOutputType | null
    _sum: LanguageproficienciesSumAggregateOutputType | null
    _min: LanguageproficienciesMinAggregateOutputType | null
    _max: LanguageproficienciesMaxAggregateOutputType | null
  }

  type GetLanguageproficienciesGroupByPayload<T extends languageproficienciesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageproficienciesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageproficienciesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageproficienciesGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageproficienciesGroupByOutputType[P]>
        }
      >
    >


  export type languageproficienciesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    LangProfID?: boolean
    ApplicationID?: boolean
    Language?: boolean
    CanSpeak?: boolean
    CanRead?: boolean
    CanWrite?: boolean
    CanTeach?: boolean
    application?: boolean | languageproficiencies$applicationArgs<ExtArgs>
  }, ExtArgs["result"]["languageproficiencies"]>



  export type languageproficienciesSelectScalar = {
    LangProfID?: boolean
    ApplicationID?: boolean
    Language?: boolean
    CanSpeak?: boolean
    CanRead?: boolean
    CanWrite?: boolean
    CanTeach?: boolean
  }

  export type languageproficienciesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"LangProfID" | "ApplicationID" | "Language" | "CanSpeak" | "CanRead" | "CanWrite" | "CanTeach", ExtArgs["result"]["languageproficiencies"]>
  export type languageproficienciesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | languageproficiencies$applicationArgs<ExtArgs>
  }

  export type $languageproficienciesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "languageproficiencies"
    objects: {
      application: Prisma.$applicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      LangProfID: number
      ApplicationID: number | null
      Language: string | null
      CanSpeak: $Enums.languageproficiencies_CanSpeak | null
      CanRead: $Enums.languageproficiencies_CanRead | null
      CanWrite: $Enums.languageproficiencies_CanWrite | null
      CanTeach: $Enums.languageproficiencies_CanTeach | null
    }, ExtArgs["result"]["languageproficiencies"]>
    composites: {}
  }

  type languageproficienciesGetPayload<S extends boolean | null | undefined | languageproficienciesDefaultArgs> = $Result.GetResult<Prisma.$languageproficienciesPayload, S>

  type languageproficienciesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<languageproficienciesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LanguageproficienciesCountAggregateInputType | true
    }

  export interface languageproficienciesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['languageproficiencies'], meta: { name: 'languageproficiencies' } }
    /**
     * Find zero or one Languageproficiencies that matches the filter.
     * @param {languageproficienciesFindUniqueArgs} args - Arguments to find a Languageproficiencies
     * @example
     * // Get one Languageproficiencies
     * const languageproficiencies = await prisma.languageproficiencies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends languageproficienciesFindUniqueArgs>(args: SelectSubset<T, languageproficienciesFindUniqueArgs<ExtArgs>>): Prisma__languageproficienciesClient<$Result.GetResult<Prisma.$languageproficienciesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Languageproficiencies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {languageproficienciesFindUniqueOrThrowArgs} args - Arguments to find a Languageproficiencies
     * @example
     * // Get one Languageproficiencies
     * const languageproficiencies = await prisma.languageproficiencies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends languageproficienciesFindUniqueOrThrowArgs>(args: SelectSubset<T, languageproficienciesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__languageproficienciesClient<$Result.GetResult<Prisma.$languageproficienciesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Languageproficiencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languageproficienciesFindFirstArgs} args - Arguments to find a Languageproficiencies
     * @example
     * // Get one Languageproficiencies
     * const languageproficiencies = await prisma.languageproficiencies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends languageproficienciesFindFirstArgs>(args?: SelectSubset<T, languageproficienciesFindFirstArgs<ExtArgs>>): Prisma__languageproficienciesClient<$Result.GetResult<Prisma.$languageproficienciesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Languageproficiencies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languageproficienciesFindFirstOrThrowArgs} args - Arguments to find a Languageproficiencies
     * @example
     * // Get one Languageproficiencies
     * const languageproficiencies = await prisma.languageproficiencies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends languageproficienciesFindFirstOrThrowArgs>(args?: SelectSubset<T, languageproficienciesFindFirstOrThrowArgs<ExtArgs>>): Prisma__languageproficienciesClient<$Result.GetResult<Prisma.$languageproficienciesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Languageproficiencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languageproficienciesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languageproficiencies
     * const languageproficiencies = await prisma.languageproficiencies.findMany()
     * 
     * // Get first 10 Languageproficiencies
     * const languageproficiencies = await prisma.languageproficiencies.findMany({ take: 10 })
     * 
     * // Only select the `LangProfID`
     * const languageproficienciesWithLangProfIDOnly = await prisma.languageproficiencies.findMany({ select: { LangProfID: true } })
     * 
     */
    findMany<T extends languageproficienciesFindManyArgs>(args?: SelectSubset<T, languageproficienciesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$languageproficienciesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Languageproficiencies.
     * @param {languageproficienciesCreateArgs} args - Arguments to create a Languageproficiencies.
     * @example
     * // Create one Languageproficiencies
     * const Languageproficiencies = await prisma.languageproficiencies.create({
     *   data: {
     *     // ... data to create a Languageproficiencies
     *   }
     * })
     * 
     */
    create<T extends languageproficienciesCreateArgs>(args: SelectSubset<T, languageproficienciesCreateArgs<ExtArgs>>): Prisma__languageproficienciesClient<$Result.GetResult<Prisma.$languageproficienciesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Languageproficiencies.
     * @param {languageproficienciesCreateManyArgs} args - Arguments to create many Languageproficiencies.
     * @example
     * // Create many Languageproficiencies
     * const languageproficiencies = await prisma.languageproficiencies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends languageproficienciesCreateManyArgs>(args?: SelectSubset<T, languageproficienciesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Languageproficiencies.
     * @param {languageproficienciesDeleteArgs} args - Arguments to delete one Languageproficiencies.
     * @example
     * // Delete one Languageproficiencies
     * const Languageproficiencies = await prisma.languageproficiencies.delete({
     *   where: {
     *     // ... filter to delete one Languageproficiencies
     *   }
     * })
     * 
     */
    delete<T extends languageproficienciesDeleteArgs>(args: SelectSubset<T, languageproficienciesDeleteArgs<ExtArgs>>): Prisma__languageproficienciesClient<$Result.GetResult<Prisma.$languageproficienciesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Languageproficiencies.
     * @param {languageproficienciesUpdateArgs} args - Arguments to update one Languageproficiencies.
     * @example
     * // Update one Languageproficiencies
     * const languageproficiencies = await prisma.languageproficiencies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends languageproficienciesUpdateArgs>(args: SelectSubset<T, languageproficienciesUpdateArgs<ExtArgs>>): Prisma__languageproficienciesClient<$Result.GetResult<Prisma.$languageproficienciesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Languageproficiencies.
     * @param {languageproficienciesDeleteManyArgs} args - Arguments to filter Languageproficiencies to delete.
     * @example
     * // Delete a few Languageproficiencies
     * const { count } = await prisma.languageproficiencies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends languageproficienciesDeleteManyArgs>(args?: SelectSubset<T, languageproficienciesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languageproficiencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languageproficienciesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languageproficiencies
     * const languageproficiencies = await prisma.languageproficiencies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends languageproficienciesUpdateManyArgs>(args: SelectSubset<T, languageproficienciesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Languageproficiencies.
     * @param {languageproficienciesUpsertArgs} args - Arguments to update or create a Languageproficiencies.
     * @example
     * // Update or create a Languageproficiencies
     * const languageproficiencies = await prisma.languageproficiencies.upsert({
     *   create: {
     *     // ... data to create a Languageproficiencies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Languageproficiencies we want to update
     *   }
     * })
     */
    upsert<T extends languageproficienciesUpsertArgs>(args: SelectSubset<T, languageproficienciesUpsertArgs<ExtArgs>>): Prisma__languageproficienciesClient<$Result.GetResult<Prisma.$languageproficienciesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Languageproficiencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languageproficienciesCountArgs} args - Arguments to filter Languageproficiencies to count.
     * @example
     * // Count the number of Languageproficiencies
     * const count = await prisma.languageproficiencies.count({
     *   where: {
     *     // ... the filter for the Languageproficiencies we want to count
     *   }
     * })
    **/
    count<T extends languageproficienciesCountArgs>(
      args?: Subset<T, languageproficienciesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageproficienciesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Languageproficiencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageproficienciesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageproficienciesAggregateArgs>(args: Subset<T, LanguageproficienciesAggregateArgs>): Prisma.PrismaPromise<GetLanguageproficienciesAggregateType<T>>

    /**
     * Group by Languageproficiencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languageproficienciesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends languageproficienciesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: languageproficienciesGroupByArgs['orderBy'] }
        : { orderBy?: languageproficienciesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, languageproficienciesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageproficienciesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the languageproficiencies model
   */
  readonly fields: languageproficienciesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for languageproficiencies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__languageproficienciesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends languageproficiencies$applicationArgs<ExtArgs> = {}>(args?: Subset<T, languageproficiencies$applicationArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the languageproficiencies model
   */
  interface languageproficienciesFieldRefs {
    readonly LangProfID: FieldRef<"languageproficiencies", 'Int'>
    readonly ApplicationID: FieldRef<"languageproficiencies", 'Int'>
    readonly Language: FieldRef<"languageproficiencies", 'String'>
    readonly CanSpeak: FieldRef<"languageproficiencies", 'languageproficiencies_CanSpeak'>
    readonly CanRead: FieldRef<"languageproficiencies", 'languageproficiencies_CanRead'>
    readonly CanWrite: FieldRef<"languageproficiencies", 'languageproficiencies_CanWrite'>
    readonly CanTeach: FieldRef<"languageproficiencies", 'languageproficiencies_CanTeach'>
  }
    

  // Custom InputTypes
  /**
   * languageproficiencies findUnique
   */
  export type languageproficienciesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languageproficiencies
     */
    select?: languageproficienciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languageproficiencies
     */
    omit?: languageproficienciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageproficienciesInclude<ExtArgs> | null
    /**
     * Filter, which languageproficiencies to fetch.
     */
    where: languageproficienciesWhereUniqueInput
  }

  /**
   * languageproficiencies findUniqueOrThrow
   */
  export type languageproficienciesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languageproficiencies
     */
    select?: languageproficienciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languageproficiencies
     */
    omit?: languageproficienciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageproficienciesInclude<ExtArgs> | null
    /**
     * Filter, which languageproficiencies to fetch.
     */
    where: languageproficienciesWhereUniqueInput
  }

  /**
   * languageproficiencies findFirst
   */
  export type languageproficienciesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languageproficiencies
     */
    select?: languageproficienciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languageproficiencies
     */
    omit?: languageproficienciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageproficienciesInclude<ExtArgs> | null
    /**
     * Filter, which languageproficiencies to fetch.
     */
    where?: languageproficienciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of languageproficiencies to fetch.
     */
    orderBy?: languageproficienciesOrderByWithRelationInput | languageproficienciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for languageproficiencies.
     */
    cursor?: languageproficienciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` languageproficiencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` languageproficiencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of languageproficiencies.
     */
    distinct?: LanguageproficienciesScalarFieldEnum | LanguageproficienciesScalarFieldEnum[]
  }

  /**
   * languageproficiencies findFirstOrThrow
   */
  export type languageproficienciesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languageproficiencies
     */
    select?: languageproficienciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languageproficiencies
     */
    omit?: languageproficienciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageproficienciesInclude<ExtArgs> | null
    /**
     * Filter, which languageproficiencies to fetch.
     */
    where?: languageproficienciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of languageproficiencies to fetch.
     */
    orderBy?: languageproficienciesOrderByWithRelationInput | languageproficienciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for languageproficiencies.
     */
    cursor?: languageproficienciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` languageproficiencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` languageproficiencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of languageproficiencies.
     */
    distinct?: LanguageproficienciesScalarFieldEnum | LanguageproficienciesScalarFieldEnum[]
  }

  /**
   * languageproficiencies findMany
   */
  export type languageproficienciesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languageproficiencies
     */
    select?: languageproficienciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languageproficiencies
     */
    omit?: languageproficienciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageproficienciesInclude<ExtArgs> | null
    /**
     * Filter, which languageproficiencies to fetch.
     */
    where?: languageproficienciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of languageproficiencies to fetch.
     */
    orderBy?: languageproficienciesOrderByWithRelationInput | languageproficienciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing languageproficiencies.
     */
    cursor?: languageproficienciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` languageproficiencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` languageproficiencies.
     */
    skip?: number
    distinct?: LanguageproficienciesScalarFieldEnum | LanguageproficienciesScalarFieldEnum[]
  }

  /**
   * languageproficiencies create
   */
  export type languageproficienciesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languageproficiencies
     */
    select?: languageproficienciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languageproficiencies
     */
    omit?: languageproficienciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageproficienciesInclude<ExtArgs> | null
    /**
     * The data needed to create a languageproficiencies.
     */
    data?: XOR<languageproficienciesCreateInput, languageproficienciesUncheckedCreateInput>
  }

  /**
   * languageproficiencies createMany
   */
  export type languageproficienciesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many languageproficiencies.
     */
    data: languageproficienciesCreateManyInput | languageproficienciesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * languageproficiencies update
   */
  export type languageproficienciesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languageproficiencies
     */
    select?: languageproficienciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languageproficiencies
     */
    omit?: languageproficienciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageproficienciesInclude<ExtArgs> | null
    /**
     * The data needed to update a languageproficiencies.
     */
    data: XOR<languageproficienciesUpdateInput, languageproficienciesUncheckedUpdateInput>
    /**
     * Choose, which languageproficiencies to update.
     */
    where: languageproficienciesWhereUniqueInput
  }

  /**
   * languageproficiencies updateMany
   */
  export type languageproficienciesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update languageproficiencies.
     */
    data: XOR<languageproficienciesUpdateManyMutationInput, languageproficienciesUncheckedUpdateManyInput>
    /**
     * Filter which languageproficiencies to update
     */
    where?: languageproficienciesWhereInput
    /**
     * Limit how many languageproficiencies to update.
     */
    limit?: number
  }

  /**
   * languageproficiencies upsert
   */
  export type languageproficienciesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languageproficiencies
     */
    select?: languageproficienciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languageproficiencies
     */
    omit?: languageproficienciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageproficienciesInclude<ExtArgs> | null
    /**
     * The filter to search for the languageproficiencies to update in case it exists.
     */
    where: languageproficienciesWhereUniqueInput
    /**
     * In case the languageproficiencies found by the `where` argument doesn't exist, create a new languageproficiencies with this data.
     */
    create: XOR<languageproficienciesCreateInput, languageproficienciesUncheckedCreateInput>
    /**
     * In case the languageproficiencies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<languageproficienciesUpdateInput, languageproficienciesUncheckedUpdateInput>
  }

  /**
   * languageproficiencies delete
   */
  export type languageproficienciesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languageproficiencies
     */
    select?: languageproficienciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languageproficiencies
     */
    omit?: languageproficienciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageproficienciesInclude<ExtArgs> | null
    /**
     * Filter which languageproficiencies to delete.
     */
    where: languageproficienciesWhereUniqueInput
  }

  /**
   * languageproficiencies deleteMany
   */
  export type languageproficienciesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which languageproficiencies to delete
     */
    where?: languageproficienciesWhereInput
    /**
     * Limit how many languageproficiencies to delete.
     */
    limit?: number
  }

  /**
   * languageproficiencies.application
   */
  export type languageproficiencies$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    where?: applicationWhereInput
  }

  /**
   * languageproficiencies without action
   */
  export type languageproficienciesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the languageproficiencies
     */
    select?: languageproficienciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the languageproficiencies
     */
    omit?: languageproficienciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageproficienciesInclude<ExtArgs> | null
  }


  /**
   * Model professionalqualifications
   */

  export type AggregateProfessionalqualifications = {
    _count: ProfessionalqualificationsCountAggregateOutputType | null
    _avg: ProfessionalqualificationsAvgAggregateOutputType | null
    _sum: ProfessionalqualificationsSumAggregateOutputType | null
    _min: ProfessionalqualificationsMinAggregateOutputType | null
    _max: ProfessionalqualificationsMaxAggregateOutputType | null
  }

  export type ProfessionalqualificationsAvgAggregateOutputType = {
    PQ_ID: number | null
    ApplicationID: number | null
    FromYear: number | null
    ToYear: number | null
  }

  export type ProfessionalqualificationsSumAggregateOutputType = {
    PQ_ID: number | null
    ApplicationID: number | null
    FromYear: number | null
    ToYear: number | null
  }

  export type ProfessionalqualificationsMinAggregateOutputType = {
    PQ_ID: number | null
    ApplicationID: number | null
    Institution: string | null
    QualificationName: string | null
    FromYear: number | null
    ToYear: number | null
    ResultOrExamPassed: string | null
  }

  export type ProfessionalqualificationsMaxAggregateOutputType = {
    PQ_ID: number | null
    ApplicationID: number | null
    Institution: string | null
    QualificationName: string | null
    FromYear: number | null
    ToYear: number | null
    ResultOrExamPassed: string | null
  }

  export type ProfessionalqualificationsCountAggregateOutputType = {
    PQ_ID: number
    ApplicationID: number
    Institution: number
    QualificationName: number
    FromYear: number
    ToYear: number
    ResultOrExamPassed: number
    _all: number
  }


  export type ProfessionalqualificationsAvgAggregateInputType = {
    PQ_ID?: true
    ApplicationID?: true
    FromYear?: true
    ToYear?: true
  }

  export type ProfessionalqualificationsSumAggregateInputType = {
    PQ_ID?: true
    ApplicationID?: true
    FromYear?: true
    ToYear?: true
  }

  export type ProfessionalqualificationsMinAggregateInputType = {
    PQ_ID?: true
    ApplicationID?: true
    Institution?: true
    QualificationName?: true
    FromYear?: true
    ToYear?: true
    ResultOrExamPassed?: true
  }

  export type ProfessionalqualificationsMaxAggregateInputType = {
    PQ_ID?: true
    ApplicationID?: true
    Institution?: true
    QualificationName?: true
    FromYear?: true
    ToYear?: true
    ResultOrExamPassed?: true
  }

  export type ProfessionalqualificationsCountAggregateInputType = {
    PQ_ID?: true
    ApplicationID?: true
    Institution?: true
    QualificationName?: true
    FromYear?: true
    ToYear?: true
    ResultOrExamPassed?: true
    _all?: true
  }

  export type ProfessionalqualificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which professionalqualifications to aggregate.
     */
    where?: professionalqualificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of professionalqualifications to fetch.
     */
    orderBy?: professionalqualificationsOrderByWithRelationInput | professionalqualificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: professionalqualificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` professionalqualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` professionalqualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned professionalqualifications
    **/
    _count?: true | ProfessionalqualificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfessionalqualificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfessionalqualificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfessionalqualificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfessionalqualificationsMaxAggregateInputType
  }

  export type GetProfessionalqualificationsAggregateType<T extends ProfessionalqualificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateProfessionalqualifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfessionalqualifications[P]>
      : GetScalarType<T[P], AggregateProfessionalqualifications[P]>
  }




  export type professionalqualificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: professionalqualificationsWhereInput
    orderBy?: professionalqualificationsOrderByWithAggregationInput | professionalqualificationsOrderByWithAggregationInput[]
    by: ProfessionalqualificationsScalarFieldEnum[] | ProfessionalqualificationsScalarFieldEnum
    having?: professionalqualificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfessionalqualificationsCountAggregateInputType | true
    _avg?: ProfessionalqualificationsAvgAggregateInputType
    _sum?: ProfessionalqualificationsSumAggregateInputType
    _min?: ProfessionalqualificationsMinAggregateInputType
    _max?: ProfessionalqualificationsMaxAggregateInputType
  }

  export type ProfessionalqualificationsGroupByOutputType = {
    PQ_ID: number
    ApplicationID: number | null
    Institution: string | null
    QualificationName: string | null
    FromYear: number | null
    ToYear: number | null
    ResultOrExamPassed: string | null
    _count: ProfessionalqualificationsCountAggregateOutputType | null
    _avg: ProfessionalqualificationsAvgAggregateOutputType | null
    _sum: ProfessionalqualificationsSumAggregateOutputType | null
    _min: ProfessionalqualificationsMinAggregateOutputType | null
    _max: ProfessionalqualificationsMaxAggregateOutputType | null
  }

  type GetProfessionalqualificationsGroupByPayload<T extends professionalqualificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfessionalqualificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfessionalqualificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfessionalqualificationsGroupByOutputType[P]>
            : GetScalarType<T[P], ProfessionalqualificationsGroupByOutputType[P]>
        }
      >
    >


  export type professionalqualificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PQ_ID?: boolean
    ApplicationID?: boolean
    Institution?: boolean
    QualificationName?: boolean
    FromYear?: boolean
    ToYear?: boolean
    ResultOrExamPassed?: boolean
    application?: boolean | professionalqualifications$applicationArgs<ExtArgs>
  }, ExtArgs["result"]["professionalqualifications"]>



  export type professionalqualificationsSelectScalar = {
    PQ_ID?: boolean
    ApplicationID?: boolean
    Institution?: boolean
    QualificationName?: boolean
    FromYear?: boolean
    ToYear?: boolean
    ResultOrExamPassed?: boolean
  }

  export type professionalqualificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"PQ_ID" | "ApplicationID" | "Institution" | "QualificationName" | "FromYear" | "ToYear" | "ResultOrExamPassed", ExtArgs["result"]["professionalqualifications"]>
  export type professionalqualificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | professionalqualifications$applicationArgs<ExtArgs>
  }

  export type $professionalqualificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "professionalqualifications"
    objects: {
      application: Prisma.$applicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      PQ_ID: number
      ApplicationID: number | null
      Institution: string | null
      QualificationName: string | null
      FromYear: number | null
      ToYear: number | null
      ResultOrExamPassed: string | null
    }, ExtArgs["result"]["professionalqualifications"]>
    composites: {}
  }

  type professionalqualificationsGetPayload<S extends boolean | null | undefined | professionalqualificationsDefaultArgs> = $Result.GetResult<Prisma.$professionalqualificationsPayload, S>

  type professionalqualificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<professionalqualificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfessionalqualificationsCountAggregateInputType | true
    }

  export interface professionalqualificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['professionalqualifications'], meta: { name: 'professionalqualifications' } }
    /**
     * Find zero or one Professionalqualifications that matches the filter.
     * @param {professionalqualificationsFindUniqueArgs} args - Arguments to find a Professionalqualifications
     * @example
     * // Get one Professionalqualifications
     * const professionalqualifications = await prisma.professionalqualifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends professionalqualificationsFindUniqueArgs>(args: SelectSubset<T, professionalqualificationsFindUniqueArgs<ExtArgs>>): Prisma__professionalqualificationsClient<$Result.GetResult<Prisma.$professionalqualificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Professionalqualifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {professionalqualificationsFindUniqueOrThrowArgs} args - Arguments to find a Professionalqualifications
     * @example
     * // Get one Professionalqualifications
     * const professionalqualifications = await prisma.professionalqualifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends professionalqualificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, professionalqualificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__professionalqualificationsClient<$Result.GetResult<Prisma.$professionalqualificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Professionalqualifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {professionalqualificationsFindFirstArgs} args - Arguments to find a Professionalqualifications
     * @example
     * // Get one Professionalqualifications
     * const professionalqualifications = await prisma.professionalqualifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends professionalqualificationsFindFirstArgs>(args?: SelectSubset<T, professionalqualificationsFindFirstArgs<ExtArgs>>): Prisma__professionalqualificationsClient<$Result.GetResult<Prisma.$professionalqualificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Professionalqualifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {professionalqualificationsFindFirstOrThrowArgs} args - Arguments to find a Professionalqualifications
     * @example
     * // Get one Professionalqualifications
     * const professionalqualifications = await prisma.professionalqualifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends professionalqualificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, professionalqualificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__professionalqualificationsClient<$Result.GetResult<Prisma.$professionalqualificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Professionalqualifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {professionalqualificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Professionalqualifications
     * const professionalqualifications = await prisma.professionalqualifications.findMany()
     * 
     * // Get first 10 Professionalqualifications
     * const professionalqualifications = await prisma.professionalqualifications.findMany({ take: 10 })
     * 
     * // Only select the `PQ_ID`
     * const professionalqualificationsWithPQ_IDOnly = await prisma.professionalqualifications.findMany({ select: { PQ_ID: true } })
     * 
     */
    findMany<T extends professionalqualificationsFindManyArgs>(args?: SelectSubset<T, professionalqualificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$professionalqualificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Professionalqualifications.
     * @param {professionalqualificationsCreateArgs} args - Arguments to create a Professionalqualifications.
     * @example
     * // Create one Professionalqualifications
     * const Professionalqualifications = await prisma.professionalqualifications.create({
     *   data: {
     *     // ... data to create a Professionalqualifications
     *   }
     * })
     * 
     */
    create<T extends professionalqualificationsCreateArgs>(args: SelectSubset<T, professionalqualificationsCreateArgs<ExtArgs>>): Prisma__professionalqualificationsClient<$Result.GetResult<Prisma.$professionalqualificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Professionalqualifications.
     * @param {professionalqualificationsCreateManyArgs} args - Arguments to create many Professionalqualifications.
     * @example
     * // Create many Professionalqualifications
     * const professionalqualifications = await prisma.professionalqualifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends professionalqualificationsCreateManyArgs>(args?: SelectSubset<T, professionalqualificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Professionalqualifications.
     * @param {professionalqualificationsDeleteArgs} args - Arguments to delete one Professionalqualifications.
     * @example
     * // Delete one Professionalqualifications
     * const Professionalqualifications = await prisma.professionalqualifications.delete({
     *   where: {
     *     // ... filter to delete one Professionalqualifications
     *   }
     * })
     * 
     */
    delete<T extends professionalqualificationsDeleteArgs>(args: SelectSubset<T, professionalqualificationsDeleteArgs<ExtArgs>>): Prisma__professionalqualificationsClient<$Result.GetResult<Prisma.$professionalqualificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Professionalqualifications.
     * @param {professionalqualificationsUpdateArgs} args - Arguments to update one Professionalqualifications.
     * @example
     * // Update one Professionalqualifications
     * const professionalqualifications = await prisma.professionalqualifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends professionalqualificationsUpdateArgs>(args: SelectSubset<T, professionalqualificationsUpdateArgs<ExtArgs>>): Prisma__professionalqualificationsClient<$Result.GetResult<Prisma.$professionalqualificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Professionalqualifications.
     * @param {professionalqualificationsDeleteManyArgs} args - Arguments to filter Professionalqualifications to delete.
     * @example
     * // Delete a few Professionalqualifications
     * const { count } = await prisma.professionalqualifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends professionalqualificationsDeleteManyArgs>(args?: SelectSubset<T, professionalqualificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Professionalqualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {professionalqualificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Professionalqualifications
     * const professionalqualifications = await prisma.professionalqualifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends professionalqualificationsUpdateManyArgs>(args: SelectSubset<T, professionalqualificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Professionalqualifications.
     * @param {professionalqualificationsUpsertArgs} args - Arguments to update or create a Professionalqualifications.
     * @example
     * // Update or create a Professionalqualifications
     * const professionalqualifications = await prisma.professionalqualifications.upsert({
     *   create: {
     *     // ... data to create a Professionalqualifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Professionalqualifications we want to update
     *   }
     * })
     */
    upsert<T extends professionalqualificationsUpsertArgs>(args: SelectSubset<T, professionalqualificationsUpsertArgs<ExtArgs>>): Prisma__professionalqualificationsClient<$Result.GetResult<Prisma.$professionalqualificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Professionalqualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {professionalqualificationsCountArgs} args - Arguments to filter Professionalqualifications to count.
     * @example
     * // Count the number of Professionalqualifications
     * const count = await prisma.professionalqualifications.count({
     *   where: {
     *     // ... the filter for the Professionalqualifications we want to count
     *   }
     * })
    **/
    count<T extends professionalqualificationsCountArgs>(
      args?: Subset<T, professionalqualificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfessionalqualificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Professionalqualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfessionalqualificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfessionalqualificationsAggregateArgs>(args: Subset<T, ProfessionalqualificationsAggregateArgs>): Prisma.PrismaPromise<GetProfessionalqualificationsAggregateType<T>>

    /**
     * Group by Professionalqualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {professionalqualificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends professionalqualificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: professionalqualificationsGroupByArgs['orderBy'] }
        : { orderBy?: professionalqualificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, professionalqualificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfessionalqualificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the professionalqualifications model
   */
  readonly fields: professionalqualificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for professionalqualifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__professionalqualificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends professionalqualifications$applicationArgs<ExtArgs> = {}>(args?: Subset<T, professionalqualifications$applicationArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the professionalqualifications model
   */
  interface professionalqualificationsFieldRefs {
    readonly PQ_ID: FieldRef<"professionalqualifications", 'Int'>
    readonly ApplicationID: FieldRef<"professionalqualifications", 'Int'>
    readonly Institution: FieldRef<"professionalqualifications", 'String'>
    readonly QualificationName: FieldRef<"professionalqualifications", 'String'>
    readonly FromYear: FieldRef<"professionalqualifications", 'Int'>
    readonly ToYear: FieldRef<"professionalqualifications", 'Int'>
    readonly ResultOrExamPassed: FieldRef<"professionalqualifications", 'String'>
  }
    

  // Custom InputTypes
  /**
   * professionalqualifications findUnique
   */
  export type professionalqualificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professionalqualifications
     */
    select?: professionalqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the professionalqualifications
     */
    omit?: professionalqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professionalqualificationsInclude<ExtArgs> | null
    /**
     * Filter, which professionalqualifications to fetch.
     */
    where: professionalqualificationsWhereUniqueInput
  }

  /**
   * professionalqualifications findUniqueOrThrow
   */
  export type professionalqualificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professionalqualifications
     */
    select?: professionalqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the professionalqualifications
     */
    omit?: professionalqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professionalqualificationsInclude<ExtArgs> | null
    /**
     * Filter, which professionalqualifications to fetch.
     */
    where: professionalqualificationsWhereUniqueInput
  }

  /**
   * professionalqualifications findFirst
   */
  export type professionalqualificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professionalqualifications
     */
    select?: professionalqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the professionalqualifications
     */
    omit?: professionalqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professionalqualificationsInclude<ExtArgs> | null
    /**
     * Filter, which professionalqualifications to fetch.
     */
    where?: professionalqualificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of professionalqualifications to fetch.
     */
    orderBy?: professionalqualificationsOrderByWithRelationInput | professionalqualificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for professionalqualifications.
     */
    cursor?: professionalqualificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` professionalqualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` professionalqualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of professionalqualifications.
     */
    distinct?: ProfessionalqualificationsScalarFieldEnum | ProfessionalqualificationsScalarFieldEnum[]
  }

  /**
   * professionalqualifications findFirstOrThrow
   */
  export type professionalqualificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professionalqualifications
     */
    select?: professionalqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the professionalqualifications
     */
    omit?: professionalqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professionalqualificationsInclude<ExtArgs> | null
    /**
     * Filter, which professionalqualifications to fetch.
     */
    where?: professionalqualificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of professionalqualifications to fetch.
     */
    orderBy?: professionalqualificationsOrderByWithRelationInput | professionalqualificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for professionalqualifications.
     */
    cursor?: professionalqualificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` professionalqualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` professionalqualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of professionalqualifications.
     */
    distinct?: ProfessionalqualificationsScalarFieldEnum | ProfessionalqualificationsScalarFieldEnum[]
  }

  /**
   * professionalqualifications findMany
   */
  export type professionalqualificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professionalqualifications
     */
    select?: professionalqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the professionalqualifications
     */
    omit?: professionalqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professionalqualificationsInclude<ExtArgs> | null
    /**
     * Filter, which professionalqualifications to fetch.
     */
    where?: professionalqualificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of professionalqualifications to fetch.
     */
    orderBy?: professionalqualificationsOrderByWithRelationInput | professionalqualificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing professionalqualifications.
     */
    cursor?: professionalqualificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` professionalqualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` professionalqualifications.
     */
    skip?: number
    distinct?: ProfessionalqualificationsScalarFieldEnum | ProfessionalqualificationsScalarFieldEnum[]
  }

  /**
   * professionalqualifications create
   */
  export type professionalqualificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professionalqualifications
     */
    select?: professionalqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the professionalqualifications
     */
    omit?: professionalqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professionalqualificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a professionalqualifications.
     */
    data?: XOR<professionalqualificationsCreateInput, professionalqualificationsUncheckedCreateInput>
  }

  /**
   * professionalqualifications createMany
   */
  export type professionalqualificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many professionalqualifications.
     */
    data: professionalqualificationsCreateManyInput | professionalqualificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * professionalqualifications update
   */
  export type professionalqualificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professionalqualifications
     */
    select?: professionalqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the professionalqualifications
     */
    omit?: professionalqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professionalqualificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a professionalqualifications.
     */
    data: XOR<professionalqualificationsUpdateInput, professionalqualificationsUncheckedUpdateInput>
    /**
     * Choose, which professionalqualifications to update.
     */
    where: professionalqualificationsWhereUniqueInput
  }

  /**
   * professionalqualifications updateMany
   */
  export type professionalqualificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update professionalqualifications.
     */
    data: XOR<professionalqualificationsUpdateManyMutationInput, professionalqualificationsUncheckedUpdateManyInput>
    /**
     * Filter which professionalqualifications to update
     */
    where?: professionalqualificationsWhereInput
    /**
     * Limit how many professionalqualifications to update.
     */
    limit?: number
  }

  /**
   * professionalqualifications upsert
   */
  export type professionalqualificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professionalqualifications
     */
    select?: professionalqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the professionalqualifications
     */
    omit?: professionalqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professionalqualificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the professionalqualifications to update in case it exists.
     */
    where: professionalqualificationsWhereUniqueInput
    /**
     * In case the professionalqualifications found by the `where` argument doesn't exist, create a new professionalqualifications with this data.
     */
    create: XOR<professionalqualificationsCreateInput, professionalqualificationsUncheckedCreateInput>
    /**
     * In case the professionalqualifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<professionalqualificationsUpdateInput, professionalqualificationsUncheckedUpdateInput>
  }

  /**
   * professionalqualifications delete
   */
  export type professionalqualificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professionalqualifications
     */
    select?: professionalqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the professionalqualifications
     */
    omit?: professionalqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professionalqualificationsInclude<ExtArgs> | null
    /**
     * Filter which professionalqualifications to delete.
     */
    where: professionalqualificationsWhereUniqueInput
  }

  /**
   * professionalqualifications deleteMany
   */
  export type professionalqualificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which professionalqualifications to delete
     */
    where?: professionalqualificationsWhereInput
    /**
     * Limit how many professionalqualifications to delete.
     */
    limit?: number
  }

  /**
   * professionalqualifications.application
   */
  export type professionalqualifications$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    where?: applicationWhereInput
  }

  /**
   * professionalqualifications without action
   */
  export type professionalqualificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the professionalqualifications
     */
    select?: professionalqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the professionalqualifications
     */
    omit?: professionalqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: professionalqualificationsInclude<ExtArgs> | null
  }


  /**
   * Model researchandpublications
   */

  export type AggregateResearchandpublications = {
    _count: ResearchandpublicationsCountAggregateOutputType | null
    _avg: ResearchandpublicationsAvgAggregateOutputType | null
    _sum: ResearchandpublicationsSumAggregateOutputType | null
    _min: ResearchandpublicationsMinAggregateOutputType | null
    _max: ResearchandpublicationsMaxAggregateOutputType | null
  }

  export type ResearchandpublicationsAvgAggregateOutputType = {
    ResearchID: number | null
    ApplicationID: number | null
  }

  export type ResearchandpublicationsSumAggregateOutputType = {
    ResearchID: number | null
    ApplicationID: number | null
  }

  export type ResearchandpublicationsMinAggregateOutputType = {
    ResearchID: number | null
    ApplicationID: number | null
    Description: string | null
  }

  export type ResearchandpublicationsMaxAggregateOutputType = {
    ResearchID: number | null
    ApplicationID: number | null
    Description: string | null
  }

  export type ResearchandpublicationsCountAggregateOutputType = {
    ResearchID: number
    ApplicationID: number
    Description: number
    _all: number
  }


  export type ResearchandpublicationsAvgAggregateInputType = {
    ResearchID?: true
    ApplicationID?: true
  }

  export type ResearchandpublicationsSumAggregateInputType = {
    ResearchID?: true
    ApplicationID?: true
  }

  export type ResearchandpublicationsMinAggregateInputType = {
    ResearchID?: true
    ApplicationID?: true
    Description?: true
  }

  export type ResearchandpublicationsMaxAggregateInputType = {
    ResearchID?: true
    ApplicationID?: true
    Description?: true
  }

  export type ResearchandpublicationsCountAggregateInputType = {
    ResearchID?: true
    ApplicationID?: true
    Description?: true
    _all?: true
  }

  export type ResearchandpublicationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which researchandpublications to aggregate.
     */
    where?: researchandpublicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of researchandpublications to fetch.
     */
    orderBy?: researchandpublicationsOrderByWithRelationInput | researchandpublicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: researchandpublicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` researchandpublications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` researchandpublications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned researchandpublications
    **/
    _count?: true | ResearchandpublicationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResearchandpublicationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResearchandpublicationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResearchandpublicationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResearchandpublicationsMaxAggregateInputType
  }

  export type GetResearchandpublicationsAggregateType<T extends ResearchandpublicationsAggregateArgs> = {
        [P in keyof T & keyof AggregateResearchandpublications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResearchandpublications[P]>
      : GetScalarType<T[P], AggregateResearchandpublications[P]>
  }




  export type researchandpublicationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: researchandpublicationsWhereInput
    orderBy?: researchandpublicationsOrderByWithAggregationInput | researchandpublicationsOrderByWithAggregationInput[]
    by: ResearchandpublicationsScalarFieldEnum[] | ResearchandpublicationsScalarFieldEnum
    having?: researchandpublicationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResearchandpublicationsCountAggregateInputType | true
    _avg?: ResearchandpublicationsAvgAggregateInputType
    _sum?: ResearchandpublicationsSumAggregateInputType
    _min?: ResearchandpublicationsMinAggregateInputType
    _max?: ResearchandpublicationsMaxAggregateInputType
  }

  export type ResearchandpublicationsGroupByOutputType = {
    ResearchID: number
    ApplicationID: number | null
    Description: string | null
    _count: ResearchandpublicationsCountAggregateOutputType | null
    _avg: ResearchandpublicationsAvgAggregateOutputType | null
    _sum: ResearchandpublicationsSumAggregateOutputType | null
    _min: ResearchandpublicationsMinAggregateOutputType | null
    _max: ResearchandpublicationsMaxAggregateOutputType | null
  }

  type GetResearchandpublicationsGroupByPayload<T extends researchandpublicationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResearchandpublicationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResearchandpublicationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResearchandpublicationsGroupByOutputType[P]>
            : GetScalarType<T[P], ResearchandpublicationsGroupByOutputType[P]>
        }
      >
    >


  export type researchandpublicationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ResearchID?: boolean
    ApplicationID?: boolean
    Description?: boolean
    application?: boolean | researchandpublications$applicationArgs<ExtArgs>
  }, ExtArgs["result"]["researchandpublications"]>



  export type researchandpublicationsSelectScalar = {
    ResearchID?: boolean
    ApplicationID?: boolean
    Description?: boolean
  }

  export type researchandpublicationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ResearchID" | "ApplicationID" | "Description", ExtArgs["result"]["researchandpublications"]>
  export type researchandpublicationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | researchandpublications$applicationArgs<ExtArgs>
  }

  export type $researchandpublicationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "researchandpublications"
    objects: {
      application: Prisma.$applicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ResearchID: number
      ApplicationID: number | null
      Description: string | null
    }, ExtArgs["result"]["researchandpublications"]>
    composites: {}
  }

  type researchandpublicationsGetPayload<S extends boolean | null | undefined | researchandpublicationsDefaultArgs> = $Result.GetResult<Prisma.$researchandpublicationsPayload, S>

  type researchandpublicationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<researchandpublicationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResearchandpublicationsCountAggregateInputType | true
    }

  export interface researchandpublicationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['researchandpublications'], meta: { name: 'researchandpublications' } }
    /**
     * Find zero or one Researchandpublications that matches the filter.
     * @param {researchandpublicationsFindUniqueArgs} args - Arguments to find a Researchandpublications
     * @example
     * // Get one Researchandpublications
     * const researchandpublications = await prisma.researchandpublications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends researchandpublicationsFindUniqueArgs>(args: SelectSubset<T, researchandpublicationsFindUniqueArgs<ExtArgs>>): Prisma__researchandpublicationsClient<$Result.GetResult<Prisma.$researchandpublicationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Researchandpublications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {researchandpublicationsFindUniqueOrThrowArgs} args - Arguments to find a Researchandpublications
     * @example
     * // Get one Researchandpublications
     * const researchandpublications = await prisma.researchandpublications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends researchandpublicationsFindUniqueOrThrowArgs>(args: SelectSubset<T, researchandpublicationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__researchandpublicationsClient<$Result.GetResult<Prisma.$researchandpublicationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Researchandpublications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {researchandpublicationsFindFirstArgs} args - Arguments to find a Researchandpublications
     * @example
     * // Get one Researchandpublications
     * const researchandpublications = await prisma.researchandpublications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends researchandpublicationsFindFirstArgs>(args?: SelectSubset<T, researchandpublicationsFindFirstArgs<ExtArgs>>): Prisma__researchandpublicationsClient<$Result.GetResult<Prisma.$researchandpublicationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Researchandpublications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {researchandpublicationsFindFirstOrThrowArgs} args - Arguments to find a Researchandpublications
     * @example
     * // Get one Researchandpublications
     * const researchandpublications = await prisma.researchandpublications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends researchandpublicationsFindFirstOrThrowArgs>(args?: SelectSubset<T, researchandpublicationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__researchandpublicationsClient<$Result.GetResult<Prisma.$researchandpublicationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Researchandpublications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {researchandpublicationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Researchandpublications
     * const researchandpublications = await prisma.researchandpublications.findMany()
     * 
     * // Get first 10 Researchandpublications
     * const researchandpublications = await prisma.researchandpublications.findMany({ take: 10 })
     * 
     * // Only select the `ResearchID`
     * const researchandpublicationsWithResearchIDOnly = await prisma.researchandpublications.findMany({ select: { ResearchID: true } })
     * 
     */
    findMany<T extends researchandpublicationsFindManyArgs>(args?: SelectSubset<T, researchandpublicationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$researchandpublicationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Researchandpublications.
     * @param {researchandpublicationsCreateArgs} args - Arguments to create a Researchandpublications.
     * @example
     * // Create one Researchandpublications
     * const Researchandpublications = await prisma.researchandpublications.create({
     *   data: {
     *     // ... data to create a Researchandpublications
     *   }
     * })
     * 
     */
    create<T extends researchandpublicationsCreateArgs>(args: SelectSubset<T, researchandpublicationsCreateArgs<ExtArgs>>): Prisma__researchandpublicationsClient<$Result.GetResult<Prisma.$researchandpublicationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Researchandpublications.
     * @param {researchandpublicationsCreateManyArgs} args - Arguments to create many Researchandpublications.
     * @example
     * // Create many Researchandpublications
     * const researchandpublications = await prisma.researchandpublications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends researchandpublicationsCreateManyArgs>(args?: SelectSubset<T, researchandpublicationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Researchandpublications.
     * @param {researchandpublicationsDeleteArgs} args - Arguments to delete one Researchandpublications.
     * @example
     * // Delete one Researchandpublications
     * const Researchandpublications = await prisma.researchandpublications.delete({
     *   where: {
     *     // ... filter to delete one Researchandpublications
     *   }
     * })
     * 
     */
    delete<T extends researchandpublicationsDeleteArgs>(args: SelectSubset<T, researchandpublicationsDeleteArgs<ExtArgs>>): Prisma__researchandpublicationsClient<$Result.GetResult<Prisma.$researchandpublicationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Researchandpublications.
     * @param {researchandpublicationsUpdateArgs} args - Arguments to update one Researchandpublications.
     * @example
     * // Update one Researchandpublications
     * const researchandpublications = await prisma.researchandpublications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends researchandpublicationsUpdateArgs>(args: SelectSubset<T, researchandpublicationsUpdateArgs<ExtArgs>>): Prisma__researchandpublicationsClient<$Result.GetResult<Prisma.$researchandpublicationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Researchandpublications.
     * @param {researchandpublicationsDeleteManyArgs} args - Arguments to filter Researchandpublications to delete.
     * @example
     * // Delete a few Researchandpublications
     * const { count } = await prisma.researchandpublications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends researchandpublicationsDeleteManyArgs>(args?: SelectSubset<T, researchandpublicationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Researchandpublications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {researchandpublicationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Researchandpublications
     * const researchandpublications = await prisma.researchandpublications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends researchandpublicationsUpdateManyArgs>(args: SelectSubset<T, researchandpublicationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Researchandpublications.
     * @param {researchandpublicationsUpsertArgs} args - Arguments to update or create a Researchandpublications.
     * @example
     * // Update or create a Researchandpublications
     * const researchandpublications = await prisma.researchandpublications.upsert({
     *   create: {
     *     // ... data to create a Researchandpublications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Researchandpublications we want to update
     *   }
     * })
     */
    upsert<T extends researchandpublicationsUpsertArgs>(args: SelectSubset<T, researchandpublicationsUpsertArgs<ExtArgs>>): Prisma__researchandpublicationsClient<$Result.GetResult<Prisma.$researchandpublicationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Researchandpublications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {researchandpublicationsCountArgs} args - Arguments to filter Researchandpublications to count.
     * @example
     * // Count the number of Researchandpublications
     * const count = await prisma.researchandpublications.count({
     *   where: {
     *     // ... the filter for the Researchandpublications we want to count
     *   }
     * })
    **/
    count<T extends researchandpublicationsCountArgs>(
      args?: Subset<T, researchandpublicationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResearchandpublicationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Researchandpublications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchandpublicationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResearchandpublicationsAggregateArgs>(args: Subset<T, ResearchandpublicationsAggregateArgs>): Prisma.PrismaPromise<GetResearchandpublicationsAggregateType<T>>

    /**
     * Group by Researchandpublications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {researchandpublicationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends researchandpublicationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: researchandpublicationsGroupByArgs['orderBy'] }
        : { orderBy?: researchandpublicationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, researchandpublicationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResearchandpublicationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the researchandpublications model
   */
  readonly fields: researchandpublicationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for researchandpublications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__researchandpublicationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends researchandpublications$applicationArgs<ExtArgs> = {}>(args?: Subset<T, researchandpublications$applicationArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the researchandpublications model
   */
  interface researchandpublicationsFieldRefs {
    readonly ResearchID: FieldRef<"researchandpublications", 'Int'>
    readonly ApplicationID: FieldRef<"researchandpublications", 'Int'>
    readonly Description: FieldRef<"researchandpublications", 'String'>
  }
    

  // Custom InputTypes
  /**
   * researchandpublications findUnique
   */
  export type researchandpublicationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the researchandpublications
     */
    select?: researchandpublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the researchandpublications
     */
    omit?: researchandpublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: researchandpublicationsInclude<ExtArgs> | null
    /**
     * Filter, which researchandpublications to fetch.
     */
    where: researchandpublicationsWhereUniqueInput
  }

  /**
   * researchandpublications findUniqueOrThrow
   */
  export type researchandpublicationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the researchandpublications
     */
    select?: researchandpublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the researchandpublications
     */
    omit?: researchandpublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: researchandpublicationsInclude<ExtArgs> | null
    /**
     * Filter, which researchandpublications to fetch.
     */
    where: researchandpublicationsWhereUniqueInput
  }

  /**
   * researchandpublications findFirst
   */
  export type researchandpublicationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the researchandpublications
     */
    select?: researchandpublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the researchandpublications
     */
    omit?: researchandpublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: researchandpublicationsInclude<ExtArgs> | null
    /**
     * Filter, which researchandpublications to fetch.
     */
    where?: researchandpublicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of researchandpublications to fetch.
     */
    orderBy?: researchandpublicationsOrderByWithRelationInput | researchandpublicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for researchandpublications.
     */
    cursor?: researchandpublicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` researchandpublications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` researchandpublications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of researchandpublications.
     */
    distinct?: ResearchandpublicationsScalarFieldEnum | ResearchandpublicationsScalarFieldEnum[]
  }

  /**
   * researchandpublications findFirstOrThrow
   */
  export type researchandpublicationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the researchandpublications
     */
    select?: researchandpublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the researchandpublications
     */
    omit?: researchandpublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: researchandpublicationsInclude<ExtArgs> | null
    /**
     * Filter, which researchandpublications to fetch.
     */
    where?: researchandpublicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of researchandpublications to fetch.
     */
    orderBy?: researchandpublicationsOrderByWithRelationInput | researchandpublicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for researchandpublications.
     */
    cursor?: researchandpublicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` researchandpublications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` researchandpublications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of researchandpublications.
     */
    distinct?: ResearchandpublicationsScalarFieldEnum | ResearchandpublicationsScalarFieldEnum[]
  }

  /**
   * researchandpublications findMany
   */
  export type researchandpublicationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the researchandpublications
     */
    select?: researchandpublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the researchandpublications
     */
    omit?: researchandpublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: researchandpublicationsInclude<ExtArgs> | null
    /**
     * Filter, which researchandpublications to fetch.
     */
    where?: researchandpublicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of researchandpublications to fetch.
     */
    orderBy?: researchandpublicationsOrderByWithRelationInput | researchandpublicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing researchandpublications.
     */
    cursor?: researchandpublicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` researchandpublications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` researchandpublications.
     */
    skip?: number
    distinct?: ResearchandpublicationsScalarFieldEnum | ResearchandpublicationsScalarFieldEnum[]
  }

  /**
   * researchandpublications create
   */
  export type researchandpublicationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the researchandpublications
     */
    select?: researchandpublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the researchandpublications
     */
    omit?: researchandpublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: researchandpublicationsInclude<ExtArgs> | null
    /**
     * The data needed to create a researchandpublications.
     */
    data?: XOR<researchandpublicationsCreateInput, researchandpublicationsUncheckedCreateInput>
  }

  /**
   * researchandpublications createMany
   */
  export type researchandpublicationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many researchandpublications.
     */
    data: researchandpublicationsCreateManyInput | researchandpublicationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * researchandpublications update
   */
  export type researchandpublicationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the researchandpublications
     */
    select?: researchandpublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the researchandpublications
     */
    omit?: researchandpublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: researchandpublicationsInclude<ExtArgs> | null
    /**
     * The data needed to update a researchandpublications.
     */
    data: XOR<researchandpublicationsUpdateInput, researchandpublicationsUncheckedUpdateInput>
    /**
     * Choose, which researchandpublications to update.
     */
    where: researchandpublicationsWhereUniqueInput
  }

  /**
   * researchandpublications updateMany
   */
  export type researchandpublicationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update researchandpublications.
     */
    data: XOR<researchandpublicationsUpdateManyMutationInput, researchandpublicationsUncheckedUpdateManyInput>
    /**
     * Filter which researchandpublications to update
     */
    where?: researchandpublicationsWhereInput
    /**
     * Limit how many researchandpublications to update.
     */
    limit?: number
  }

  /**
   * researchandpublications upsert
   */
  export type researchandpublicationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the researchandpublications
     */
    select?: researchandpublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the researchandpublications
     */
    omit?: researchandpublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: researchandpublicationsInclude<ExtArgs> | null
    /**
     * The filter to search for the researchandpublications to update in case it exists.
     */
    where: researchandpublicationsWhereUniqueInput
    /**
     * In case the researchandpublications found by the `where` argument doesn't exist, create a new researchandpublications with this data.
     */
    create: XOR<researchandpublicationsCreateInput, researchandpublicationsUncheckedCreateInput>
    /**
     * In case the researchandpublications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<researchandpublicationsUpdateInput, researchandpublicationsUncheckedUpdateInput>
  }

  /**
   * researchandpublications delete
   */
  export type researchandpublicationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the researchandpublications
     */
    select?: researchandpublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the researchandpublications
     */
    omit?: researchandpublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: researchandpublicationsInclude<ExtArgs> | null
    /**
     * Filter which researchandpublications to delete.
     */
    where: researchandpublicationsWhereUniqueInput
  }

  /**
   * researchandpublications deleteMany
   */
  export type researchandpublicationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which researchandpublications to delete
     */
    where?: researchandpublicationsWhereInput
    /**
     * Limit how many researchandpublications to delete.
     */
    limit?: number
  }

  /**
   * researchandpublications.application
   */
  export type researchandpublications$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    where?: applicationWhereInput
  }

  /**
   * researchandpublications without action
   */
  export type researchandpublicationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the researchandpublications
     */
    select?: researchandpublicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the researchandpublications
     */
    omit?: researchandpublicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: researchandpublicationsInclude<ExtArgs> | null
  }


  /**
   * Model specialqualifications
   */

  export type AggregateSpecialqualifications = {
    _count: SpecialqualificationsCountAggregateOutputType | null
    _avg: SpecialqualificationsAvgAggregateOutputType | null
    _sum: SpecialqualificationsSumAggregateOutputType | null
    _min: SpecialqualificationsMinAggregateOutputType | null
    _max: SpecialqualificationsMaxAggregateOutputType | null
  }

  export type SpecialqualificationsAvgAggregateOutputType = {
    SpecialQualID: number | null
    ApplicationID: number | null
  }

  export type SpecialqualificationsSumAggregateOutputType = {
    SpecialQualID: number | null
    ApplicationID: number | null
  }

  export type SpecialqualificationsMinAggregateOutputType = {
    SpecialQualID: number | null
    ApplicationID: number | null
    Description: string | null
  }

  export type SpecialqualificationsMaxAggregateOutputType = {
    SpecialQualID: number | null
    ApplicationID: number | null
    Description: string | null
  }

  export type SpecialqualificationsCountAggregateOutputType = {
    SpecialQualID: number
    ApplicationID: number
    Description: number
    _all: number
  }


  export type SpecialqualificationsAvgAggregateInputType = {
    SpecialQualID?: true
    ApplicationID?: true
  }

  export type SpecialqualificationsSumAggregateInputType = {
    SpecialQualID?: true
    ApplicationID?: true
  }

  export type SpecialqualificationsMinAggregateInputType = {
    SpecialQualID?: true
    ApplicationID?: true
    Description?: true
  }

  export type SpecialqualificationsMaxAggregateInputType = {
    SpecialQualID?: true
    ApplicationID?: true
    Description?: true
  }

  export type SpecialqualificationsCountAggregateInputType = {
    SpecialQualID?: true
    ApplicationID?: true
    Description?: true
    _all?: true
  }

  export type SpecialqualificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which specialqualifications to aggregate.
     */
    where?: specialqualificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of specialqualifications to fetch.
     */
    orderBy?: specialqualificationsOrderByWithRelationInput | specialqualificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: specialqualificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` specialqualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` specialqualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned specialqualifications
    **/
    _count?: true | SpecialqualificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpecialqualificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpecialqualificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecialqualificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecialqualificationsMaxAggregateInputType
  }

  export type GetSpecialqualificationsAggregateType<T extends SpecialqualificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecialqualifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecialqualifications[P]>
      : GetScalarType<T[P], AggregateSpecialqualifications[P]>
  }




  export type specialqualificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: specialqualificationsWhereInput
    orderBy?: specialqualificationsOrderByWithAggregationInput | specialqualificationsOrderByWithAggregationInput[]
    by: SpecialqualificationsScalarFieldEnum[] | SpecialqualificationsScalarFieldEnum
    having?: specialqualificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecialqualificationsCountAggregateInputType | true
    _avg?: SpecialqualificationsAvgAggregateInputType
    _sum?: SpecialqualificationsSumAggregateInputType
    _min?: SpecialqualificationsMinAggregateInputType
    _max?: SpecialqualificationsMaxAggregateInputType
  }

  export type SpecialqualificationsGroupByOutputType = {
    SpecialQualID: number
    ApplicationID: number | null
    Description: string | null
    _count: SpecialqualificationsCountAggregateOutputType | null
    _avg: SpecialqualificationsAvgAggregateOutputType | null
    _sum: SpecialqualificationsSumAggregateOutputType | null
    _min: SpecialqualificationsMinAggregateOutputType | null
    _max: SpecialqualificationsMaxAggregateOutputType | null
  }

  type GetSpecialqualificationsGroupByPayload<T extends specialqualificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpecialqualificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecialqualificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecialqualificationsGroupByOutputType[P]>
            : GetScalarType<T[P], SpecialqualificationsGroupByOutputType[P]>
        }
      >
    >


  export type specialqualificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SpecialQualID?: boolean
    ApplicationID?: boolean
    Description?: boolean
    application?: boolean | specialqualifications$applicationArgs<ExtArgs>
  }, ExtArgs["result"]["specialqualifications"]>



  export type specialqualificationsSelectScalar = {
    SpecialQualID?: boolean
    ApplicationID?: boolean
    Description?: boolean
  }

  export type specialqualificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"SpecialQualID" | "ApplicationID" | "Description", ExtArgs["result"]["specialqualifications"]>
  export type specialqualificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | specialqualifications$applicationArgs<ExtArgs>
  }

  export type $specialqualificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "specialqualifications"
    objects: {
      application: Prisma.$applicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      SpecialQualID: number
      ApplicationID: number | null
      Description: string | null
    }, ExtArgs["result"]["specialqualifications"]>
    composites: {}
  }

  type specialqualificationsGetPayload<S extends boolean | null | undefined | specialqualificationsDefaultArgs> = $Result.GetResult<Prisma.$specialqualificationsPayload, S>

  type specialqualificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<specialqualificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpecialqualificationsCountAggregateInputType | true
    }

  export interface specialqualificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['specialqualifications'], meta: { name: 'specialqualifications' } }
    /**
     * Find zero or one Specialqualifications that matches the filter.
     * @param {specialqualificationsFindUniqueArgs} args - Arguments to find a Specialqualifications
     * @example
     * // Get one Specialqualifications
     * const specialqualifications = await prisma.specialqualifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends specialqualificationsFindUniqueArgs>(args: SelectSubset<T, specialqualificationsFindUniqueArgs<ExtArgs>>): Prisma__specialqualificationsClient<$Result.GetResult<Prisma.$specialqualificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Specialqualifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {specialqualificationsFindUniqueOrThrowArgs} args - Arguments to find a Specialqualifications
     * @example
     * // Get one Specialqualifications
     * const specialqualifications = await prisma.specialqualifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends specialqualificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, specialqualificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__specialqualificationsClient<$Result.GetResult<Prisma.$specialqualificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Specialqualifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specialqualificationsFindFirstArgs} args - Arguments to find a Specialqualifications
     * @example
     * // Get one Specialqualifications
     * const specialqualifications = await prisma.specialqualifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends specialqualificationsFindFirstArgs>(args?: SelectSubset<T, specialqualificationsFindFirstArgs<ExtArgs>>): Prisma__specialqualificationsClient<$Result.GetResult<Prisma.$specialqualificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Specialqualifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specialqualificationsFindFirstOrThrowArgs} args - Arguments to find a Specialqualifications
     * @example
     * // Get one Specialqualifications
     * const specialqualifications = await prisma.specialqualifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends specialqualificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, specialqualificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__specialqualificationsClient<$Result.GetResult<Prisma.$specialqualificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Specialqualifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specialqualificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Specialqualifications
     * const specialqualifications = await prisma.specialqualifications.findMany()
     * 
     * // Get first 10 Specialqualifications
     * const specialqualifications = await prisma.specialqualifications.findMany({ take: 10 })
     * 
     * // Only select the `SpecialQualID`
     * const specialqualificationsWithSpecialQualIDOnly = await prisma.specialqualifications.findMany({ select: { SpecialQualID: true } })
     * 
     */
    findMany<T extends specialqualificationsFindManyArgs>(args?: SelectSubset<T, specialqualificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$specialqualificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Specialqualifications.
     * @param {specialqualificationsCreateArgs} args - Arguments to create a Specialqualifications.
     * @example
     * // Create one Specialqualifications
     * const Specialqualifications = await prisma.specialqualifications.create({
     *   data: {
     *     // ... data to create a Specialqualifications
     *   }
     * })
     * 
     */
    create<T extends specialqualificationsCreateArgs>(args: SelectSubset<T, specialqualificationsCreateArgs<ExtArgs>>): Prisma__specialqualificationsClient<$Result.GetResult<Prisma.$specialqualificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Specialqualifications.
     * @param {specialqualificationsCreateManyArgs} args - Arguments to create many Specialqualifications.
     * @example
     * // Create many Specialqualifications
     * const specialqualifications = await prisma.specialqualifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends specialqualificationsCreateManyArgs>(args?: SelectSubset<T, specialqualificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Specialqualifications.
     * @param {specialqualificationsDeleteArgs} args - Arguments to delete one Specialqualifications.
     * @example
     * // Delete one Specialqualifications
     * const Specialqualifications = await prisma.specialqualifications.delete({
     *   where: {
     *     // ... filter to delete one Specialqualifications
     *   }
     * })
     * 
     */
    delete<T extends specialqualificationsDeleteArgs>(args: SelectSubset<T, specialqualificationsDeleteArgs<ExtArgs>>): Prisma__specialqualificationsClient<$Result.GetResult<Prisma.$specialqualificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Specialqualifications.
     * @param {specialqualificationsUpdateArgs} args - Arguments to update one Specialqualifications.
     * @example
     * // Update one Specialqualifications
     * const specialqualifications = await prisma.specialqualifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends specialqualificationsUpdateArgs>(args: SelectSubset<T, specialqualificationsUpdateArgs<ExtArgs>>): Prisma__specialqualificationsClient<$Result.GetResult<Prisma.$specialqualificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Specialqualifications.
     * @param {specialqualificationsDeleteManyArgs} args - Arguments to filter Specialqualifications to delete.
     * @example
     * // Delete a few Specialqualifications
     * const { count } = await prisma.specialqualifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends specialqualificationsDeleteManyArgs>(args?: SelectSubset<T, specialqualificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Specialqualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specialqualificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Specialqualifications
     * const specialqualifications = await prisma.specialqualifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends specialqualificationsUpdateManyArgs>(args: SelectSubset<T, specialqualificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Specialqualifications.
     * @param {specialqualificationsUpsertArgs} args - Arguments to update or create a Specialqualifications.
     * @example
     * // Update or create a Specialqualifications
     * const specialqualifications = await prisma.specialqualifications.upsert({
     *   create: {
     *     // ... data to create a Specialqualifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Specialqualifications we want to update
     *   }
     * })
     */
    upsert<T extends specialqualificationsUpsertArgs>(args: SelectSubset<T, specialqualificationsUpsertArgs<ExtArgs>>): Prisma__specialqualificationsClient<$Result.GetResult<Prisma.$specialqualificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Specialqualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specialqualificationsCountArgs} args - Arguments to filter Specialqualifications to count.
     * @example
     * // Count the number of Specialqualifications
     * const count = await prisma.specialqualifications.count({
     *   where: {
     *     // ... the filter for the Specialqualifications we want to count
     *   }
     * })
    **/
    count<T extends specialqualificationsCountArgs>(
      args?: Subset<T, specialqualificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecialqualificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Specialqualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialqualificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecialqualificationsAggregateArgs>(args: Subset<T, SpecialqualificationsAggregateArgs>): Prisma.PrismaPromise<GetSpecialqualificationsAggregateType<T>>

    /**
     * Group by Specialqualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specialqualificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends specialqualificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: specialqualificationsGroupByArgs['orderBy'] }
        : { orderBy?: specialqualificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, specialqualificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecialqualificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the specialqualifications model
   */
  readonly fields: specialqualificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for specialqualifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__specialqualificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends specialqualifications$applicationArgs<ExtArgs> = {}>(args?: Subset<T, specialqualifications$applicationArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the specialqualifications model
   */
  interface specialqualificationsFieldRefs {
    readonly SpecialQualID: FieldRef<"specialqualifications", 'Int'>
    readonly ApplicationID: FieldRef<"specialqualifications", 'Int'>
    readonly Description: FieldRef<"specialqualifications", 'String'>
  }
    

  // Custom InputTypes
  /**
   * specialqualifications findUnique
   */
  export type specialqualificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialqualifications
     */
    select?: specialqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the specialqualifications
     */
    omit?: specialqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: specialqualificationsInclude<ExtArgs> | null
    /**
     * Filter, which specialqualifications to fetch.
     */
    where: specialqualificationsWhereUniqueInput
  }

  /**
   * specialqualifications findUniqueOrThrow
   */
  export type specialqualificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialqualifications
     */
    select?: specialqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the specialqualifications
     */
    omit?: specialqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: specialqualificationsInclude<ExtArgs> | null
    /**
     * Filter, which specialqualifications to fetch.
     */
    where: specialqualificationsWhereUniqueInput
  }

  /**
   * specialqualifications findFirst
   */
  export type specialqualificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialqualifications
     */
    select?: specialqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the specialqualifications
     */
    omit?: specialqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: specialqualificationsInclude<ExtArgs> | null
    /**
     * Filter, which specialqualifications to fetch.
     */
    where?: specialqualificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of specialqualifications to fetch.
     */
    orderBy?: specialqualificationsOrderByWithRelationInput | specialqualificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for specialqualifications.
     */
    cursor?: specialqualificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` specialqualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` specialqualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of specialqualifications.
     */
    distinct?: SpecialqualificationsScalarFieldEnum | SpecialqualificationsScalarFieldEnum[]
  }

  /**
   * specialqualifications findFirstOrThrow
   */
  export type specialqualificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialqualifications
     */
    select?: specialqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the specialqualifications
     */
    omit?: specialqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: specialqualificationsInclude<ExtArgs> | null
    /**
     * Filter, which specialqualifications to fetch.
     */
    where?: specialqualificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of specialqualifications to fetch.
     */
    orderBy?: specialqualificationsOrderByWithRelationInput | specialqualificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for specialqualifications.
     */
    cursor?: specialqualificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` specialqualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` specialqualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of specialqualifications.
     */
    distinct?: SpecialqualificationsScalarFieldEnum | SpecialqualificationsScalarFieldEnum[]
  }

  /**
   * specialqualifications findMany
   */
  export type specialqualificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialqualifications
     */
    select?: specialqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the specialqualifications
     */
    omit?: specialqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: specialqualificationsInclude<ExtArgs> | null
    /**
     * Filter, which specialqualifications to fetch.
     */
    where?: specialqualificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of specialqualifications to fetch.
     */
    orderBy?: specialqualificationsOrderByWithRelationInput | specialqualificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing specialqualifications.
     */
    cursor?: specialqualificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` specialqualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` specialqualifications.
     */
    skip?: number
    distinct?: SpecialqualificationsScalarFieldEnum | SpecialqualificationsScalarFieldEnum[]
  }

  /**
   * specialqualifications create
   */
  export type specialqualificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialqualifications
     */
    select?: specialqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the specialqualifications
     */
    omit?: specialqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: specialqualificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a specialqualifications.
     */
    data?: XOR<specialqualificationsCreateInput, specialqualificationsUncheckedCreateInput>
  }

  /**
   * specialqualifications createMany
   */
  export type specialqualificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many specialqualifications.
     */
    data: specialqualificationsCreateManyInput | specialqualificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * specialqualifications update
   */
  export type specialqualificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialqualifications
     */
    select?: specialqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the specialqualifications
     */
    omit?: specialqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: specialqualificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a specialqualifications.
     */
    data: XOR<specialqualificationsUpdateInput, specialqualificationsUncheckedUpdateInput>
    /**
     * Choose, which specialqualifications to update.
     */
    where: specialqualificationsWhereUniqueInput
  }

  /**
   * specialqualifications updateMany
   */
  export type specialqualificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update specialqualifications.
     */
    data: XOR<specialqualificationsUpdateManyMutationInput, specialqualificationsUncheckedUpdateManyInput>
    /**
     * Filter which specialqualifications to update
     */
    where?: specialqualificationsWhereInput
    /**
     * Limit how many specialqualifications to update.
     */
    limit?: number
  }

  /**
   * specialqualifications upsert
   */
  export type specialqualificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialqualifications
     */
    select?: specialqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the specialqualifications
     */
    omit?: specialqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: specialqualificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the specialqualifications to update in case it exists.
     */
    where: specialqualificationsWhereUniqueInput
    /**
     * In case the specialqualifications found by the `where` argument doesn't exist, create a new specialqualifications with this data.
     */
    create: XOR<specialqualificationsCreateInput, specialqualificationsUncheckedCreateInput>
    /**
     * In case the specialqualifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<specialqualificationsUpdateInput, specialqualificationsUncheckedUpdateInput>
  }

  /**
   * specialqualifications delete
   */
  export type specialqualificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialqualifications
     */
    select?: specialqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the specialqualifications
     */
    omit?: specialqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: specialqualificationsInclude<ExtArgs> | null
    /**
     * Filter which specialqualifications to delete.
     */
    where: specialqualificationsWhereUniqueInput
  }

  /**
   * specialqualifications deleteMany
   */
  export type specialqualificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which specialqualifications to delete
     */
    where?: specialqualificationsWhereInput
    /**
     * Limit how many specialqualifications to delete.
     */
    limit?: number
  }

  /**
   * specialqualifications.application
   */
  export type specialqualifications$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    where?: applicationWhereInput
  }

  /**
   * specialqualifications without action
   */
  export type specialqualificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialqualifications
     */
    select?: specialqualificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the specialqualifications
     */
    omit?: specialqualificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: specialqualificationsInclude<ExtArgs> | null
  }


  /**
   * Model superadmin
   */

  export type AggregateSuperadmin = {
    _count: SuperadminCountAggregateOutputType | null
    _avg: SuperadminAvgAggregateOutputType | null
    _sum: SuperadminSumAggregateOutputType | null
    _min: SuperadminMinAggregateOutputType | null
    _max: SuperadminMaxAggregateOutputType | null
  }

  export type SuperadminAvgAggregateOutputType = {
    SuperAdminID: number | null
  }

  export type SuperadminSumAggregateOutputType = {
    SuperAdminID: number | null
  }

  export type SuperadminMinAggregateOutputType = {
    SuperAdminID: number | null
    FullName: string | null
    Email: string | null
    PasswordHash: string | null
    PhoneNumber: string | null
    CreatedAt: Date | null
  }

  export type SuperadminMaxAggregateOutputType = {
    SuperAdminID: number | null
    FullName: string | null
    Email: string | null
    PasswordHash: string | null
    PhoneNumber: string | null
    CreatedAt: Date | null
  }

  export type SuperadminCountAggregateOutputType = {
    SuperAdminID: number
    FullName: number
    Email: number
    PasswordHash: number
    PhoneNumber: number
    CreatedAt: number
    _all: number
  }


  export type SuperadminAvgAggregateInputType = {
    SuperAdminID?: true
  }

  export type SuperadminSumAggregateInputType = {
    SuperAdminID?: true
  }

  export type SuperadminMinAggregateInputType = {
    SuperAdminID?: true
    FullName?: true
    Email?: true
    PasswordHash?: true
    PhoneNumber?: true
    CreatedAt?: true
  }

  export type SuperadminMaxAggregateInputType = {
    SuperAdminID?: true
    FullName?: true
    Email?: true
    PasswordHash?: true
    PhoneNumber?: true
    CreatedAt?: true
  }

  export type SuperadminCountAggregateInputType = {
    SuperAdminID?: true
    FullName?: true
    Email?: true
    PasswordHash?: true
    PhoneNumber?: true
    CreatedAt?: true
    _all?: true
  }

  export type SuperadminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which superadmin to aggregate.
     */
    where?: superadminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of superadmins to fetch.
     */
    orderBy?: superadminOrderByWithRelationInput | superadminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: superadminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` superadmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` superadmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned superadmins
    **/
    _count?: true | SuperadminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SuperadminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SuperadminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuperadminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuperadminMaxAggregateInputType
  }

  export type GetSuperadminAggregateType<T extends SuperadminAggregateArgs> = {
        [P in keyof T & keyof AggregateSuperadmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuperadmin[P]>
      : GetScalarType<T[P], AggregateSuperadmin[P]>
  }




  export type superadminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: superadminWhereInput
    orderBy?: superadminOrderByWithAggregationInput | superadminOrderByWithAggregationInput[]
    by: SuperadminScalarFieldEnum[] | SuperadminScalarFieldEnum
    having?: superadminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuperadminCountAggregateInputType | true
    _avg?: SuperadminAvgAggregateInputType
    _sum?: SuperadminSumAggregateInputType
    _min?: SuperadminMinAggregateInputType
    _max?: SuperadminMaxAggregateInputType
  }

  export type SuperadminGroupByOutputType = {
    SuperAdminID: number
    FullName: string | null
    Email: string | null
    PasswordHash: string | null
    PhoneNumber: string | null
    CreatedAt: Date | null
    _count: SuperadminCountAggregateOutputType | null
    _avg: SuperadminAvgAggregateOutputType | null
    _sum: SuperadminSumAggregateOutputType | null
    _min: SuperadminMinAggregateOutputType | null
    _max: SuperadminMaxAggregateOutputType | null
  }

  type GetSuperadminGroupByPayload<T extends superadminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuperadminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuperadminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuperadminGroupByOutputType[P]>
            : GetScalarType<T[P], SuperadminGroupByOutputType[P]>
        }
      >
    >


  export type superadminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SuperAdminID?: boolean
    FullName?: boolean
    Email?: boolean
    PasswordHash?: boolean
    PhoneNumber?: boolean
    CreatedAt?: boolean
  }, ExtArgs["result"]["superadmin"]>



  export type superadminSelectScalar = {
    SuperAdminID?: boolean
    FullName?: boolean
    Email?: boolean
    PasswordHash?: boolean
    PhoneNumber?: boolean
    CreatedAt?: boolean
  }

  export type superadminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"SuperAdminID" | "FullName" | "Email" | "PasswordHash" | "PhoneNumber" | "CreatedAt", ExtArgs["result"]["superadmin"]>

  export type $superadminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "superadmin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      SuperAdminID: number
      FullName: string | null
      Email: string | null
      PasswordHash: string | null
      PhoneNumber: string | null
      CreatedAt: Date | null
    }, ExtArgs["result"]["superadmin"]>
    composites: {}
  }

  type superadminGetPayload<S extends boolean | null | undefined | superadminDefaultArgs> = $Result.GetResult<Prisma.$superadminPayload, S>

  type superadminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<superadminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SuperadminCountAggregateInputType | true
    }

  export interface superadminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['superadmin'], meta: { name: 'superadmin' } }
    /**
     * Find zero or one Superadmin that matches the filter.
     * @param {superadminFindUniqueArgs} args - Arguments to find a Superadmin
     * @example
     * // Get one Superadmin
     * const superadmin = await prisma.superadmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends superadminFindUniqueArgs>(args: SelectSubset<T, superadminFindUniqueArgs<ExtArgs>>): Prisma__superadminClient<$Result.GetResult<Prisma.$superadminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Superadmin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {superadminFindUniqueOrThrowArgs} args - Arguments to find a Superadmin
     * @example
     * // Get one Superadmin
     * const superadmin = await prisma.superadmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends superadminFindUniqueOrThrowArgs>(args: SelectSubset<T, superadminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__superadminClient<$Result.GetResult<Prisma.$superadminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Superadmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superadminFindFirstArgs} args - Arguments to find a Superadmin
     * @example
     * // Get one Superadmin
     * const superadmin = await prisma.superadmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends superadminFindFirstArgs>(args?: SelectSubset<T, superadminFindFirstArgs<ExtArgs>>): Prisma__superadminClient<$Result.GetResult<Prisma.$superadminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Superadmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superadminFindFirstOrThrowArgs} args - Arguments to find a Superadmin
     * @example
     * // Get one Superadmin
     * const superadmin = await prisma.superadmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends superadminFindFirstOrThrowArgs>(args?: SelectSubset<T, superadminFindFirstOrThrowArgs<ExtArgs>>): Prisma__superadminClient<$Result.GetResult<Prisma.$superadminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Superadmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superadminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Superadmins
     * const superadmins = await prisma.superadmin.findMany()
     * 
     * // Get first 10 Superadmins
     * const superadmins = await prisma.superadmin.findMany({ take: 10 })
     * 
     * // Only select the `SuperAdminID`
     * const superadminWithSuperAdminIDOnly = await prisma.superadmin.findMany({ select: { SuperAdminID: true } })
     * 
     */
    findMany<T extends superadminFindManyArgs>(args?: SelectSubset<T, superadminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$superadminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Superadmin.
     * @param {superadminCreateArgs} args - Arguments to create a Superadmin.
     * @example
     * // Create one Superadmin
     * const Superadmin = await prisma.superadmin.create({
     *   data: {
     *     // ... data to create a Superadmin
     *   }
     * })
     * 
     */
    create<T extends superadminCreateArgs>(args: SelectSubset<T, superadminCreateArgs<ExtArgs>>): Prisma__superadminClient<$Result.GetResult<Prisma.$superadminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Superadmins.
     * @param {superadminCreateManyArgs} args - Arguments to create many Superadmins.
     * @example
     * // Create many Superadmins
     * const superadmin = await prisma.superadmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends superadminCreateManyArgs>(args?: SelectSubset<T, superadminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Superadmin.
     * @param {superadminDeleteArgs} args - Arguments to delete one Superadmin.
     * @example
     * // Delete one Superadmin
     * const Superadmin = await prisma.superadmin.delete({
     *   where: {
     *     // ... filter to delete one Superadmin
     *   }
     * })
     * 
     */
    delete<T extends superadminDeleteArgs>(args: SelectSubset<T, superadminDeleteArgs<ExtArgs>>): Prisma__superadminClient<$Result.GetResult<Prisma.$superadminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Superadmin.
     * @param {superadminUpdateArgs} args - Arguments to update one Superadmin.
     * @example
     * // Update one Superadmin
     * const superadmin = await prisma.superadmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends superadminUpdateArgs>(args: SelectSubset<T, superadminUpdateArgs<ExtArgs>>): Prisma__superadminClient<$Result.GetResult<Prisma.$superadminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Superadmins.
     * @param {superadminDeleteManyArgs} args - Arguments to filter Superadmins to delete.
     * @example
     * // Delete a few Superadmins
     * const { count } = await prisma.superadmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends superadminDeleteManyArgs>(args?: SelectSubset<T, superadminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Superadmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superadminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Superadmins
     * const superadmin = await prisma.superadmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends superadminUpdateManyArgs>(args: SelectSubset<T, superadminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Superadmin.
     * @param {superadminUpsertArgs} args - Arguments to update or create a Superadmin.
     * @example
     * // Update or create a Superadmin
     * const superadmin = await prisma.superadmin.upsert({
     *   create: {
     *     // ... data to create a Superadmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Superadmin we want to update
     *   }
     * })
     */
    upsert<T extends superadminUpsertArgs>(args: SelectSubset<T, superadminUpsertArgs<ExtArgs>>): Prisma__superadminClient<$Result.GetResult<Prisma.$superadminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Superadmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superadminCountArgs} args - Arguments to filter Superadmins to count.
     * @example
     * // Count the number of Superadmins
     * const count = await prisma.superadmin.count({
     *   where: {
     *     // ... the filter for the Superadmins we want to count
     *   }
     * })
    **/
    count<T extends superadminCountArgs>(
      args?: Subset<T, superadminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuperadminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Superadmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperadminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuperadminAggregateArgs>(args: Subset<T, SuperadminAggregateArgs>): Prisma.PrismaPromise<GetSuperadminAggregateType<T>>

    /**
     * Group by Superadmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superadminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends superadminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: superadminGroupByArgs['orderBy'] }
        : { orderBy?: superadminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, superadminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuperadminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the superadmin model
   */
  readonly fields: superadminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for superadmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__superadminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the superadmin model
   */
  interface superadminFieldRefs {
    readonly SuperAdminID: FieldRef<"superadmin", 'Int'>
    readonly FullName: FieldRef<"superadmin", 'String'>
    readonly Email: FieldRef<"superadmin", 'String'>
    readonly PasswordHash: FieldRef<"superadmin", 'String'>
    readonly PhoneNumber: FieldRef<"superadmin", 'String'>
    readonly CreatedAt: FieldRef<"superadmin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * superadmin findUnique
   */
  export type superadminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superadmin
     */
    select?: superadminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the superadmin
     */
    omit?: superadminOmit<ExtArgs> | null
    /**
     * Filter, which superadmin to fetch.
     */
    where: superadminWhereUniqueInput
  }

  /**
   * superadmin findUniqueOrThrow
   */
  export type superadminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superadmin
     */
    select?: superadminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the superadmin
     */
    omit?: superadminOmit<ExtArgs> | null
    /**
     * Filter, which superadmin to fetch.
     */
    where: superadminWhereUniqueInput
  }

  /**
   * superadmin findFirst
   */
  export type superadminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superadmin
     */
    select?: superadminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the superadmin
     */
    omit?: superadminOmit<ExtArgs> | null
    /**
     * Filter, which superadmin to fetch.
     */
    where?: superadminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of superadmins to fetch.
     */
    orderBy?: superadminOrderByWithRelationInput | superadminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for superadmins.
     */
    cursor?: superadminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` superadmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` superadmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of superadmins.
     */
    distinct?: SuperadminScalarFieldEnum | SuperadminScalarFieldEnum[]
  }

  /**
   * superadmin findFirstOrThrow
   */
  export type superadminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superadmin
     */
    select?: superadminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the superadmin
     */
    omit?: superadminOmit<ExtArgs> | null
    /**
     * Filter, which superadmin to fetch.
     */
    where?: superadminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of superadmins to fetch.
     */
    orderBy?: superadminOrderByWithRelationInput | superadminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for superadmins.
     */
    cursor?: superadminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` superadmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` superadmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of superadmins.
     */
    distinct?: SuperadminScalarFieldEnum | SuperadminScalarFieldEnum[]
  }

  /**
   * superadmin findMany
   */
  export type superadminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superadmin
     */
    select?: superadminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the superadmin
     */
    omit?: superadminOmit<ExtArgs> | null
    /**
     * Filter, which superadmins to fetch.
     */
    where?: superadminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of superadmins to fetch.
     */
    orderBy?: superadminOrderByWithRelationInput | superadminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing superadmins.
     */
    cursor?: superadminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` superadmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` superadmins.
     */
    skip?: number
    distinct?: SuperadminScalarFieldEnum | SuperadminScalarFieldEnum[]
  }

  /**
   * superadmin create
   */
  export type superadminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superadmin
     */
    select?: superadminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the superadmin
     */
    omit?: superadminOmit<ExtArgs> | null
    /**
     * The data needed to create a superadmin.
     */
    data?: XOR<superadminCreateInput, superadminUncheckedCreateInput>
  }

  /**
   * superadmin createMany
   */
  export type superadminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many superadmins.
     */
    data: superadminCreateManyInput | superadminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * superadmin update
   */
  export type superadminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superadmin
     */
    select?: superadminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the superadmin
     */
    omit?: superadminOmit<ExtArgs> | null
    /**
     * The data needed to update a superadmin.
     */
    data: XOR<superadminUpdateInput, superadminUncheckedUpdateInput>
    /**
     * Choose, which superadmin to update.
     */
    where: superadminWhereUniqueInput
  }

  /**
   * superadmin updateMany
   */
  export type superadminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update superadmins.
     */
    data: XOR<superadminUpdateManyMutationInput, superadminUncheckedUpdateManyInput>
    /**
     * Filter which superadmins to update
     */
    where?: superadminWhereInput
    /**
     * Limit how many superadmins to update.
     */
    limit?: number
  }

  /**
   * superadmin upsert
   */
  export type superadminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superadmin
     */
    select?: superadminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the superadmin
     */
    omit?: superadminOmit<ExtArgs> | null
    /**
     * The filter to search for the superadmin to update in case it exists.
     */
    where: superadminWhereUniqueInput
    /**
     * In case the superadmin found by the `where` argument doesn't exist, create a new superadmin with this data.
     */
    create: XOR<superadminCreateInput, superadminUncheckedCreateInput>
    /**
     * In case the superadmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<superadminUpdateInput, superadminUncheckedUpdateInput>
  }

  /**
   * superadmin delete
   */
  export type superadminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superadmin
     */
    select?: superadminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the superadmin
     */
    omit?: superadminOmit<ExtArgs> | null
    /**
     * Filter which superadmin to delete.
     */
    where: superadminWhereUniqueInput
  }

  /**
   * superadmin deleteMany
   */
  export type superadminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which superadmins to delete
     */
    where?: superadminWhereInput
    /**
     * Limit how many superadmins to delete.
     */
    limit?: number
  }

  /**
   * superadmin without action
   */
  export type superadminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superadmin
     */
    select?: superadminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the superadmin
     */
    omit?: superadminOmit<ExtArgs> | null
  }


  /**
   * Model universityeducations
   */

  export type AggregateUniversityeducations = {
    _count: UniversityeducationsCountAggregateOutputType | null
    _avg: UniversityeducationsAvgAggregateOutputType | null
    _sum: UniversityeducationsSumAggregateOutputType | null
    _min: UniversityeducationsMinAggregateOutputType | null
    _max: UniversityeducationsMaxAggregateOutputType | null
  }

  export type UniversityeducationsAvgAggregateOutputType = {
    UE_ID: number | null
    ApplicationID: number | null
    FromYear: number | null
    ToYear: number | null
    YearObtained: number | null
  }

  export type UniversityeducationsSumAggregateOutputType = {
    UE_ID: number | null
    ApplicationID: number | null
    FromYear: number | null
    ToYear: number | null
    YearObtained: number | null
  }

  export type UniversityeducationsMinAggregateOutputType = {
    UE_ID: number | null
    ApplicationID: number | null
    DegreeOrDiploma: string | null
    Institute: string | null
    FromYear: number | null
    ToYear: number | null
    Class: string | null
    YearObtained: number | null
    IndexNumber: string | null
  }

  export type UniversityeducationsMaxAggregateOutputType = {
    UE_ID: number | null
    ApplicationID: number | null
    DegreeOrDiploma: string | null
    Institute: string | null
    FromYear: number | null
    ToYear: number | null
    Class: string | null
    YearObtained: number | null
    IndexNumber: string | null
  }

  export type UniversityeducationsCountAggregateOutputType = {
    UE_ID: number
    ApplicationID: number
    DegreeOrDiploma: number
    Institute: number
    FromYear: number
    ToYear: number
    Class: number
    YearObtained: number
    IndexNumber: number
    _all: number
  }


  export type UniversityeducationsAvgAggregateInputType = {
    UE_ID?: true
    ApplicationID?: true
    FromYear?: true
    ToYear?: true
    YearObtained?: true
  }

  export type UniversityeducationsSumAggregateInputType = {
    UE_ID?: true
    ApplicationID?: true
    FromYear?: true
    ToYear?: true
    YearObtained?: true
  }

  export type UniversityeducationsMinAggregateInputType = {
    UE_ID?: true
    ApplicationID?: true
    DegreeOrDiploma?: true
    Institute?: true
    FromYear?: true
    ToYear?: true
    Class?: true
    YearObtained?: true
    IndexNumber?: true
  }

  export type UniversityeducationsMaxAggregateInputType = {
    UE_ID?: true
    ApplicationID?: true
    DegreeOrDiploma?: true
    Institute?: true
    FromYear?: true
    ToYear?: true
    Class?: true
    YearObtained?: true
    IndexNumber?: true
  }

  export type UniversityeducationsCountAggregateInputType = {
    UE_ID?: true
    ApplicationID?: true
    DegreeOrDiploma?: true
    Institute?: true
    FromYear?: true
    ToYear?: true
    Class?: true
    YearObtained?: true
    IndexNumber?: true
    _all?: true
  }

  export type UniversityeducationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which universityeducations to aggregate.
     */
    where?: universityeducationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of universityeducations to fetch.
     */
    orderBy?: universityeducationsOrderByWithRelationInput | universityeducationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: universityeducationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` universityeducations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` universityeducations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned universityeducations
    **/
    _count?: true | UniversityeducationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UniversityeducationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UniversityeducationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UniversityeducationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UniversityeducationsMaxAggregateInputType
  }

  export type GetUniversityeducationsAggregateType<T extends UniversityeducationsAggregateArgs> = {
        [P in keyof T & keyof AggregateUniversityeducations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUniversityeducations[P]>
      : GetScalarType<T[P], AggregateUniversityeducations[P]>
  }




  export type universityeducationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: universityeducationsWhereInput
    orderBy?: universityeducationsOrderByWithAggregationInput | universityeducationsOrderByWithAggregationInput[]
    by: UniversityeducationsScalarFieldEnum[] | UniversityeducationsScalarFieldEnum
    having?: universityeducationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UniversityeducationsCountAggregateInputType | true
    _avg?: UniversityeducationsAvgAggregateInputType
    _sum?: UniversityeducationsSumAggregateInputType
    _min?: UniversityeducationsMinAggregateInputType
    _max?: UniversityeducationsMaxAggregateInputType
  }

  export type UniversityeducationsGroupByOutputType = {
    UE_ID: number
    ApplicationID: number | null
    DegreeOrDiploma: string | null
    Institute: string | null
    FromYear: number | null
    ToYear: number | null
    Class: string | null
    YearObtained: number | null
    IndexNumber: string | null
    _count: UniversityeducationsCountAggregateOutputType | null
    _avg: UniversityeducationsAvgAggregateOutputType | null
    _sum: UniversityeducationsSumAggregateOutputType | null
    _min: UniversityeducationsMinAggregateOutputType | null
    _max: UniversityeducationsMaxAggregateOutputType | null
  }

  type GetUniversityeducationsGroupByPayload<T extends universityeducationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UniversityeducationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UniversityeducationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UniversityeducationsGroupByOutputType[P]>
            : GetScalarType<T[P], UniversityeducationsGroupByOutputType[P]>
        }
      >
    >


  export type universityeducationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    UE_ID?: boolean
    ApplicationID?: boolean
    DegreeOrDiploma?: boolean
    Institute?: boolean
    FromYear?: boolean
    ToYear?: boolean
    Class?: boolean
    YearObtained?: boolean
    IndexNumber?: boolean
    application?: boolean | universityeducations$applicationArgs<ExtArgs>
  }, ExtArgs["result"]["universityeducations"]>



  export type universityeducationsSelectScalar = {
    UE_ID?: boolean
    ApplicationID?: boolean
    DegreeOrDiploma?: boolean
    Institute?: boolean
    FromYear?: boolean
    ToYear?: boolean
    Class?: boolean
    YearObtained?: boolean
    IndexNumber?: boolean
  }

  export type universityeducationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"UE_ID" | "ApplicationID" | "DegreeOrDiploma" | "Institute" | "FromYear" | "ToYear" | "Class" | "YearObtained" | "IndexNumber", ExtArgs["result"]["universityeducations"]>
  export type universityeducationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | universityeducations$applicationArgs<ExtArgs>
  }

  export type $universityeducationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "universityeducations"
    objects: {
      application: Prisma.$applicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      UE_ID: number
      ApplicationID: number | null
      DegreeOrDiploma: string | null
      Institute: string | null
      FromYear: number | null
      ToYear: number | null
      Class: string | null
      YearObtained: number | null
      IndexNumber: string | null
    }, ExtArgs["result"]["universityeducations"]>
    composites: {}
  }

  type universityeducationsGetPayload<S extends boolean | null | undefined | universityeducationsDefaultArgs> = $Result.GetResult<Prisma.$universityeducationsPayload, S>

  type universityeducationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<universityeducationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UniversityeducationsCountAggregateInputType | true
    }

  export interface universityeducationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['universityeducations'], meta: { name: 'universityeducations' } }
    /**
     * Find zero or one Universityeducations that matches the filter.
     * @param {universityeducationsFindUniqueArgs} args - Arguments to find a Universityeducations
     * @example
     * // Get one Universityeducations
     * const universityeducations = await prisma.universityeducations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends universityeducationsFindUniqueArgs>(args: SelectSubset<T, universityeducationsFindUniqueArgs<ExtArgs>>): Prisma__universityeducationsClient<$Result.GetResult<Prisma.$universityeducationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Universityeducations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {universityeducationsFindUniqueOrThrowArgs} args - Arguments to find a Universityeducations
     * @example
     * // Get one Universityeducations
     * const universityeducations = await prisma.universityeducations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends universityeducationsFindUniqueOrThrowArgs>(args: SelectSubset<T, universityeducationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__universityeducationsClient<$Result.GetResult<Prisma.$universityeducationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Universityeducations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {universityeducationsFindFirstArgs} args - Arguments to find a Universityeducations
     * @example
     * // Get one Universityeducations
     * const universityeducations = await prisma.universityeducations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends universityeducationsFindFirstArgs>(args?: SelectSubset<T, universityeducationsFindFirstArgs<ExtArgs>>): Prisma__universityeducationsClient<$Result.GetResult<Prisma.$universityeducationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Universityeducations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {universityeducationsFindFirstOrThrowArgs} args - Arguments to find a Universityeducations
     * @example
     * // Get one Universityeducations
     * const universityeducations = await prisma.universityeducations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends universityeducationsFindFirstOrThrowArgs>(args?: SelectSubset<T, universityeducationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__universityeducationsClient<$Result.GetResult<Prisma.$universityeducationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Universityeducations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {universityeducationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Universityeducations
     * const universityeducations = await prisma.universityeducations.findMany()
     * 
     * // Get first 10 Universityeducations
     * const universityeducations = await prisma.universityeducations.findMany({ take: 10 })
     * 
     * // Only select the `UE_ID`
     * const universityeducationsWithUE_IDOnly = await prisma.universityeducations.findMany({ select: { UE_ID: true } })
     * 
     */
    findMany<T extends universityeducationsFindManyArgs>(args?: SelectSubset<T, universityeducationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$universityeducationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Universityeducations.
     * @param {universityeducationsCreateArgs} args - Arguments to create a Universityeducations.
     * @example
     * // Create one Universityeducations
     * const Universityeducations = await prisma.universityeducations.create({
     *   data: {
     *     // ... data to create a Universityeducations
     *   }
     * })
     * 
     */
    create<T extends universityeducationsCreateArgs>(args: SelectSubset<T, universityeducationsCreateArgs<ExtArgs>>): Prisma__universityeducationsClient<$Result.GetResult<Prisma.$universityeducationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Universityeducations.
     * @param {universityeducationsCreateManyArgs} args - Arguments to create many Universityeducations.
     * @example
     * // Create many Universityeducations
     * const universityeducations = await prisma.universityeducations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends universityeducationsCreateManyArgs>(args?: SelectSubset<T, universityeducationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Universityeducations.
     * @param {universityeducationsDeleteArgs} args - Arguments to delete one Universityeducations.
     * @example
     * // Delete one Universityeducations
     * const Universityeducations = await prisma.universityeducations.delete({
     *   where: {
     *     // ... filter to delete one Universityeducations
     *   }
     * })
     * 
     */
    delete<T extends universityeducationsDeleteArgs>(args: SelectSubset<T, universityeducationsDeleteArgs<ExtArgs>>): Prisma__universityeducationsClient<$Result.GetResult<Prisma.$universityeducationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Universityeducations.
     * @param {universityeducationsUpdateArgs} args - Arguments to update one Universityeducations.
     * @example
     * // Update one Universityeducations
     * const universityeducations = await prisma.universityeducations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends universityeducationsUpdateArgs>(args: SelectSubset<T, universityeducationsUpdateArgs<ExtArgs>>): Prisma__universityeducationsClient<$Result.GetResult<Prisma.$universityeducationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Universityeducations.
     * @param {universityeducationsDeleteManyArgs} args - Arguments to filter Universityeducations to delete.
     * @example
     * // Delete a few Universityeducations
     * const { count } = await prisma.universityeducations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends universityeducationsDeleteManyArgs>(args?: SelectSubset<T, universityeducationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Universityeducations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {universityeducationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Universityeducations
     * const universityeducations = await prisma.universityeducations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends universityeducationsUpdateManyArgs>(args: SelectSubset<T, universityeducationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Universityeducations.
     * @param {universityeducationsUpsertArgs} args - Arguments to update or create a Universityeducations.
     * @example
     * // Update or create a Universityeducations
     * const universityeducations = await prisma.universityeducations.upsert({
     *   create: {
     *     // ... data to create a Universityeducations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Universityeducations we want to update
     *   }
     * })
     */
    upsert<T extends universityeducationsUpsertArgs>(args: SelectSubset<T, universityeducationsUpsertArgs<ExtArgs>>): Prisma__universityeducationsClient<$Result.GetResult<Prisma.$universityeducationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Universityeducations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {universityeducationsCountArgs} args - Arguments to filter Universityeducations to count.
     * @example
     * // Count the number of Universityeducations
     * const count = await prisma.universityeducations.count({
     *   where: {
     *     // ... the filter for the Universityeducations we want to count
     *   }
     * })
    **/
    count<T extends universityeducationsCountArgs>(
      args?: Subset<T, universityeducationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UniversityeducationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Universityeducations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityeducationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UniversityeducationsAggregateArgs>(args: Subset<T, UniversityeducationsAggregateArgs>): Prisma.PrismaPromise<GetUniversityeducationsAggregateType<T>>

    /**
     * Group by Universityeducations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {universityeducationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends universityeducationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: universityeducationsGroupByArgs['orderBy'] }
        : { orderBy?: universityeducationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, universityeducationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUniversityeducationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the universityeducations model
   */
  readonly fields: universityeducationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for universityeducations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__universityeducationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends universityeducations$applicationArgs<ExtArgs> = {}>(args?: Subset<T, universityeducations$applicationArgs<ExtArgs>>): Prisma__applicationClient<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the universityeducations model
   */
  interface universityeducationsFieldRefs {
    readonly UE_ID: FieldRef<"universityeducations", 'Int'>
    readonly ApplicationID: FieldRef<"universityeducations", 'Int'>
    readonly DegreeOrDiploma: FieldRef<"universityeducations", 'String'>
    readonly Institute: FieldRef<"universityeducations", 'String'>
    readonly FromYear: FieldRef<"universityeducations", 'Int'>
    readonly ToYear: FieldRef<"universityeducations", 'Int'>
    readonly Class: FieldRef<"universityeducations", 'String'>
    readonly YearObtained: FieldRef<"universityeducations", 'Int'>
    readonly IndexNumber: FieldRef<"universityeducations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * universityeducations findUnique
   */
  export type universityeducationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the universityeducations
     */
    select?: universityeducationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the universityeducations
     */
    omit?: universityeducationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: universityeducationsInclude<ExtArgs> | null
    /**
     * Filter, which universityeducations to fetch.
     */
    where: universityeducationsWhereUniqueInput
  }

  /**
   * universityeducations findUniqueOrThrow
   */
  export type universityeducationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the universityeducations
     */
    select?: universityeducationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the universityeducations
     */
    omit?: universityeducationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: universityeducationsInclude<ExtArgs> | null
    /**
     * Filter, which universityeducations to fetch.
     */
    where: universityeducationsWhereUniqueInput
  }

  /**
   * universityeducations findFirst
   */
  export type universityeducationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the universityeducations
     */
    select?: universityeducationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the universityeducations
     */
    omit?: universityeducationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: universityeducationsInclude<ExtArgs> | null
    /**
     * Filter, which universityeducations to fetch.
     */
    where?: universityeducationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of universityeducations to fetch.
     */
    orderBy?: universityeducationsOrderByWithRelationInput | universityeducationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for universityeducations.
     */
    cursor?: universityeducationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` universityeducations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` universityeducations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of universityeducations.
     */
    distinct?: UniversityeducationsScalarFieldEnum | UniversityeducationsScalarFieldEnum[]
  }

  /**
   * universityeducations findFirstOrThrow
   */
  export type universityeducationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the universityeducations
     */
    select?: universityeducationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the universityeducations
     */
    omit?: universityeducationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: universityeducationsInclude<ExtArgs> | null
    /**
     * Filter, which universityeducations to fetch.
     */
    where?: universityeducationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of universityeducations to fetch.
     */
    orderBy?: universityeducationsOrderByWithRelationInput | universityeducationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for universityeducations.
     */
    cursor?: universityeducationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` universityeducations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` universityeducations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of universityeducations.
     */
    distinct?: UniversityeducationsScalarFieldEnum | UniversityeducationsScalarFieldEnum[]
  }

  /**
   * universityeducations findMany
   */
  export type universityeducationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the universityeducations
     */
    select?: universityeducationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the universityeducations
     */
    omit?: universityeducationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: universityeducationsInclude<ExtArgs> | null
    /**
     * Filter, which universityeducations to fetch.
     */
    where?: universityeducationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of universityeducations to fetch.
     */
    orderBy?: universityeducationsOrderByWithRelationInput | universityeducationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing universityeducations.
     */
    cursor?: universityeducationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` universityeducations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` universityeducations.
     */
    skip?: number
    distinct?: UniversityeducationsScalarFieldEnum | UniversityeducationsScalarFieldEnum[]
  }

  /**
   * universityeducations create
   */
  export type universityeducationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the universityeducations
     */
    select?: universityeducationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the universityeducations
     */
    omit?: universityeducationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: universityeducationsInclude<ExtArgs> | null
    /**
     * The data needed to create a universityeducations.
     */
    data?: XOR<universityeducationsCreateInput, universityeducationsUncheckedCreateInput>
  }

  /**
   * universityeducations createMany
   */
  export type universityeducationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many universityeducations.
     */
    data: universityeducationsCreateManyInput | universityeducationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * universityeducations update
   */
  export type universityeducationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the universityeducations
     */
    select?: universityeducationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the universityeducations
     */
    omit?: universityeducationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: universityeducationsInclude<ExtArgs> | null
    /**
     * The data needed to update a universityeducations.
     */
    data: XOR<universityeducationsUpdateInput, universityeducationsUncheckedUpdateInput>
    /**
     * Choose, which universityeducations to update.
     */
    where: universityeducationsWhereUniqueInput
  }

  /**
   * universityeducations updateMany
   */
  export type universityeducationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update universityeducations.
     */
    data: XOR<universityeducationsUpdateManyMutationInput, universityeducationsUncheckedUpdateManyInput>
    /**
     * Filter which universityeducations to update
     */
    where?: universityeducationsWhereInput
    /**
     * Limit how many universityeducations to update.
     */
    limit?: number
  }

  /**
   * universityeducations upsert
   */
  export type universityeducationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the universityeducations
     */
    select?: universityeducationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the universityeducations
     */
    omit?: universityeducationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: universityeducationsInclude<ExtArgs> | null
    /**
     * The filter to search for the universityeducations to update in case it exists.
     */
    where: universityeducationsWhereUniqueInput
    /**
     * In case the universityeducations found by the `where` argument doesn't exist, create a new universityeducations with this data.
     */
    create: XOR<universityeducationsCreateInput, universityeducationsUncheckedCreateInput>
    /**
     * In case the universityeducations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<universityeducationsUpdateInput, universityeducationsUncheckedUpdateInput>
  }

  /**
   * universityeducations delete
   */
  export type universityeducationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the universityeducations
     */
    select?: universityeducationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the universityeducations
     */
    omit?: universityeducationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: universityeducationsInclude<ExtArgs> | null
    /**
     * Filter which universityeducations to delete.
     */
    where: universityeducationsWhereUniqueInput
  }

  /**
   * universityeducations deleteMany
   */
  export type universityeducationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which universityeducations to delete
     */
    where?: universityeducationsWhereInput
    /**
     * Limit how many universityeducations to delete.
     */
    limit?: number
  }

  /**
   * universityeducations.application
   */
  export type universityeducations$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    where?: applicationWhereInput
  }

  /**
   * universityeducations without action
   */
  export type universityeducationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the universityeducations
     */
    select?: universityeducationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the universityeducations
     */
    omit?: universityeducationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: universityeducationsInclude<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    UserID: number | null
  }

  export type UserSumAggregateOutputType = {
    UserID: number | null
  }

  export type UserMinAggregateOutputType = {
    UserID: number | null
    FullName: string | null
    Email: string | null
    PasswordHash: string | null
    NIC: string | null
    PhoneNumber: string | null
    Address: string | null
    AccountStatus: $Enums.user_AccountStatus | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    UserID: number | null
    FullName: string | null
    Email: string | null
    PasswordHash: string | null
    NIC: string | null
    PhoneNumber: string | null
    Address: string | null
    AccountStatus: $Enums.user_AccountStatus | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    UserID: number
    FullName: number
    Email: number
    PasswordHash: number
    NIC: number
    PhoneNumber: number
    Address: number
    AccountStatus: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    UserID?: true
  }

  export type UserSumAggregateInputType = {
    UserID?: true
  }

  export type UserMinAggregateInputType = {
    UserID?: true
    FullName?: true
    Email?: true
    PasswordHash?: true
    NIC?: true
    PhoneNumber?: true
    Address?: true
    AccountStatus?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    UserID?: true
    FullName?: true
    Email?: true
    PasswordHash?: true
    NIC?: true
    PhoneNumber?: true
    Address?: true
    AccountStatus?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type UserCountAggregateInputType = {
    UserID?: true
    FullName?: true
    Email?: true
    PasswordHash?: true
    NIC?: true
    PhoneNumber?: true
    Address?: true
    AccountStatus?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    UserID: number
    FullName: string | null
    Email: string | null
    PasswordHash: string | null
    NIC: string | null
    PhoneNumber: string | null
    Address: string | null
    AccountStatus: $Enums.user_AccountStatus | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    UserID?: boolean
    FullName?: boolean
    Email?: boolean
    PasswordHash?: boolean
    NIC?: boolean
    PhoneNumber?: boolean
    Address?: boolean
    AccountStatus?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    application?: boolean | user$applicationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type userSelectScalar = {
    UserID?: boolean
    FullName?: boolean
    Email?: boolean
    PasswordHash?: boolean
    NIC?: boolean
    PhoneNumber?: boolean
    Address?: boolean
    AccountStatus?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"UserID" | "FullName" | "Email" | "PasswordHash" | "NIC" | "PhoneNumber" | "Address" | "AccountStatus" | "CreatedAt" | "UpdatedAt", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | user$applicationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      application: Prisma.$applicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      UserID: number
      FullName: string | null
      Email: string | null
      PasswordHash: string | null
      NIC: string | null
      PhoneNumber: string | null
      Address: string | null
      AccountStatus: $Enums.user_AccountStatus | null
      CreatedAt: Date | null
      UpdatedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `UserID`
     * const userWithUserIDOnly = await prisma.user.findMany({ select: { UserID: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends user$applicationArgs<ExtArgs> = {}>(args?: Subset<T, user$applicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly UserID: FieldRef<"user", 'Int'>
    readonly FullName: FieldRef<"user", 'String'>
    readonly Email: FieldRef<"user", 'String'>
    readonly PasswordHash: FieldRef<"user", 'String'>
    readonly NIC: FieldRef<"user", 'String'>
    readonly PhoneNumber: FieldRef<"user", 'String'>
    readonly Address: FieldRef<"user", 'String'>
    readonly AccountStatus: FieldRef<"user", 'user_AccountStatus'>
    readonly CreatedAt: FieldRef<"user", 'DateTime'>
    readonly UpdatedAt: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data?: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user.application
   */
  export type user$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the application
     */
    select?: applicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the application
     */
    omit?: applicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationInclude<ExtArgs> | null
    where?: applicationWhereInput
    orderBy?: applicationOrderByWithRelationInput | applicationOrderByWithRelationInput[]
    cursor?: applicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdditionalinfoScalarFieldEnum: {
    InfoID: 'InfoID',
    ApplicationID: 'ApplicationID',
    Content: 'Content'
  };

  export type AdditionalinfoScalarFieldEnum = (typeof AdditionalinfoScalarFieldEnum)[keyof typeof AdditionalinfoScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    AdminID: 'AdminID',
    FullName: 'FullName',
    Email: 'Email',
    PasswordHash: 'PasswordHash',
    Department: 'Department',
    PhoneNumber: 'PhoneNumber',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt',
    isDeleted: 'isDeleted'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const ApplicationScalarFieldEnum: {
    ApplicationID: 'ApplicationID',
    UserID: 'UserID',
    JobID: 'JobID',
    SubmissionDate: 'SubmissionDate',
    Status: 'Status',
    Remarks: 'Remarks'
  };

  export type ApplicationScalarFieldEnum = (typeof ApplicationScalarFieldEnum)[keyof typeof ApplicationScalarFieldEnum]


  export const ApplicationattachmentsScalarFieldEnum: {
    AttachmentID: 'AttachmentID',
    ApplicationID: 'ApplicationID',
    FileType: 'FileType',
    FilePath: 'FilePath',
    UploadedAt: 'UploadedAt'
  };

  export type ApplicationattachmentsScalarFieldEnum = (typeof ApplicationattachmentsScalarFieldEnum)[keyof typeof ApplicationattachmentsScalarFieldEnum]


  export const ApplicationgeneraldetailsScalarFieldEnum: {
    ApplicationID: 'ApplicationID',
    PostApplied: 'PostApplied',
    FullName: 'FullName',
    NameWithInitials: 'NameWithInitials',
    NIC: 'NIC',
    DOB: 'DOB',
    Gender: 'Gender',
    PhoneNumber: 'PhoneNumber',
    Email: 'Email',
    PresentAddress: 'PresentAddress',
    PermanentAddress: 'PermanentAddress',
    CivilStatus: 'CivilStatus',
    CitizenshipType: 'CitizenshipType',
    CitizenshipDetails: 'CitizenshipDetails',
    EthnicityOrReligion: 'EthnicityOrReligion'
  };

  export type ApplicationgeneraldetailsScalarFieldEnum = (typeof ApplicationgeneraldetailsScalarFieldEnum)[keyof typeof ApplicationgeneraldetailsScalarFieldEnum]


  export const ApplicationreferencesScalarFieldEnum: {
    ReferenceID: 'ReferenceID',
    ApplicationID: 'ApplicationID',
    Name: 'Name',
    Designation: 'Designation',
    Address: 'Address'
  };

  export type ApplicationreferencesScalarFieldEnum = (typeof ApplicationreferencesScalarFieldEnum)[keyof typeof ApplicationreferencesScalarFieldEnum]


  export const ApplicationtemplateScalarFieldEnum: {
    TemplateID: 'TemplateID',
    Type: 'Type',
    FilePath: 'FilePath',
    UploadedBy: 'UploadedBy',
    UploadDate: 'UploadDate'
  };

  export type ApplicationtemplateScalarFieldEnum = (typeof ApplicationtemplateScalarFieldEnum)[keyof typeof ApplicationtemplateScalarFieldEnum]


  export const AuditlogScalarFieldEnum: {
    LogID: 'LogID',
    ActorID: 'ActorID',
    ActorRole: 'ActorRole',
    Action: 'Action',
    Timestamp: 'Timestamp',
    Details: 'Details'
  };

  export type AuditlogScalarFieldEnum = (typeof AuditlogScalarFieldEnum)[keyof typeof AuditlogScalarFieldEnum]


  export const EmploymenthistoriesScalarFieldEnum: {
    EmploymentID: 'EmploymentID',
    ApplicationID: 'ApplicationID',
    PostHeld: 'PostHeld',
    Institution: 'Institution',
    FromDate: 'FromDate',
    ToDate: 'ToDate',
    LastSalary: 'LastSalary'
  };

  export type EmploymenthistoriesScalarFieldEnum = (typeof EmploymenthistoriesScalarFieldEnum)[keyof typeof EmploymenthistoriesScalarFieldEnum]


  export const ExperiencedetailsScalarFieldEnum: {
    ExperienceID: 'ExperienceID',
    ApplicationID: 'ApplicationID',
    Description: 'Description'
  };

  export type ExperiencedetailsScalarFieldEnum = (typeof ExperiencedetailsScalarFieldEnum)[keyof typeof ExperiencedetailsScalarFieldEnum]


  export const Gce_al_resultsScalarFieldEnum: {
    AL_ID: 'AL_ID',
    ApplicationID: 'ApplicationID',
    Subject: 'Subject',
    Grade: 'Grade'
  };

  export type Gce_al_resultsScalarFieldEnum = (typeof Gce_al_resultsScalarFieldEnum)[keyof typeof Gce_al_resultsScalarFieldEnum]


  export const Gce_ol_resultsScalarFieldEnum: {
    OL_ID: 'OL_ID',
    ApplicationID: 'ApplicationID',
    Subject: 'Subject',
    Grade: 'Grade'
  };

  export type Gce_ol_resultsScalarFieldEnum = (typeof Gce_ol_resultsScalarFieldEnum)[keyof typeof Gce_ol_resultsScalarFieldEnum]


  export const JobvacancyScalarFieldEnum: {
    JobID: 'JobID',
    Title: 'Title',
    Description: 'Description',
    Type: 'Type',
    Department: 'Department',
    Level: 'Level',
    PostedBy: 'PostedBy',
    PostedDate: 'PostedDate',
    ExpiryDate: 'ExpiryDate',
    Status: 'Status',
    TemplateID: 'TemplateID'
  };

  export type JobvacancyScalarFieldEnum = (typeof JobvacancyScalarFieldEnum)[keyof typeof JobvacancyScalarFieldEnum]


  export const LanguageproficienciesScalarFieldEnum: {
    LangProfID: 'LangProfID',
    ApplicationID: 'ApplicationID',
    Language: 'Language',
    CanSpeak: 'CanSpeak',
    CanRead: 'CanRead',
    CanWrite: 'CanWrite',
    CanTeach: 'CanTeach'
  };

  export type LanguageproficienciesScalarFieldEnum = (typeof LanguageproficienciesScalarFieldEnum)[keyof typeof LanguageproficienciesScalarFieldEnum]


  export const ProfessionalqualificationsScalarFieldEnum: {
    PQ_ID: 'PQ_ID',
    ApplicationID: 'ApplicationID',
    Institution: 'Institution',
    QualificationName: 'QualificationName',
    FromYear: 'FromYear',
    ToYear: 'ToYear',
    ResultOrExamPassed: 'ResultOrExamPassed'
  };

  export type ProfessionalqualificationsScalarFieldEnum = (typeof ProfessionalqualificationsScalarFieldEnum)[keyof typeof ProfessionalqualificationsScalarFieldEnum]


  export const ResearchandpublicationsScalarFieldEnum: {
    ResearchID: 'ResearchID',
    ApplicationID: 'ApplicationID',
    Description: 'Description'
  };

  export type ResearchandpublicationsScalarFieldEnum = (typeof ResearchandpublicationsScalarFieldEnum)[keyof typeof ResearchandpublicationsScalarFieldEnum]


  export const SpecialqualificationsScalarFieldEnum: {
    SpecialQualID: 'SpecialQualID',
    ApplicationID: 'ApplicationID',
    Description: 'Description'
  };

  export type SpecialqualificationsScalarFieldEnum = (typeof SpecialqualificationsScalarFieldEnum)[keyof typeof SpecialqualificationsScalarFieldEnum]


  export const SuperadminScalarFieldEnum: {
    SuperAdminID: 'SuperAdminID',
    FullName: 'FullName',
    Email: 'Email',
    PasswordHash: 'PasswordHash',
    PhoneNumber: 'PhoneNumber',
    CreatedAt: 'CreatedAt'
  };

  export type SuperadminScalarFieldEnum = (typeof SuperadminScalarFieldEnum)[keyof typeof SuperadminScalarFieldEnum]


  export const UniversityeducationsScalarFieldEnum: {
    UE_ID: 'UE_ID',
    ApplicationID: 'ApplicationID',
    DegreeOrDiploma: 'DegreeOrDiploma',
    Institute: 'Institute',
    FromYear: 'FromYear',
    ToYear: 'ToYear',
    Class: 'Class',
    YearObtained: 'YearObtained',
    IndexNumber: 'IndexNumber'
  };

  export type UniversityeducationsScalarFieldEnum = (typeof UniversityeducationsScalarFieldEnum)[keyof typeof UniversityeducationsScalarFieldEnum]


  export const UserScalarFieldEnum: {
    UserID: 'UserID',
    FullName: 'FullName',
    Email: 'Email',
    PasswordHash: 'PasswordHash',
    NIC: 'NIC',
    PhoneNumber: 'PhoneNumber',
    Address: 'Address',
    AccountStatus: 'AccountStatus',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const additionalinfoOrderByRelevanceFieldEnum: {
    Content: 'Content'
  };

  export type additionalinfoOrderByRelevanceFieldEnum = (typeof additionalinfoOrderByRelevanceFieldEnum)[keyof typeof additionalinfoOrderByRelevanceFieldEnum]


  export const adminOrderByRelevanceFieldEnum: {
    FullName: 'FullName',
    Email: 'Email',
    PasswordHash: 'PasswordHash',
    Department: 'Department',
    PhoneNumber: 'PhoneNumber'
  };

  export type adminOrderByRelevanceFieldEnum = (typeof adminOrderByRelevanceFieldEnum)[keyof typeof adminOrderByRelevanceFieldEnum]


  export const applicationOrderByRelevanceFieldEnum: {
    Remarks: 'Remarks'
  };

  export type applicationOrderByRelevanceFieldEnum = (typeof applicationOrderByRelevanceFieldEnum)[keyof typeof applicationOrderByRelevanceFieldEnum]


  export const applicationattachmentsOrderByRelevanceFieldEnum: {
    FileType: 'FileType',
    FilePath: 'FilePath'
  };

  export type applicationattachmentsOrderByRelevanceFieldEnum = (typeof applicationattachmentsOrderByRelevanceFieldEnum)[keyof typeof applicationattachmentsOrderByRelevanceFieldEnum]


  export const applicationgeneraldetailsOrderByRelevanceFieldEnum: {
    PostApplied: 'PostApplied',
    FullName: 'FullName',
    NameWithInitials: 'NameWithInitials',
    NIC: 'NIC',
    PhoneNumber: 'PhoneNumber',
    Email: 'Email',
    PresentAddress: 'PresentAddress',
    PermanentAddress: 'PermanentAddress',
    CivilStatus: 'CivilStatus',
    CitizenshipDetails: 'CitizenshipDetails',
    EthnicityOrReligion: 'EthnicityOrReligion'
  };

  export type applicationgeneraldetailsOrderByRelevanceFieldEnum = (typeof applicationgeneraldetailsOrderByRelevanceFieldEnum)[keyof typeof applicationgeneraldetailsOrderByRelevanceFieldEnum]


  export const applicationreferencesOrderByRelevanceFieldEnum: {
    Name: 'Name',
    Designation: 'Designation',
    Address: 'Address'
  };

  export type applicationreferencesOrderByRelevanceFieldEnum = (typeof applicationreferencesOrderByRelevanceFieldEnum)[keyof typeof applicationreferencesOrderByRelevanceFieldEnum]


  export const applicationtemplateOrderByRelevanceFieldEnum: {
    FilePath: 'FilePath'
  };

  export type applicationtemplateOrderByRelevanceFieldEnum = (typeof applicationtemplateOrderByRelevanceFieldEnum)[keyof typeof applicationtemplateOrderByRelevanceFieldEnum]


  export const auditlogOrderByRelevanceFieldEnum: {
    Action: 'Action',
    Details: 'Details'
  };

  export type auditlogOrderByRelevanceFieldEnum = (typeof auditlogOrderByRelevanceFieldEnum)[keyof typeof auditlogOrderByRelevanceFieldEnum]


  export const employmenthistoriesOrderByRelevanceFieldEnum: {
    PostHeld: 'PostHeld',
    Institution: 'Institution'
  };

  export type employmenthistoriesOrderByRelevanceFieldEnum = (typeof employmenthistoriesOrderByRelevanceFieldEnum)[keyof typeof employmenthistoriesOrderByRelevanceFieldEnum]


  export const experiencedetailsOrderByRelevanceFieldEnum: {
    Description: 'Description'
  };

  export type experiencedetailsOrderByRelevanceFieldEnum = (typeof experiencedetailsOrderByRelevanceFieldEnum)[keyof typeof experiencedetailsOrderByRelevanceFieldEnum]


  export const gce_al_resultsOrderByRelevanceFieldEnum: {
    Subject: 'Subject',
    Grade: 'Grade'
  };

  export type gce_al_resultsOrderByRelevanceFieldEnum = (typeof gce_al_resultsOrderByRelevanceFieldEnum)[keyof typeof gce_al_resultsOrderByRelevanceFieldEnum]


  export const gce_ol_resultsOrderByRelevanceFieldEnum: {
    Subject: 'Subject',
    Grade: 'Grade'
  };

  export type gce_ol_resultsOrderByRelevanceFieldEnum = (typeof gce_ol_resultsOrderByRelevanceFieldEnum)[keyof typeof gce_ol_resultsOrderByRelevanceFieldEnum]


  export const jobvacancyOrderByRelevanceFieldEnum: {
    Title: 'Title',
    Description: 'Description',
    Department: 'Department',
    Level: 'Level'
  };

  export type jobvacancyOrderByRelevanceFieldEnum = (typeof jobvacancyOrderByRelevanceFieldEnum)[keyof typeof jobvacancyOrderByRelevanceFieldEnum]


  export const languageproficienciesOrderByRelevanceFieldEnum: {
    Language: 'Language'
  };

  export type languageproficienciesOrderByRelevanceFieldEnum = (typeof languageproficienciesOrderByRelevanceFieldEnum)[keyof typeof languageproficienciesOrderByRelevanceFieldEnum]


  export const professionalqualificationsOrderByRelevanceFieldEnum: {
    Institution: 'Institution',
    QualificationName: 'QualificationName',
    ResultOrExamPassed: 'ResultOrExamPassed'
  };

  export type professionalqualificationsOrderByRelevanceFieldEnum = (typeof professionalqualificationsOrderByRelevanceFieldEnum)[keyof typeof professionalqualificationsOrderByRelevanceFieldEnum]


  export const researchandpublicationsOrderByRelevanceFieldEnum: {
    Description: 'Description'
  };

  export type researchandpublicationsOrderByRelevanceFieldEnum = (typeof researchandpublicationsOrderByRelevanceFieldEnum)[keyof typeof researchandpublicationsOrderByRelevanceFieldEnum]


  export const specialqualificationsOrderByRelevanceFieldEnum: {
    Description: 'Description'
  };

  export type specialqualificationsOrderByRelevanceFieldEnum = (typeof specialqualificationsOrderByRelevanceFieldEnum)[keyof typeof specialqualificationsOrderByRelevanceFieldEnum]


  export const superadminOrderByRelevanceFieldEnum: {
    FullName: 'FullName',
    Email: 'Email',
    PasswordHash: 'PasswordHash',
    PhoneNumber: 'PhoneNumber'
  };

  export type superadminOrderByRelevanceFieldEnum = (typeof superadminOrderByRelevanceFieldEnum)[keyof typeof superadminOrderByRelevanceFieldEnum]


  export const universityeducationsOrderByRelevanceFieldEnum: {
    DegreeOrDiploma: 'DegreeOrDiploma',
    Institute: 'Institute',
    Class: 'Class',
    IndexNumber: 'IndexNumber'
  };

  export type universityeducationsOrderByRelevanceFieldEnum = (typeof universityeducationsOrderByRelevanceFieldEnum)[keyof typeof universityeducationsOrderByRelevanceFieldEnum]


  export const userOrderByRelevanceFieldEnum: {
    FullName: 'FullName',
    Email: 'Email',
    PasswordHash: 'PasswordHash',
    NIC: 'NIC',
    PhoneNumber: 'PhoneNumber',
    Address: 'Address'
  };

  export type userOrderByRelevanceFieldEnum = (typeof userOrderByRelevanceFieldEnum)[keyof typeof userOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'application_Status'
   */
  export type Enumapplication_StatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'application_Status'>
    


  /**
   * Reference to a field of type 'applicationgeneraldetails_Gender'
   */
  export type Enumapplicationgeneraldetails_GenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'applicationgeneraldetails_Gender'>
    


  /**
   * Reference to a field of type 'applicationgeneraldetails_CitizenshipType'
   */
  export type Enumapplicationgeneraldetails_CitizenshipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'applicationgeneraldetails_CitizenshipType'>
    


  /**
   * Reference to a field of type 'applicationtemplate_Type'
   */
  export type Enumapplicationtemplate_TypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'applicationtemplate_Type'>
    


  /**
   * Reference to a field of type 'auditlog_ActorRole'
   */
  export type Enumauditlog_ActorRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'auditlog_ActorRole'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'jobvacancy_Type'
   */
  export type Enumjobvacancy_TypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'jobvacancy_Type'>
    


  /**
   * Reference to a field of type 'jobvacancy_Status'
   */
  export type Enumjobvacancy_StatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'jobvacancy_Status'>
    


  /**
   * Reference to a field of type 'languageproficiencies_CanSpeak'
   */
  export type Enumlanguageproficiencies_CanSpeakFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'languageproficiencies_CanSpeak'>
    


  /**
   * Reference to a field of type 'languageproficiencies_CanRead'
   */
  export type Enumlanguageproficiencies_CanReadFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'languageproficiencies_CanRead'>
    


  /**
   * Reference to a field of type 'languageproficiencies_CanWrite'
   */
  export type Enumlanguageproficiencies_CanWriteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'languageproficiencies_CanWrite'>
    


  /**
   * Reference to a field of type 'languageproficiencies_CanTeach'
   */
  export type Enumlanguageproficiencies_CanTeachFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'languageproficiencies_CanTeach'>
    


  /**
   * Reference to a field of type 'user_AccountStatus'
   */
  export type Enumuser_AccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_AccountStatus'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type additionalinfoWhereInput = {
    AND?: additionalinfoWhereInput | additionalinfoWhereInput[]
    OR?: additionalinfoWhereInput[]
    NOT?: additionalinfoWhereInput | additionalinfoWhereInput[]
    InfoID?: IntFilter<"additionalinfo"> | number
    ApplicationID?: IntNullableFilter<"additionalinfo"> | number | null
    Content?: StringNullableFilter<"additionalinfo"> | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }

  export type additionalinfoOrderByWithRelationInput = {
    InfoID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    Content?: SortOrderInput | SortOrder
    application?: applicationOrderByWithRelationInput
    _relevance?: additionalinfoOrderByRelevanceInput
  }

  export type additionalinfoWhereUniqueInput = Prisma.AtLeast<{
    InfoID?: number
    AND?: additionalinfoWhereInput | additionalinfoWhereInput[]
    OR?: additionalinfoWhereInput[]
    NOT?: additionalinfoWhereInput | additionalinfoWhereInput[]
    ApplicationID?: IntNullableFilter<"additionalinfo"> | number | null
    Content?: StringNullableFilter<"additionalinfo"> | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }, "InfoID">

  export type additionalinfoOrderByWithAggregationInput = {
    InfoID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    Content?: SortOrderInput | SortOrder
    _count?: additionalinfoCountOrderByAggregateInput
    _avg?: additionalinfoAvgOrderByAggregateInput
    _max?: additionalinfoMaxOrderByAggregateInput
    _min?: additionalinfoMinOrderByAggregateInput
    _sum?: additionalinfoSumOrderByAggregateInput
  }

  export type additionalinfoScalarWhereWithAggregatesInput = {
    AND?: additionalinfoScalarWhereWithAggregatesInput | additionalinfoScalarWhereWithAggregatesInput[]
    OR?: additionalinfoScalarWhereWithAggregatesInput[]
    NOT?: additionalinfoScalarWhereWithAggregatesInput | additionalinfoScalarWhereWithAggregatesInput[]
    InfoID?: IntWithAggregatesFilter<"additionalinfo"> | number
    ApplicationID?: IntNullableWithAggregatesFilter<"additionalinfo"> | number | null
    Content?: StringNullableWithAggregatesFilter<"additionalinfo"> | string | null
  }

  export type adminWhereInput = {
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    AdminID?: IntFilter<"admin"> | number
    FullName?: StringNullableFilter<"admin"> | string | null
    Email?: StringNullableFilter<"admin"> | string | null
    PasswordHash?: StringNullableFilter<"admin"> | string | null
    Department?: StringNullableFilter<"admin"> | string | null
    PhoneNumber?: StringNullableFilter<"admin"> | string | null
    CreatedAt?: DateTimeNullableFilter<"admin"> | Date | string | null
    UpdatedAt?: DateTimeNullableFilter<"admin"> | Date | string | null
    isDeleted?: BoolNullableFilter<"admin"> | boolean | null
    applicationtemplate?: ApplicationtemplateListRelationFilter
    jobvacancy?: JobvacancyListRelationFilter
  }

  export type adminOrderByWithRelationInput = {
    AdminID?: SortOrder
    FullName?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    PasswordHash?: SortOrderInput | SortOrder
    Department?: SortOrderInput | SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrderInput | SortOrder
    applicationtemplate?: applicationtemplateOrderByRelationAggregateInput
    jobvacancy?: jobvacancyOrderByRelationAggregateInput
    _relevance?: adminOrderByRelevanceInput
  }

  export type adminWhereUniqueInput = Prisma.AtLeast<{
    AdminID?: number
    Email?: string
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    FullName?: StringNullableFilter<"admin"> | string | null
    PasswordHash?: StringNullableFilter<"admin"> | string | null
    Department?: StringNullableFilter<"admin"> | string | null
    PhoneNumber?: StringNullableFilter<"admin"> | string | null
    CreatedAt?: DateTimeNullableFilter<"admin"> | Date | string | null
    UpdatedAt?: DateTimeNullableFilter<"admin"> | Date | string | null
    isDeleted?: BoolNullableFilter<"admin"> | boolean | null
    applicationtemplate?: ApplicationtemplateListRelationFilter
    jobvacancy?: JobvacancyListRelationFilter
  }, "AdminID" | "Email">

  export type adminOrderByWithAggregationInput = {
    AdminID?: SortOrder
    FullName?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    PasswordHash?: SortOrderInput | SortOrder
    Department?: SortOrderInput | SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrderInput | SortOrder
    _count?: adminCountOrderByAggregateInput
    _avg?: adminAvgOrderByAggregateInput
    _max?: adminMaxOrderByAggregateInput
    _min?: adminMinOrderByAggregateInput
    _sum?: adminSumOrderByAggregateInput
  }

  export type adminScalarWhereWithAggregatesInput = {
    AND?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    OR?: adminScalarWhereWithAggregatesInput[]
    NOT?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    AdminID?: IntWithAggregatesFilter<"admin"> | number
    FullName?: StringNullableWithAggregatesFilter<"admin"> | string | null
    Email?: StringNullableWithAggregatesFilter<"admin"> | string | null
    PasswordHash?: StringNullableWithAggregatesFilter<"admin"> | string | null
    Department?: StringNullableWithAggregatesFilter<"admin"> | string | null
    PhoneNumber?: StringNullableWithAggregatesFilter<"admin"> | string | null
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"admin"> | Date | string | null
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"admin"> | Date | string | null
    isDeleted?: BoolNullableWithAggregatesFilter<"admin"> | boolean | null
  }

  export type applicationWhereInput = {
    AND?: applicationWhereInput | applicationWhereInput[]
    OR?: applicationWhereInput[]
    NOT?: applicationWhereInput | applicationWhereInput[]
    ApplicationID?: IntFilter<"application"> | number
    UserID?: IntNullableFilter<"application"> | number | null
    JobID?: IntNullableFilter<"application"> | number | null
    SubmissionDate?: DateTimeNullableFilter<"application"> | Date | string | null
    Status?: Enumapplication_StatusNullableFilter<"application"> | $Enums.application_Status | null
    Remarks?: StringNullableFilter<"application"> | string | null
    additionalinfo?: AdditionalinfoListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    jobvacancy?: XOR<JobvacancyNullableScalarRelationFilter, jobvacancyWhereInput> | null
    applicationattachments?: ApplicationattachmentsListRelationFilter
    applicationgeneraldetails?: XOR<ApplicationgeneraldetailsNullableScalarRelationFilter, applicationgeneraldetailsWhereInput> | null
    applicationreferences?: ApplicationreferencesListRelationFilter
    employmenthistories?: EmploymenthistoriesListRelationFilter
    experiencedetails?: ExperiencedetailsListRelationFilter
    gce_al_results?: Gce_al_resultsListRelationFilter
    gce_ol_results?: Gce_ol_resultsListRelationFilter
    languageproficiencies?: LanguageproficienciesListRelationFilter
    professionalqualifications?: ProfessionalqualificationsListRelationFilter
    researchandpublications?: ResearchandpublicationsListRelationFilter
    specialqualifications?: SpecialqualificationsListRelationFilter
    universityeducations?: UniversityeducationsListRelationFilter
  }

  export type applicationOrderByWithRelationInput = {
    ApplicationID?: SortOrder
    UserID?: SortOrderInput | SortOrder
    JobID?: SortOrderInput | SortOrder
    SubmissionDate?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    Remarks?: SortOrderInput | SortOrder
    additionalinfo?: additionalinfoOrderByRelationAggregateInput
    user?: userOrderByWithRelationInput
    jobvacancy?: jobvacancyOrderByWithRelationInput
    applicationattachments?: applicationattachmentsOrderByRelationAggregateInput
    applicationgeneraldetails?: applicationgeneraldetailsOrderByWithRelationInput
    applicationreferences?: applicationreferencesOrderByRelationAggregateInput
    employmenthistories?: employmenthistoriesOrderByRelationAggregateInput
    experiencedetails?: experiencedetailsOrderByRelationAggregateInput
    gce_al_results?: gce_al_resultsOrderByRelationAggregateInput
    gce_ol_results?: gce_ol_resultsOrderByRelationAggregateInput
    languageproficiencies?: languageproficienciesOrderByRelationAggregateInput
    professionalqualifications?: professionalqualificationsOrderByRelationAggregateInput
    researchandpublications?: researchandpublicationsOrderByRelationAggregateInput
    specialqualifications?: specialqualificationsOrderByRelationAggregateInput
    universityeducations?: universityeducationsOrderByRelationAggregateInput
    _relevance?: applicationOrderByRelevanceInput
  }

  export type applicationWhereUniqueInput = Prisma.AtLeast<{
    ApplicationID?: number
    AND?: applicationWhereInput | applicationWhereInput[]
    OR?: applicationWhereInput[]
    NOT?: applicationWhereInput | applicationWhereInput[]
    UserID?: IntNullableFilter<"application"> | number | null
    JobID?: IntNullableFilter<"application"> | number | null
    SubmissionDate?: DateTimeNullableFilter<"application"> | Date | string | null
    Status?: Enumapplication_StatusNullableFilter<"application"> | $Enums.application_Status | null
    Remarks?: StringNullableFilter<"application"> | string | null
    additionalinfo?: AdditionalinfoListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    jobvacancy?: XOR<JobvacancyNullableScalarRelationFilter, jobvacancyWhereInput> | null
    applicationattachments?: ApplicationattachmentsListRelationFilter
    applicationgeneraldetails?: XOR<ApplicationgeneraldetailsNullableScalarRelationFilter, applicationgeneraldetailsWhereInput> | null
    applicationreferences?: ApplicationreferencesListRelationFilter
    employmenthistories?: EmploymenthistoriesListRelationFilter
    experiencedetails?: ExperiencedetailsListRelationFilter
    gce_al_results?: Gce_al_resultsListRelationFilter
    gce_ol_results?: Gce_ol_resultsListRelationFilter
    languageproficiencies?: LanguageproficienciesListRelationFilter
    professionalqualifications?: ProfessionalqualificationsListRelationFilter
    researchandpublications?: ResearchandpublicationsListRelationFilter
    specialqualifications?: SpecialqualificationsListRelationFilter
    universityeducations?: UniversityeducationsListRelationFilter
  }, "ApplicationID">

  export type applicationOrderByWithAggregationInput = {
    ApplicationID?: SortOrder
    UserID?: SortOrderInput | SortOrder
    JobID?: SortOrderInput | SortOrder
    SubmissionDate?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    Remarks?: SortOrderInput | SortOrder
    _count?: applicationCountOrderByAggregateInput
    _avg?: applicationAvgOrderByAggregateInput
    _max?: applicationMaxOrderByAggregateInput
    _min?: applicationMinOrderByAggregateInput
    _sum?: applicationSumOrderByAggregateInput
  }

  export type applicationScalarWhereWithAggregatesInput = {
    AND?: applicationScalarWhereWithAggregatesInput | applicationScalarWhereWithAggregatesInput[]
    OR?: applicationScalarWhereWithAggregatesInput[]
    NOT?: applicationScalarWhereWithAggregatesInput | applicationScalarWhereWithAggregatesInput[]
    ApplicationID?: IntWithAggregatesFilter<"application"> | number
    UserID?: IntNullableWithAggregatesFilter<"application"> | number | null
    JobID?: IntNullableWithAggregatesFilter<"application"> | number | null
    SubmissionDate?: DateTimeNullableWithAggregatesFilter<"application"> | Date | string | null
    Status?: Enumapplication_StatusNullableWithAggregatesFilter<"application"> | $Enums.application_Status | null
    Remarks?: StringNullableWithAggregatesFilter<"application"> | string | null
  }

  export type applicationattachmentsWhereInput = {
    AND?: applicationattachmentsWhereInput | applicationattachmentsWhereInput[]
    OR?: applicationattachmentsWhereInput[]
    NOT?: applicationattachmentsWhereInput | applicationattachmentsWhereInput[]
    AttachmentID?: IntFilter<"applicationattachments"> | number
    ApplicationID?: IntNullableFilter<"applicationattachments"> | number | null
    FileType?: StringNullableFilter<"applicationattachments"> | string | null
    FilePath?: StringNullableFilter<"applicationattachments"> | string | null
    UploadedAt?: DateTimeNullableFilter<"applicationattachments"> | Date | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }

  export type applicationattachmentsOrderByWithRelationInput = {
    AttachmentID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    FileType?: SortOrderInput | SortOrder
    FilePath?: SortOrderInput | SortOrder
    UploadedAt?: SortOrderInput | SortOrder
    application?: applicationOrderByWithRelationInput
    _relevance?: applicationattachmentsOrderByRelevanceInput
  }

  export type applicationattachmentsWhereUniqueInput = Prisma.AtLeast<{
    AttachmentID?: number
    AND?: applicationattachmentsWhereInput | applicationattachmentsWhereInput[]
    OR?: applicationattachmentsWhereInput[]
    NOT?: applicationattachmentsWhereInput | applicationattachmentsWhereInput[]
    ApplicationID?: IntNullableFilter<"applicationattachments"> | number | null
    FileType?: StringNullableFilter<"applicationattachments"> | string | null
    FilePath?: StringNullableFilter<"applicationattachments"> | string | null
    UploadedAt?: DateTimeNullableFilter<"applicationattachments"> | Date | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }, "AttachmentID">

  export type applicationattachmentsOrderByWithAggregationInput = {
    AttachmentID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    FileType?: SortOrderInput | SortOrder
    FilePath?: SortOrderInput | SortOrder
    UploadedAt?: SortOrderInput | SortOrder
    _count?: applicationattachmentsCountOrderByAggregateInput
    _avg?: applicationattachmentsAvgOrderByAggregateInput
    _max?: applicationattachmentsMaxOrderByAggregateInput
    _min?: applicationattachmentsMinOrderByAggregateInput
    _sum?: applicationattachmentsSumOrderByAggregateInput
  }

  export type applicationattachmentsScalarWhereWithAggregatesInput = {
    AND?: applicationattachmentsScalarWhereWithAggregatesInput | applicationattachmentsScalarWhereWithAggregatesInput[]
    OR?: applicationattachmentsScalarWhereWithAggregatesInput[]
    NOT?: applicationattachmentsScalarWhereWithAggregatesInput | applicationattachmentsScalarWhereWithAggregatesInput[]
    AttachmentID?: IntWithAggregatesFilter<"applicationattachments"> | number
    ApplicationID?: IntNullableWithAggregatesFilter<"applicationattachments"> | number | null
    FileType?: StringNullableWithAggregatesFilter<"applicationattachments"> | string | null
    FilePath?: StringNullableWithAggregatesFilter<"applicationattachments"> | string | null
    UploadedAt?: DateTimeNullableWithAggregatesFilter<"applicationattachments"> | Date | string | null
  }

  export type applicationgeneraldetailsWhereInput = {
    AND?: applicationgeneraldetailsWhereInput | applicationgeneraldetailsWhereInput[]
    OR?: applicationgeneraldetailsWhereInput[]
    NOT?: applicationgeneraldetailsWhereInput | applicationgeneraldetailsWhereInput[]
    ApplicationID?: IntFilter<"applicationgeneraldetails"> | number
    PostApplied?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    FullName?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    NameWithInitials?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    NIC?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    DOB?: DateTimeNullableFilter<"applicationgeneraldetails"> | Date | string | null
    Gender?: Enumapplicationgeneraldetails_GenderNullableFilter<"applicationgeneraldetails"> | $Enums.applicationgeneraldetails_Gender | null
    PhoneNumber?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    Email?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    PresentAddress?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    PermanentAddress?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    CivilStatus?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    CitizenshipType?: Enumapplicationgeneraldetails_CitizenshipTypeNullableFilter<"applicationgeneraldetails"> | $Enums.applicationgeneraldetails_CitizenshipType | null
    CitizenshipDetails?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    EthnicityOrReligion?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    application?: XOR<ApplicationScalarRelationFilter, applicationWhereInput>
  }

  export type applicationgeneraldetailsOrderByWithRelationInput = {
    ApplicationID?: SortOrder
    PostApplied?: SortOrderInput | SortOrder
    FullName?: SortOrderInput | SortOrder
    NameWithInitials?: SortOrderInput | SortOrder
    NIC?: SortOrderInput | SortOrder
    DOB?: SortOrderInput | SortOrder
    Gender?: SortOrderInput | SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    PresentAddress?: SortOrderInput | SortOrder
    PermanentAddress?: SortOrderInput | SortOrder
    CivilStatus?: SortOrderInput | SortOrder
    CitizenshipType?: SortOrderInput | SortOrder
    CitizenshipDetails?: SortOrderInput | SortOrder
    EthnicityOrReligion?: SortOrderInput | SortOrder
    application?: applicationOrderByWithRelationInput
    _relevance?: applicationgeneraldetailsOrderByRelevanceInput
  }

  export type applicationgeneraldetailsWhereUniqueInput = Prisma.AtLeast<{
    ApplicationID?: number
    AND?: applicationgeneraldetailsWhereInput | applicationgeneraldetailsWhereInput[]
    OR?: applicationgeneraldetailsWhereInput[]
    NOT?: applicationgeneraldetailsWhereInput | applicationgeneraldetailsWhereInput[]
    PostApplied?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    FullName?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    NameWithInitials?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    NIC?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    DOB?: DateTimeNullableFilter<"applicationgeneraldetails"> | Date | string | null
    Gender?: Enumapplicationgeneraldetails_GenderNullableFilter<"applicationgeneraldetails"> | $Enums.applicationgeneraldetails_Gender | null
    PhoneNumber?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    Email?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    PresentAddress?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    PermanentAddress?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    CivilStatus?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    CitizenshipType?: Enumapplicationgeneraldetails_CitizenshipTypeNullableFilter<"applicationgeneraldetails"> | $Enums.applicationgeneraldetails_CitizenshipType | null
    CitizenshipDetails?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    EthnicityOrReligion?: StringNullableFilter<"applicationgeneraldetails"> | string | null
    application?: XOR<ApplicationScalarRelationFilter, applicationWhereInput>
  }, "ApplicationID">

  export type applicationgeneraldetailsOrderByWithAggregationInput = {
    ApplicationID?: SortOrder
    PostApplied?: SortOrderInput | SortOrder
    FullName?: SortOrderInput | SortOrder
    NameWithInitials?: SortOrderInput | SortOrder
    NIC?: SortOrderInput | SortOrder
    DOB?: SortOrderInput | SortOrder
    Gender?: SortOrderInput | SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    PresentAddress?: SortOrderInput | SortOrder
    PermanentAddress?: SortOrderInput | SortOrder
    CivilStatus?: SortOrderInput | SortOrder
    CitizenshipType?: SortOrderInput | SortOrder
    CitizenshipDetails?: SortOrderInput | SortOrder
    EthnicityOrReligion?: SortOrderInput | SortOrder
    _count?: applicationgeneraldetailsCountOrderByAggregateInput
    _avg?: applicationgeneraldetailsAvgOrderByAggregateInput
    _max?: applicationgeneraldetailsMaxOrderByAggregateInput
    _min?: applicationgeneraldetailsMinOrderByAggregateInput
    _sum?: applicationgeneraldetailsSumOrderByAggregateInput
  }

  export type applicationgeneraldetailsScalarWhereWithAggregatesInput = {
    AND?: applicationgeneraldetailsScalarWhereWithAggregatesInput | applicationgeneraldetailsScalarWhereWithAggregatesInput[]
    OR?: applicationgeneraldetailsScalarWhereWithAggregatesInput[]
    NOT?: applicationgeneraldetailsScalarWhereWithAggregatesInput | applicationgeneraldetailsScalarWhereWithAggregatesInput[]
    ApplicationID?: IntWithAggregatesFilter<"applicationgeneraldetails"> | number
    PostApplied?: StringNullableWithAggregatesFilter<"applicationgeneraldetails"> | string | null
    FullName?: StringNullableWithAggregatesFilter<"applicationgeneraldetails"> | string | null
    NameWithInitials?: StringNullableWithAggregatesFilter<"applicationgeneraldetails"> | string | null
    NIC?: StringNullableWithAggregatesFilter<"applicationgeneraldetails"> | string | null
    DOB?: DateTimeNullableWithAggregatesFilter<"applicationgeneraldetails"> | Date | string | null
    Gender?: Enumapplicationgeneraldetails_GenderNullableWithAggregatesFilter<"applicationgeneraldetails"> | $Enums.applicationgeneraldetails_Gender | null
    PhoneNumber?: StringNullableWithAggregatesFilter<"applicationgeneraldetails"> | string | null
    Email?: StringNullableWithAggregatesFilter<"applicationgeneraldetails"> | string | null
    PresentAddress?: StringNullableWithAggregatesFilter<"applicationgeneraldetails"> | string | null
    PermanentAddress?: StringNullableWithAggregatesFilter<"applicationgeneraldetails"> | string | null
    CivilStatus?: StringNullableWithAggregatesFilter<"applicationgeneraldetails"> | string | null
    CitizenshipType?: Enumapplicationgeneraldetails_CitizenshipTypeNullableWithAggregatesFilter<"applicationgeneraldetails"> | $Enums.applicationgeneraldetails_CitizenshipType | null
    CitizenshipDetails?: StringNullableWithAggregatesFilter<"applicationgeneraldetails"> | string | null
    EthnicityOrReligion?: StringNullableWithAggregatesFilter<"applicationgeneraldetails"> | string | null
  }

  export type applicationreferencesWhereInput = {
    AND?: applicationreferencesWhereInput | applicationreferencesWhereInput[]
    OR?: applicationreferencesWhereInput[]
    NOT?: applicationreferencesWhereInput | applicationreferencesWhereInput[]
    ReferenceID?: IntFilter<"applicationreferences"> | number
    ApplicationID?: IntNullableFilter<"applicationreferences"> | number | null
    Name?: StringNullableFilter<"applicationreferences"> | string | null
    Designation?: StringNullableFilter<"applicationreferences"> | string | null
    Address?: StringNullableFilter<"applicationreferences"> | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }

  export type applicationreferencesOrderByWithRelationInput = {
    ReferenceID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    Name?: SortOrderInput | SortOrder
    Designation?: SortOrderInput | SortOrder
    Address?: SortOrderInput | SortOrder
    application?: applicationOrderByWithRelationInput
    _relevance?: applicationreferencesOrderByRelevanceInput
  }

  export type applicationreferencesWhereUniqueInput = Prisma.AtLeast<{
    ReferenceID?: number
    AND?: applicationreferencesWhereInput | applicationreferencesWhereInput[]
    OR?: applicationreferencesWhereInput[]
    NOT?: applicationreferencesWhereInput | applicationreferencesWhereInput[]
    ApplicationID?: IntNullableFilter<"applicationreferences"> | number | null
    Name?: StringNullableFilter<"applicationreferences"> | string | null
    Designation?: StringNullableFilter<"applicationreferences"> | string | null
    Address?: StringNullableFilter<"applicationreferences"> | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }, "ReferenceID">

  export type applicationreferencesOrderByWithAggregationInput = {
    ReferenceID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    Name?: SortOrderInput | SortOrder
    Designation?: SortOrderInput | SortOrder
    Address?: SortOrderInput | SortOrder
    _count?: applicationreferencesCountOrderByAggregateInput
    _avg?: applicationreferencesAvgOrderByAggregateInput
    _max?: applicationreferencesMaxOrderByAggregateInput
    _min?: applicationreferencesMinOrderByAggregateInput
    _sum?: applicationreferencesSumOrderByAggregateInput
  }

  export type applicationreferencesScalarWhereWithAggregatesInput = {
    AND?: applicationreferencesScalarWhereWithAggregatesInput | applicationreferencesScalarWhereWithAggregatesInput[]
    OR?: applicationreferencesScalarWhereWithAggregatesInput[]
    NOT?: applicationreferencesScalarWhereWithAggregatesInput | applicationreferencesScalarWhereWithAggregatesInput[]
    ReferenceID?: IntWithAggregatesFilter<"applicationreferences"> | number
    ApplicationID?: IntNullableWithAggregatesFilter<"applicationreferences"> | number | null
    Name?: StringNullableWithAggregatesFilter<"applicationreferences"> | string | null
    Designation?: StringNullableWithAggregatesFilter<"applicationreferences"> | string | null
    Address?: StringNullableWithAggregatesFilter<"applicationreferences"> | string | null
  }

  export type applicationtemplateWhereInput = {
    AND?: applicationtemplateWhereInput | applicationtemplateWhereInput[]
    OR?: applicationtemplateWhereInput[]
    NOT?: applicationtemplateWhereInput | applicationtemplateWhereInput[]
    TemplateID?: IntFilter<"applicationtemplate"> | number
    Type?: Enumapplicationtemplate_TypeNullableFilter<"applicationtemplate"> | $Enums.applicationtemplate_Type | null
    FilePath?: StringNullableFilter<"applicationtemplate"> | string | null
    UploadedBy?: IntNullableFilter<"applicationtemplate"> | number | null
    UploadDate?: DateTimeNullableFilter<"applicationtemplate"> | Date | string | null
    admin?: XOR<AdminNullableScalarRelationFilter, adminWhereInput> | null
    jobvacancy?: JobvacancyListRelationFilter
  }

  export type applicationtemplateOrderByWithRelationInput = {
    TemplateID?: SortOrder
    Type?: SortOrderInput | SortOrder
    FilePath?: SortOrderInput | SortOrder
    UploadedBy?: SortOrderInput | SortOrder
    UploadDate?: SortOrderInput | SortOrder
    admin?: adminOrderByWithRelationInput
    jobvacancy?: jobvacancyOrderByRelationAggregateInput
    _relevance?: applicationtemplateOrderByRelevanceInput
  }

  export type applicationtemplateWhereUniqueInput = Prisma.AtLeast<{
    TemplateID?: number
    AND?: applicationtemplateWhereInput | applicationtemplateWhereInput[]
    OR?: applicationtemplateWhereInput[]
    NOT?: applicationtemplateWhereInput | applicationtemplateWhereInput[]
    Type?: Enumapplicationtemplate_TypeNullableFilter<"applicationtemplate"> | $Enums.applicationtemplate_Type | null
    FilePath?: StringNullableFilter<"applicationtemplate"> | string | null
    UploadedBy?: IntNullableFilter<"applicationtemplate"> | number | null
    UploadDate?: DateTimeNullableFilter<"applicationtemplate"> | Date | string | null
    admin?: XOR<AdminNullableScalarRelationFilter, adminWhereInput> | null
    jobvacancy?: JobvacancyListRelationFilter
  }, "TemplateID">

  export type applicationtemplateOrderByWithAggregationInput = {
    TemplateID?: SortOrder
    Type?: SortOrderInput | SortOrder
    FilePath?: SortOrderInput | SortOrder
    UploadedBy?: SortOrderInput | SortOrder
    UploadDate?: SortOrderInput | SortOrder
    _count?: applicationtemplateCountOrderByAggregateInput
    _avg?: applicationtemplateAvgOrderByAggregateInput
    _max?: applicationtemplateMaxOrderByAggregateInput
    _min?: applicationtemplateMinOrderByAggregateInput
    _sum?: applicationtemplateSumOrderByAggregateInput
  }

  export type applicationtemplateScalarWhereWithAggregatesInput = {
    AND?: applicationtemplateScalarWhereWithAggregatesInput | applicationtemplateScalarWhereWithAggregatesInput[]
    OR?: applicationtemplateScalarWhereWithAggregatesInput[]
    NOT?: applicationtemplateScalarWhereWithAggregatesInput | applicationtemplateScalarWhereWithAggregatesInput[]
    TemplateID?: IntWithAggregatesFilter<"applicationtemplate"> | number
    Type?: Enumapplicationtemplate_TypeNullableWithAggregatesFilter<"applicationtemplate"> | $Enums.applicationtemplate_Type | null
    FilePath?: StringNullableWithAggregatesFilter<"applicationtemplate"> | string | null
    UploadedBy?: IntNullableWithAggregatesFilter<"applicationtemplate"> | number | null
    UploadDate?: DateTimeNullableWithAggregatesFilter<"applicationtemplate"> | Date | string | null
  }

  export type auditlogWhereInput = {
    AND?: auditlogWhereInput | auditlogWhereInput[]
    OR?: auditlogWhereInput[]
    NOT?: auditlogWhereInput | auditlogWhereInput[]
    LogID?: IntFilter<"auditlog"> | number
    ActorID?: IntNullableFilter<"auditlog"> | number | null
    ActorRole?: Enumauditlog_ActorRoleNullableFilter<"auditlog"> | $Enums.auditlog_ActorRole | null
    Action?: StringNullableFilter<"auditlog"> | string | null
    Timestamp?: DateTimeNullableFilter<"auditlog"> | Date | string | null
    Details?: StringNullableFilter<"auditlog"> | string | null
  }

  export type auditlogOrderByWithRelationInput = {
    LogID?: SortOrder
    ActorID?: SortOrderInput | SortOrder
    ActorRole?: SortOrderInput | SortOrder
    Action?: SortOrderInput | SortOrder
    Timestamp?: SortOrderInput | SortOrder
    Details?: SortOrderInput | SortOrder
    _relevance?: auditlogOrderByRelevanceInput
  }

  export type auditlogWhereUniqueInput = Prisma.AtLeast<{
    LogID?: number
    AND?: auditlogWhereInput | auditlogWhereInput[]
    OR?: auditlogWhereInput[]
    NOT?: auditlogWhereInput | auditlogWhereInput[]
    ActorID?: IntNullableFilter<"auditlog"> | number | null
    ActorRole?: Enumauditlog_ActorRoleNullableFilter<"auditlog"> | $Enums.auditlog_ActorRole | null
    Action?: StringNullableFilter<"auditlog"> | string | null
    Timestamp?: DateTimeNullableFilter<"auditlog"> | Date | string | null
    Details?: StringNullableFilter<"auditlog"> | string | null
  }, "LogID">

  export type auditlogOrderByWithAggregationInput = {
    LogID?: SortOrder
    ActorID?: SortOrderInput | SortOrder
    ActorRole?: SortOrderInput | SortOrder
    Action?: SortOrderInput | SortOrder
    Timestamp?: SortOrderInput | SortOrder
    Details?: SortOrderInput | SortOrder
    _count?: auditlogCountOrderByAggregateInput
    _avg?: auditlogAvgOrderByAggregateInput
    _max?: auditlogMaxOrderByAggregateInput
    _min?: auditlogMinOrderByAggregateInput
    _sum?: auditlogSumOrderByAggregateInput
  }

  export type auditlogScalarWhereWithAggregatesInput = {
    AND?: auditlogScalarWhereWithAggregatesInput | auditlogScalarWhereWithAggregatesInput[]
    OR?: auditlogScalarWhereWithAggregatesInput[]
    NOT?: auditlogScalarWhereWithAggregatesInput | auditlogScalarWhereWithAggregatesInput[]
    LogID?: IntWithAggregatesFilter<"auditlog"> | number
    ActorID?: IntNullableWithAggregatesFilter<"auditlog"> | number | null
    ActorRole?: Enumauditlog_ActorRoleNullableWithAggregatesFilter<"auditlog"> | $Enums.auditlog_ActorRole | null
    Action?: StringNullableWithAggregatesFilter<"auditlog"> | string | null
    Timestamp?: DateTimeNullableWithAggregatesFilter<"auditlog"> | Date | string | null
    Details?: StringNullableWithAggregatesFilter<"auditlog"> | string | null
  }

  export type employmenthistoriesWhereInput = {
    AND?: employmenthistoriesWhereInput | employmenthistoriesWhereInput[]
    OR?: employmenthistoriesWhereInput[]
    NOT?: employmenthistoriesWhereInput | employmenthistoriesWhereInput[]
    EmploymentID?: IntFilter<"employmenthistories"> | number
    ApplicationID?: IntNullableFilter<"employmenthistories"> | number | null
    PostHeld?: StringNullableFilter<"employmenthistories"> | string | null
    Institution?: StringNullableFilter<"employmenthistories"> | string | null
    FromDate?: DateTimeNullableFilter<"employmenthistories"> | Date | string | null
    ToDate?: DateTimeNullableFilter<"employmenthistories"> | Date | string | null
    LastSalary?: DecimalNullableFilter<"employmenthistories"> | Decimal | DecimalJsLike | number | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }

  export type employmenthistoriesOrderByWithRelationInput = {
    EmploymentID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    PostHeld?: SortOrderInput | SortOrder
    Institution?: SortOrderInput | SortOrder
    FromDate?: SortOrderInput | SortOrder
    ToDate?: SortOrderInput | SortOrder
    LastSalary?: SortOrderInput | SortOrder
    application?: applicationOrderByWithRelationInput
    _relevance?: employmenthistoriesOrderByRelevanceInput
  }

  export type employmenthistoriesWhereUniqueInput = Prisma.AtLeast<{
    EmploymentID?: number
    AND?: employmenthistoriesWhereInput | employmenthistoriesWhereInput[]
    OR?: employmenthistoriesWhereInput[]
    NOT?: employmenthistoriesWhereInput | employmenthistoriesWhereInput[]
    ApplicationID?: IntNullableFilter<"employmenthistories"> | number | null
    PostHeld?: StringNullableFilter<"employmenthistories"> | string | null
    Institution?: StringNullableFilter<"employmenthistories"> | string | null
    FromDate?: DateTimeNullableFilter<"employmenthistories"> | Date | string | null
    ToDate?: DateTimeNullableFilter<"employmenthistories"> | Date | string | null
    LastSalary?: DecimalNullableFilter<"employmenthistories"> | Decimal | DecimalJsLike | number | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }, "EmploymentID">

  export type employmenthistoriesOrderByWithAggregationInput = {
    EmploymentID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    PostHeld?: SortOrderInput | SortOrder
    Institution?: SortOrderInput | SortOrder
    FromDate?: SortOrderInput | SortOrder
    ToDate?: SortOrderInput | SortOrder
    LastSalary?: SortOrderInput | SortOrder
    _count?: employmenthistoriesCountOrderByAggregateInput
    _avg?: employmenthistoriesAvgOrderByAggregateInput
    _max?: employmenthistoriesMaxOrderByAggregateInput
    _min?: employmenthistoriesMinOrderByAggregateInput
    _sum?: employmenthistoriesSumOrderByAggregateInput
  }

  export type employmenthistoriesScalarWhereWithAggregatesInput = {
    AND?: employmenthistoriesScalarWhereWithAggregatesInput | employmenthistoriesScalarWhereWithAggregatesInput[]
    OR?: employmenthistoriesScalarWhereWithAggregatesInput[]
    NOT?: employmenthistoriesScalarWhereWithAggregatesInput | employmenthistoriesScalarWhereWithAggregatesInput[]
    EmploymentID?: IntWithAggregatesFilter<"employmenthistories"> | number
    ApplicationID?: IntNullableWithAggregatesFilter<"employmenthistories"> | number | null
    PostHeld?: StringNullableWithAggregatesFilter<"employmenthistories"> | string | null
    Institution?: StringNullableWithAggregatesFilter<"employmenthistories"> | string | null
    FromDate?: DateTimeNullableWithAggregatesFilter<"employmenthistories"> | Date | string | null
    ToDate?: DateTimeNullableWithAggregatesFilter<"employmenthistories"> | Date | string | null
    LastSalary?: DecimalNullableWithAggregatesFilter<"employmenthistories"> | Decimal | DecimalJsLike | number | string | null
  }

  export type experiencedetailsWhereInput = {
    AND?: experiencedetailsWhereInput | experiencedetailsWhereInput[]
    OR?: experiencedetailsWhereInput[]
    NOT?: experiencedetailsWhereInput | experiencedetailsWhereInput[]
    ExperienceID?: IntFilter<"experiencedetails"> | number
    ApplicationID?: IntNullableFilter<"experiencedetails"> | number | null
    Description?: StringNullableFilter<"experiencedetails"> | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }

  export type experiencedetailsOrderByWithRelationInput = {
    ExperienceID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    application?: applicationOrderByWithRelationInput
    _relevance?: experiencedetailsOrderByRelevanceInput
  }

  export type experiencedetailsWhereUniqueInput = Prisma.AtLeast<{
    ExperienceID?: number
    AND?: experiencedetailsWhereInput | experiencedetailsWhereInput[]
    OR?: experiencedetailsWhereInput[]
    NOT?: experiencedetailsWhereInput | experiencedetailsWhereInput[]
    ApplicationID?: IntNullableFilter<"experiencedetails"> | number | null
    Description?: StringNullableFilter<"experiencedetails"> | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }, "ExperienceID">

  export type experiencedetailsOrderByWithAggregationInput = {
    ExperienceID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    _count?: experiencedetailsCountOrderByAggregateInput
    _avg?: experiencedetailsAvgOrderByAggregateInput
    _max?: experiencedetailsMaxOrderByAggregateInput
    _min?: experiencedetailsMinOrderByAggregateInput
    _sum?: experiencedetailsSumOrderByAggregateInput
  }

  export type experiencedetailsScalarWhereWithAggregatesInput = {
    AND?: experiencedetailsScalarWhereWithAggregatesInput | experiencedetailsScalarWhereWithAggregatesInput[]
    OR?: experiencedetailsScalarWhereWithAggregatesInput[]
    NOT?: experiencedetailsScalarWhereWithAggregatesInput | experiencedetailsScalarWhereWithAggregatesInput[]
    ExperienceID?: IntWithAggregatesFilter<"experiencedetails"> | number
    ApplicationID?: IntNullableWithAggregatesFilter<"experiencedetails"> | number | null
    Description?: StringNullableWithAggregatesFilter<"experiencedetails"> | string | null
  }

  export type gce_al_resultsWhereInput = {
    AND?: gce_al_resultsWhereInput | gce_al_resultsWhereInput[]
    OR?: gce_al_resultsWhereInput[]
    NOT?: gce_al_resultsWhereInput | gce_al_resultsWhereInput[]
    AL_ID?: IntFilter<"gce_al_results"> | number
    ApplicationID?: IntNullableFilter<"gce_al_results"> | number | null
    Subject?: StringNullableFilter<"gce_al_results"> | string | null
    Grade?: StringNullableFilter<"gce_al_results"> | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }

  export type gce_al_resultsOrderByWithRelationInput = {
    AL_ID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    Subject?: SortOrderInput | SortOrder
    Grade?: SortOrderInput | SortOrder
    application?: applicationOrderByWithRelationInput
    _relevance?: gce_al_resultsOrderByRelevanceInput
  }

  export type gce_al_resultsWhereUniqueInput = Prisma.AtLeast<{
    AL_ID?: number
    AND?: gce_al_resultsWhereInput | gce_al_resultsWhereInput[]
    OR?: gce_al_resultsWhereInput[]
    NOT?: gce_al_resultsWhereInput | gce_al_resultsWhereInput[]
    ApplicationID?: IntNullableFilter<"gce_al_results"> | number | null
    Subject?: StringNullableFilter<"gce_al_results"> | string | null
    Grade?: StringNullableFilter<"gce_al_results"> | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }, "AL_ID">

  export type gce_al_resultsOrderByWithAggregationInput = {
    AL_ID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    Subject?: SortOrderInput | SortOrder
    Grade?: SortOrderInput | SortOrder
    _count?: gce_al_resultsCountOrderByAggregateInput
    _avg?: gce_al_resultsAvgOrderByAggregateInput
    _max?: gce_al_resultsMaxOrderByAggregateInput
    _min?: gce_al_resultsMinOrderByAggregateInput
    _sum?: gce_al_resultsSumOrderByAggregateInput
  }

  export type gce_al_resultsScalarWhereWithAggregatesInput = {
    AND?: gce_al_resultsScalarWhereWithAggregatesInput | gce_al_resultsScalarWhereWithAggregatesInput[]
    OR?: gce_al_resultsScalarWhereWithAggregatesInput[]
    NOT?: gce_al_resultsScalarWhereWithAggregatesInput | gce_al_resultsScalarWhereWithAggregatesInput[]
    AL_ID?: IntWithAggregatesFilter<"gce_al_results"> | number
    ApplicationID?: IntNullableWithAggregatesFilter<"gce_al_results"> | number | null
    Subject?: StringNullableWithAggregatesFilter<"gce_al_results"> | string | null
    Grade?: StringNullableWithAggregatesFilter<"gce_al_results"> | string | null
  }

  export type gce_ol_resultsWhereInput = {
    AND?: gce_ol_resultsWhereInput | gce_ol_resultsWhereInput[]
    OR?: gce_ol_resultsWhereInput[]
    NOT?: gce_ol_resultsWhereInput | gce_ol_resultsWhereInput[]
    OL_ID?: IntFilter<"gce_ol_results"> | number
    ApplicationID?: IntNullableFilter<"gce_ol_results"> | number | null
    Subject?: StringNullableFilter<"gce_ol_results"> | string | null
    Grade?: StringNullableFilter<"gce_ol_results"> | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }

  export type gce_ol_resultsOrderByWithRelationInput = {
    OL_ID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    Subject?: SortOrderInput | SortOrder
    Grade?: SortOrderInput | SortOrder
    application?: applicationOrderByWithRelationInput
    _relevance?: gce_ol_resultsOrderByRelevanceInput
  }

  export type gce_ol_resultsWhereUniqueInput = Prisma.AtLeast<{
    OL_ID?: number
    AND?: gce_ol_resultsWhereInput | gce_ol_resultsWhereInput[]
    OR?: gce_ol_resultsWhereInput[]
    NOT?: gce_ol_resultsWhereInput | gce_ol_resultsWhereInput[]
    ApplicationID?: IntNullableFilter<"gce_ol_results"> | number | null
    Subject?: StringNullableFilter<"gce_ol_results"> | string | null
    Grade?: StringNullableFilter<"gce_ol_results"> | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }, "OL_ID">

  export type gce_ol_resultsOrderByWithAggregationInput = {
    OL_ID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    Subject?: SortOrderInput | SortOrder
    Grade?: SortOrderInput | SortOrder
    _count?: gce_ol_resultsCountOrderByAggregateInput
    _avg?: gce_ol_resultsAvgOrderByAggregateInput
    _max?: gce_ol_resultsMaxOrderByAggregateInput
    _min?: gce_ol_resultsMinOrderByAggregateInput
    _sum?: gce_ol_resultsSumOrderByAggregateInput
  }

  export type gce_ol_resultsScalarWhereWithAggregatesInput = {
    AND?: gce_ol_resultsScalarWhereWithAggregatesInput | gce_ol_resultsScalarWhereWithAggregatesInput[]
    OR?: gce_ol_resultsScalarWhereWithAggregatesInput[]
    NOT?: gce_ol_resultsScalarWhereWithAggregatesInput | gce_ol_resultsScalarWhereWithAggregatesInput[]
    OL_ID?: IntWithAggregatesFilter<"gce_ol_results"> | number
    ApplicationID?: IntNullableWithAggregatesFilter<"gce_ol_results"> | number | null
    Subject?: StringNullableWithAggregatesFilter<"gce_ol_results"> | string | null
    Grade?: StringNullableWithAggregatesFilter<"gce_ol_results"> | string | null
  }

  export type jobvacancyWhereInput = {
    AND?: jobvacancyWhereInput | jobvacancyWhereInput[]
    OR?: jobvacancyWhereInput[]
    NOT?: jobvacancyWhereInput | jobvacancyWhereInput[]
    JobID?: IntFilter<"jobvacancy"> | number
    Title?: StringNullableFilter<"jobvacancy"> | string | null
    Description?: StringNullableFilter<"jobvacancy"> | string | null
    Type?: Enumjobvacancy_TypeNullableFilter<"jobvacancy"> | $Enums.jobvacancy_Type | null
    Department?: StringNullableFilter<"jobvacancy"> | string | null
    Level?: StringNullableFilter<"jobvacancy"> | string | null
    PostedBy?: IntNullableFilter<"jobvacancy"> | number | null
    PostedDate?: DateTimeNullableFilter<"jobvacancy"> | Date | string | null
    ExpiryDate?: DateTimeNullableFilter<"jobvacancy"> | Date | string | null
    Status?: Enumjobvacancy_StatusNullableFilter<"jobvacancy"> | $Enums.jobvacancy_Status | null
    TemplateID?: IntNullableFilter<"jobvacancy"> | number | null
    application?: ApplicationListRelationFilter
    admin?: XOR<AdminNullableScalarRelationFilter, adminWhereInput> | null
    applicationtemplate?: XOR<ApplicationtemplateNullableScalarRelationFilter, applicationtemplateWhereInput> | null
  }

  export type jobvacancyOrderByWithRelationInput = {
    JobID?: SortOrder
    Title?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    Type?: SortOrderInput | SortOrder
    Department?: SortOrderInput | SortOrder
    Level?: SortOrderInput | SortOrder
    PostedBy?: SortOrderInput | SortOrder
    PostedDate?: SortOrderInput | SortOrder
    ExpiryDate?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    TemplateID?: SortOrderInput | SortOrder
    application?: applicationOrderByRelationAggregateInput
    admin?: adminOrderByWithRelationInput
    applicationtemplate?: applicationtemplateOrderByWithRelationInput
    _relevance?: jobvacancyOrderByRelevanceInput
  }

  export type jobvacancyWhereUniqueInput = Prisma.AtLeast<{
    JobID?: number
    AND?: jobvacancyWhereInput | jobvacancyWhereInput[]
    OR?: jobvacancyWhereInput[]
    NOT?: jobvacancyWhereInput | jobvacancyWhereInput[]
    Title?: StringNullableFilter<"jobvacancy"> | string | null
    Description?: StringNullableFilter<"jobvacancy"> | string | null
    Type?: Enumjobvacancy_TypeNullableFilter<"jobvacancy"> | $Enums.jobvacancy_Type | null
    Department?: StringNullableFilter<"jobvacancy"> | string | null
    Level?: StringNullableFilter<"jobvacancy"> | string | null
    PostedBy?: IntNullableFilter<"jobvacancy"> | number | null
    PostedDate?: DateTimeNullableFilter<"jobvacancy"> | Date | string | null
    ExpiryDate?: DateTimeNullableFilter<"jobvacancy"> | Date | string | null
    Status?: Enumjobvacancy_StatusNullableFilter<"jobvacancy"> | $Enums.jobvacancy_Status | null
    TemplateID?: IntNullableFilter<"jobvacancy"> | number | null
    application?: ApplicationListRelationFilter
    admin?: XOR<AdminNullableScalarRelationFilter, adminWhereInput> | null
    applicationtemplate?: XOR<ApplicationtemplateNullableScalarRelationFilter, applicationtemplateWhereInput> | null
  }, "JobID">

  export type jobvacancyOrderByWithAggregationInput = {
    JobID?: SortOrder
    Title?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    Type?: SortOrderInput | SortOrder
    Department?: SortOrderInput | SortOrder
    Level?: SortOrderInput | SortOrder
    PostedBy?: SortOrderInput | SortOrder
    PostedDate?: SortOrderInput | SortOrder
    ExpiryDate?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    TemplateID?: SortOrderInput | SortOrder
    _count?: jobvacancyCountOrderByAggregateInput
    _avg?: jobvacancyAvgOrderByAggregateInput
    _max?: jobvacancyMaxOrderByAggregateInput
    _min?: jobvacancyMinOrderByAggregateInput
    _sum?: jobvacancySumOrderByAggregateInput
  }

  export type jobvacancyScalarWhereWithAggregatesInput = {
    AND?: jobvacancyScalarWhereWithAggregatesInput | jobvacancyScalarWhereWithAggregatesInput[]
    OR?: jobvacancyScalarWhereWithAggregatesInput[]
    NOT?: jobvacancyScalarWhereWithAggregatesInput | jobvacancyScalarWhereWithAggregatesInput[]
    JobID?: IntWithAggregatesFilter<"jobvacancy"> | number
    Title?: StringNullableWithAggregatesFilter<"jobvacancy"> | string | null
    Description?: StringNullableWithAggregatesFilter<"jobvacancy"> | string | null
    Type?: Enumjobvacancy_TypeNullableWithAggregatesFilter<"jobvacancy"> | $Enums.jobvacancy_Type | null
    Department?: StringNullableWithAggregatesFilter<"jobvacancy"> | string | null
    Level?: StringNullableWithAggregatesFilter<"jobvacancy"> | string | null
    PostedBy?: IntNullableWithAggregatesFilter<"jobvacancy"> | number | null
    PostedDate?: DateTimeNullableWithAggregatesFilter<"jobvacancy"> | Date | string | null
    ExpiryDate?: DateTimeNullableWithAggregatesFilter<"jobvacancy"> | Date | string | null
    Status?: Enumjobvacancy_StatusNullableWithAggregatesFilter<"jobvacancy"> | $Enums.jobvacancy_Status | null
    TemplateID?: IntNullableWithAggregatesFilter<"jobvacancy"> | number | null
  }

  export type languageproficienciesWhereInput = {
    AND?: languageproficienciesWhereInput | languageproficienciesWhereInput[]
    OR?: languageproficienciesWhereInput[]
    NOT?: languageproficienciesWhereInput | languageproficienciesWhereInput[]
    LangProfID?: IntFilter<"languageproficiencies"> | number
    ApplicationID?: IntNullableFilter<"languageproficiencies"> | number | null
    Language?: StringNullableFilter<"languageproficiencies"> | string | null
    CanSpeak?: Enumlanguageproficiencies_CanSpeakNullableFilter<"languageproficiencies"> | $Enums.languageproficiencies_CanSpeak | null
    CanRead?: Enumlanguageproficiencies_CanReadNullableFilter<"languageproficiencies"> | $Enums.languageproficiencies_CanRead | null
    CanWrite?: Enumlanguageproficiencies_CanWriteNullableFilter<"languageproficiencies"> | $Enums.languageproficiencies_CanWrite | null
    CanTeach?: Enumlanguageproficiencies_CanTeachNullableFilter<"languageproficiencies"> | $Enums.languageproficiencies_CanTeach | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }

  export type languageproficienciesOrderByWithRelationInput = {
    LangProfID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    Language?: SortOrderInput | SortOrder
    CanSpeak?: SortOrderInput | SortOrder
    CanRead?: SortOrderInput | SortOrder
    CanWrite?: SortOrderInput | SortOrder
    CanTeach?: SortOrderInput | SortOrder
    application?: applicationOrderByWithRelationInput
    _relevance?: languageproficienciesOrderByRelevanceInput
  }

  export type languageproficienciesWhereUniqueInput = Prisma.AtLeast<{
    LangProfID?: number
    AND?: languageproficienciesWhereInput | languageproficienciesWhereInput[]
    OR?: languageproficienciesWhereInput[]
    NOT?: languageproficienciesWhereInput | languageproficienciesWhereInput[]
    ApplicationID?: IntNullableFilter<"languageproficiencies"> | number | null
    Language?: StringNullableFilter<"languageproficiencies"> | string | null
    CanSpeak?: Enumlanguageproficiencies_CanSpeakNullableFilter<"languageproficiencies"> | $Enums.languageproficiencies_CanSpeak | null
    CanRead?: Enumlanguageproficiencies_CanReadNullableFilter<"languageproficiencies"> | $Enums.languageproficiencies_CanRead | null
    CanWrite?: Enumlanguageproficiencies_CanWriteNullableFilter<"languageproficiencies"> | $Enums.languageproficiencies_CanWrite | null
    CanTeach?: Enumlanguageproficiencies_CanTeachNullableFilter<"languageproficiencies"> | $Enums.languageproficiencies_CanTeach | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }, "LangProfID">

  export type languageproficienciesOrderByWithAggregationInput = {
    LangProfID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    Language?: SortOrderInput | SortOrder
    CanSpeak?: SortOrderInput | SortOrder
    CanRead?: SortOrderInput | SortOrder
    CanWrite?: SortOrderInput | SortOrder
    CanTeach?: SortOrderInput | SortOrder
    _count?: languageproficienciesCountOrderByAggregateInput
    _avg?: languageproficienciesAvgOrderByAggregateInput
    _max?: languageproficienciesMaxOrderByAggregateInput
    _min?: languageproficienciesMinOrderByAggregateInput
    _sum?: languageproficienciesSumOrderByAggregateInput
  }

  export type languageproficienciesScalarWhereWithAggregatesInput = {
    AND?: languageproficienciesScalarWhereWithAggregatesInput | languageproficienciesScalarWhereWithAggregatesInput[]
    OR?: languageproficienciesScalarWhereWithAggregatesInput[]
    NOT?: languageproficienciesScalarWhereWithAggregatesInput | languageproficienciesScalarWhereWithAggregatesInput[]
    LangProfID?: IntWithAggregatesFilter<"languageproficiencies"> | number
    ApplicationID?: IntNullableWithAggregatesFilter<"languageproficiencies"> | number | null
    Language?: StringNullableWithAggregatesFilter<"languageproficiencies"> | string | null
    CanSpeak?: Enumlanguageproficiencies_CanSpeakNullableWithAggregatesFilter<"languageproficiencies"> | $Enums.languageproficiencies_CanSpeak | null
    CanRead?: Enumlanguageproficiencies_CanReadNullableWithAggregatesFilter<"languageproficiencies"> | $Enums.languageproficiencies_CanRead | null
    CanWrite?: Enumlanguageproficiencies_CanWriteNullableWithAggregatesFilter<"languageproficiencies"> | $Enums.languageproficiencies_CanWrite | null
    CanTeach?: Enumlanguageproficiencies_CanTeachNullableWithAggregatesFilter<"languageproficiencies"> | $Enums.languageproficiencies_CanTeach | null
  }

  export type professionalqualificationsWhereInput = {
    AND?: professionalqualificationsWhereInput | professionalqualificationsWhereInput[]
    OR?: professionalqualificationsWhereInput[]
    NOT?: professionalqualificationsWhereInput | professionalqualificationsWhereInput[]
    PQ_ID?: IntFilter<"professionalqualifications"> | number
    ApplicationID?: IntNullableFilter<"professionalqualifications"> | number | null
    Institution?: StringNullableFilter<"professionalqualifications"> | string | null
    QualificationName?: StringNullableFilter<"professionalqualifications"> | string | null
    FromYear?: IntNullableFilter<"professionalqualifications"> | number | null
    ToYear?: IntNullableFilter<"professionalqualifications"> | number | null
    ResultOrExamPassed?: StringNullableFilter<"professionalqualifications"> | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }

  export type professionalqualificationsOrderByWithRelationInput = {
    PQ_ID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    Institution?: SortOrderInput | SortOrder
    QualificationName?: SortOrderInput | SortOrder
    FromYear?: SortOrderInput | SortOrder
    ToYear?: SortOrderInput | SortOrder
    ResultOrExamPassed?: SortOrderInput | SortOrder
    application?: applicationOrderByWithRelationInput
    _relevance?: professionalqualificationsOrderByRelevanceInput
  }

  export type professionalqualificationsWhereUniqueInput = Prisma.AtLeast<{
    PQ_ID?: number
    AND?: professionalqualificationsWhereInput | professionalqualificationsWhereInput[]
    OR?: professionalqualificationsWhereInput[]
    NOT?: professionalqualificationsWhereInput | professionalqualificationsWhereInput[]
    ApplicationID?: IntNullableFilter<"professionalqualifications"> | number | null
    Institution?: StringNullableFilter<"professionalqualifications"> | string | null
    QualificationName?: StringNullableFilter<"professionalqualifications"> | string | null
    FromYear?: IntNullableFilter<"professionalqualifications"> | number | null
    ToYear?: IntNullableFilter<"professionalqualifications"> | number | null
    ResultOrExamPassed?: StringNullableFilter<"professionalqualifications"> | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }, "PQ_ID">

  export type professionalqualificationsOrderByWithAggregationInput = {
    PQ_ID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    Institution?: SortOrderInput | SortOrder
    QualificationName?: SortOrderInput | SortOrder
    FromYear?: SortOrderInput | SortOrder
    ToYear?: SortOrderInput | SortOrder
    ResultOrExamPassed?: SortOrderInput | SortOrder
    _count?: professionalqualificationsCountOrderByAggregateInput
    _avg?: professionalqualificationsAvgOrderByAggregateInput
    _max?: professionalqualificationsMaxOrderByAggregateInput
    _min?: professionalqualificationsMinOrderByAggregateInput
    _sum?: professionalqualificationsSumOrderByAggregateInput
  }

  export type professionalqualificationsScalarWhereWithAggregatesInput = {
    AND?: professionalqualificationsScalarWhereWithAggregatesInput | professionalqualificationsScalarWhereWithAggregatesInput[]
    OR?: professionalqualificationsScalarWhereWithAggregatesInput[]
    NOT?: professionalqualificationsScalarWhereWithAggregatesInput | professionalqualificationsScalarWhereWithAggregatesInput[]
    PQ_ID?: IntWithAggregatesFilter<"professionalqualifications"> | number
    ApplicationID?: IntNullableWithAggregatesFilter<"professionalqualifications"> | number | null
    Institution?: StringNullableWithAggregatesFilter<"professionalqualifications"> | string | null
    QualificationName?: StringNullableWithAggregatesFilter<"professionalqualifications"> | string | null
    FromYear?: IntNullableWithAggregatesFilter<"professionalqualifications"> | number | null
    ToYear?: IntNullableWithAggregatesFilter<"professionalqualifications"> | number | null
    ResultOrExamPassed?: StringNullableWithAggregatesFilter<"professionalqualifications"> | string | null
  }

  export type researchandpublicationsWhereInput = {
    AND?: researchandpublicationsWhereInput | researchandpublicationsWhereInput[]
    OR?: researchandpublicationsWhereInput[]
    NOT?: researchandpublicationsWhereInput | researchandpublicationsWhereInput[]
    ResearchID?: IntFilter<"researchandpublications"> | number
    ApplicationID?: IntNullableFilter<"researchandpublications"> | number | null
    Description?: StringNullableFilter<"researchandpublications"> | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }

  export type researchandpublicationsOrderByWithRelationInput = {
    ResearchID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    application?: applicationOrderByWithRelationInput
    _relevance?: researchandpublicationsOrderByRelevanceInput
  }

  export type researchandpublicationsWhereUniqueInput = Prisma.AtLeast<{
    ResearchID?: number
    AND?: researchandpublicationsWhereInput | researchandpublicationsWhereInput[]
    OR?: researchandpublicationsWhereInput[]
    NOT?: researchandpublicationsWhereInput | researchandpublicationsWhereInput[]
    ApplicationID?: IntNullableFilter<"researchandpublications"> | number | null
    Description?: StringNullableFilter<"researchandpublications"> | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }, "ResearchID">

  export type researchandpublicationsOrderByWithAggregationInput = {
    ResearchID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    _count?: researchandpublicationsCountOrderByAggregateInput
    _avg?: researchandpublicationsAvgOrderByAggregateInput
    _max?: researchandpublicationsMaxOrderByAggregateInput
    _min?: researchandpublicationsMinOrderByAggregateInput
    _sum?: researchandpublicationsSumOrderByAggregateInput
  }

  export type researchandpublicationsScalarWhereWithAggregatesInput = {
    AND?: researchandpublicationsScalarWhereWithAggregatesInput | researchandpublicationsScalarWhereWithAggregatesInput[]
    OR?: researchandpublicationsScalarWhereWithAggregatesInput[]
    NOT?: researchandpublicationsScalarWhereWithAggregatesInput | researchandpublicationsScalarWhereWithAggregatesInput[]
    ResearchID?: IntWithAggregatesFilter<"researchandpublications"> | number
    ApplicationID?: IntNullableWithAggregatesFilter<"researchandpublications"> | number | null
    Description?: StringNullableWithAggregatesFilter<"researchandpublications"> | string | null
  }

  export type specialqualificationsWhereInput = {
    AND?: specialqualificationsWhereInput | specialqualificationsWhereInput[]
    OR?: specialqualificationsWhereInput[]
    NOT?: specialqualificationsWhereInput | specialqualificationsWhereInput[]
    SpecialQualID?: IntFilter<"specialqualifications"> | number
    ApplicationID?: IntNullableFilter<"specialqualifications"> | number | null
    Description?: StringNullableFilter<"specialqualifications"> | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }

  export type specialqualificationsOrderByWithRelationInput = {
    SpecialQualID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    application?: applicationOrderByWithRelationInput
    _relevance?: specialqualificationsOrderByRelevanceInput
  }

  export type specialqualificationsWhereUniqueInput = Prisma.AtLeast<{
    SpecialQualID?: number
    AND?: specialqualificationsWhereInput | specialqualificationsWhereInput[]
    OR?: specialqualificationsWhereInput[]
    NOT?: specialqualificationsWhereInput | specialqualificationsWhereInput[]
    ApplicationID?: IntNullableFilter<"specialqualifications"> | number | null
    Description?: StringNullableFilter<"specialqualifications"> | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }, "SpecialQualID">

  export type specialqualificationsOrderByWithAggregationInput = {
    SpecialQualID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    _count?: specialqualificationsCountOrderByAggregateInput
    _avg?: specialqualificationsAvgOrderByAggregateInput
    _max?: specialqualificationsMaxOrderByAggregateInput
    _min?: specialqualificationsMinOrderByAggregateInput
    _sum?: specialqualificationsSumOrderByAggregateInput
  }

  export type specialqualificationsScalarWhereWithAggregatesInput = {
    AND?: specialqualificationsScalarWhereWithAggregatesInput | specialqualificationsScalarWhereWithAggregatesInput[]
    OR?: specialqualificationsScalarWhereWithAggregatesInput[]
    NOT?: specialqualificationsScalarWhereWithAggregatesInput | specialqualificationsScalarWhereWithAggregatesInput[]
    SpecialQualID?: IntWithAggregatesFilter<"specialqualifications"> | number
    ApplicationID?: IntNullableWithAggregatesFilter<"specialqualifications"> | number | null
    Description?: StringNullableWithAggregatesFilter<"specialqualifications"> | string | null
  }

  export type superadminWhereInput = {
    AND?: superadminWhereInput | superadminWhereInput[]
    OR?: superadminWhereInput[]
    NOT?: superadminWhereInput | superadminWhereInput[]
    SuperAdminID?: IntFilter<"superadmin"> | number
    FullName?: StringNullableFilter<"superadmin"> | string | null
    Email?: StringNullableFilter<"superadmin"> | string | null
    PasswordHash?: StringNullableFilter<"superadmin"> | string | null
    PhoneNumber?: StringNullableFilter<"superadmin"> | string | null
    CreatedAt?: DateTimeNullableFilter<"superadmin"> | Date | string | null
  }

  export type superadminOrderByWithRelationInput = {
    SuperAdminID?: SortOrder
    FullName?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    PasswordHash?: SortOrderInput | SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    _relevance?: superadminOrderByRelevanceInput
  }

  export type superadminWhereUniqueInput = Prisma.AtLeast<{
    SuperAdminID?: number
    Email?: string
    AND?: superadminWhereInput | superadminWhereInput[]
    OR?: superadminWhereInput[]
    NOT?: superadminWhereInput | superadminWhereInput[]
    FullName?: StringNullableFilter<"superadmin"> | string | null
    PasswordHash?: StringNullableFilter<"superadmin"> | string | null
    PhoneNumber?: StringNullableFilter<"superadmin"> | string | null
    CreatedAt?: DateTimeNullableFilter<"superadmin"> | Date | string | null
  }, "SuperAdminID" | "Email">

  export type superadminOrderByWithAggregationInput = {
    SuperAdminID?: SortOrder
    FullName?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    PasswordHash?: SortOrderInput | SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    _count?: superadminCountOrderByAggregateInput
    _avg?: superadminAvgOrderByAggregateInput
    _max?: superadminMaxOrderByAggregateInput
    _min?: superadminMinOrderByAggregateInput
    _sum?: superadminSumOrderByAggregateInput
  }

  export type superadminScalarWhereWithAggregatesInput = {
    AND?: superadminScalarWhereWithAggregatesInput | superadminScalarWhereWithAggregatesInput[]
    OR?: superadminScalarWhereWithAggregatesInput[]
    NOT?: superadminScalarWhereWithAggregatesInput | superadminScalarWhereWithAggregatesInput[]
    SuperAdminID?: IntWithAggregatesFilter<"superadmin"> | number
    FullName?: StringNullableWithAggregatesFilter<"superadmin"> | string | null
    Email?: StringNullableWithAggregatesFilter<"superadmin"> | string | null
    PasswordHash?: StringNullableWithAggregatesFilter<"superadmin"> | string | null
    PhoneNumber?: StringNullableWithAggregatesFilter<"superadmin"> | string | null
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"superadmin"> | Date | string | null
  }

  export type universityeducationsWhereInput = {
    AND?: universityeducationsWhereInput | universityeducationsWhereInput[]
    OR?: universityeducationsWhereInput[]
    NOT?: universityeducationsWhereInput | universityeducationsWhereInput[]
    UE_ID?: IntFilter<"universityeducations"> | number
    ApplicationID?: IntNullableFilter<"universityeducations"> | number | null
    DegreeOrDiploma?: StringNullableFilter<"universityeducations"> | string | null
    Institute?: StringNullableFilter<"universityeducations"> | string | null
    FromYear?: IntNullableFilter<"universityeducations"> | number | null
    ToYear?: IntNullableFilter<"universityeducations"> | number | null
    Class?: StringNullableFilter<"universityeducations"> | string | null
    YearObtained?: IntNullableFilter<"universityeducations"> | number | null
    IndexNumber?: StringNullableFilter<"universityeducations"> | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }

  export type universityeducationsOrderByWithRelationInput = {
    UE_ID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    DegreeOrDiploma?: SortOrderInput | SortOrder
    Institute?: SortOrderInput | SortOrder
    FromYear?: SortOrderInput | SortOrder
    ToYear?: SortOrderInput | SortOrder
    Class?: SortOrderInput | SortOrder
    YearObtained?: SortOrderInput | SortOrder
    IndexNumber?: SortOrderInput | SortOrder
    application?: applicationOrderByWithRelationInput
    _relevance?: universityeducationsOrderByRelevanceInput
  }

  export type universityeducationsWhereUniqueInput = Prisma.AtLeast<{
    UE_ID?: number
    AND?: universityeducationsWhereInput | universityeducationsWhereInput[]
    OR?: universityeducationsWhereInput[]
    NOT?: universityeducationsWhereInput | universityeducationsWhereInput[]
    ApplicationID?: IntNullableFilter<"universityeducations"> | number | null
    DegreeOrDiploma?: StringNullableFilter<"universityeducations"> | string | null
    Institute?: StringNullableFilter<"universityeducations"> | string | null
    FromYear?: IntNullableFilter<"universityeducations"> | number | null
    ToYear?: IntNullableFilter<"universityeducations"> | number | null
    Class?: StringNullableFilter<"universityeducations"> | string | null
    YearObtained?: IntNullableFilter<"universityeducations"> | number | null
    IndexNumber?: StringNullableFilter<"universityeducations"> | string | null
    application?: XOR<ApplicationNullableScalarRelationFilter, applicationWhereInput> | null
  }, "UE_ID">

  export type universityeducationsOrderByWithAggregationInput = {
    UE_ID?: SortOrder
    ApplicationID?: SortOrderInput | SortOrder
    DegreeOrDiploma?: SortOrderInput | SortOrder
    Institute?: SortOrderInput | SortOrder
    FromYear?: SortOrderInput | SortOrder
    ToYear?: SortOrderInput | SortOrder
    Class?: SortOrderInput | SortOrder
    YearObtained?: SortOrderInput | SortOrder
    IndexNumber?: SortOrderInput | SortOrder
    _count?: universityeducationsCountOrderByAggregateInput
    _avg?: universityeducationsAvgOrderByAggregateInput
    _max?: universityeducationsMaxOrderByAggregateInput
    _min?: universityeducationsMinOrderByAggregateInput
    _sum?: universityeducationsSumOrderByAggregateInput
  }

  export type universityeducationsScalarWhereWithAggregatesInput = {
    AND?: universityeducationsScalarWhereWithAggregatesInput | universityeducationsScalarWhereWithAggregatesInput[]
    OR?: universityeducationsScalarWhereWithAggregatesInput[]
    NOT?: universityeducationsScalarWhereWithAggregatesInput | universityeducationsScalarWhereWithAggregatesInput[]
    UE_ID?: IntWithAggregatesFilter<"universityeducations"> | number
    ApplicationID?: IntNullableWithAggregatesFilter<"universityeducations"> | number | null
    DegreeOrDiploma?: StringNullableWithAggregatesFilter<"universityeducations"> | string | null
    Institute?: StringNullableWithAggregatesFilter<"universityeducations"> | string | null
    FromYear?: IntNullableWithAggregatesFilter<"universityeducations"> | number | null
    ToYear?: IntNullableWithAggregatesFilter<"universityeducations"> | number | null
    Class?: StringNullableWithAggregatesFilter<"universityeducations"> | string | null
    YearObtained?: IntNullableWithAggregatesFilter<"universityeducations"> | number | null
    IndexNumber?: StringNullableWithAggregatesFilter<"universityeducations"> | string | null
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    UserID?: IntFilter<"user"> | number
    FullName?: StringNullableFilter<"user"> | string | null
    Email?: StringNullableFilter<"user"> | string | null
    PasswordHash?: StringNullableFilter<"user"> | string | null
    NIC?: StringNullableFilter<"user"> | string | null
    PhoneNumber?: StringNullableFilter<"user"> | string | null
    Address?: StringNullableFilter<"user"> | string | null
    AccountStatus?: Enumuser_AccountStatusNullableFilter<"user"> | $Enums.user_AccountStatus | null
    CreatedAt?: DateTimeNullableFilter<"user"> | Date | string | null
    UpdatedAt?: DateTimeNullableFilter<"user"> | Date | string | null
    application?: ApplicationListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    UserID?: SortOrder
    FullName?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    PasswordHash?: SortOrderInput | SortOrder
    NIC?: SortOrderInput | SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    Address?: SortOrderInput | SortOrder
    AccountStatus?: SortOrderInput | SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    application?: applicationOrderByRelationAggregateInput
    _relevance?: userOrderByRelevanceInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    UserID?: number
    Email?: string
    NIC?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    FullName?: StringNullableFilter<"user"> | string | null
    PasswordHash?: StringNullableFilter<"user"> | string | null
    PhoneNumber?: StringNullableFilter<"user"> | string | null
    Address?: StringNullableFilter<"user"> | string | null
    AccountStatus?: Enumuser_AccountStatusNullableFilter<"user"> | $Enums.user_AccountStatus | null
    CreatedAt?: DateTimeNullableFilter<"user"> | Date | string | null
    UpdatedAt?: DateTimeNullableFilter<"user"> | Date | string | null
    application?: ApplicationListRelationFilter
  }, "UserID" | "Email" | "NIC">

  export type userOrderByWithAggregationInput = {
    UserID?: SortOrder
    FullName?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    PasswordHash?: SortOrderInput | SortOrder
    NIC?: SortOrderInput | SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    Address?: SortOrderInput | SortOrder
    AccountStatus?: SortOrderInput | SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    UpdatedAt?: SortOrderInput | SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    UserID?: IntWithAggregatesFilter<"user"> | number
    FullName?: StringNullableWithAggregatesFilter<"user"> | string | null
    Email?: StringNullableWithAggregatesFilter<"user"> | string | null
    PasswordHash?: StringNullableWithAggregatesFilter<"user"> | string | null
    NIC?: StringNullableWithAggregatesFilter<"user"> | string | null
    PhoneNumber?: StringNullableWithAggregatesFilter<"user"> | string | null
    Address?: StringNullableWithAggregatesFilter<"user"> | string | null
    AccountStatus?: Enumuser_AccountStatusNullableWithAggregatesFilter<"user"> | $Enums.user_AccountStatus | null
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    UpdatedAt?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
  }

  export type additionalinfoCreateInput = {
    Content?: string | null
    application?: applicationCreateNestedOneWithoutAdditionalinfoInput
  }

  export type additionalinfoUncheckedCreateInput = {
    InfoID?: number
    ApplicationID?: number | null
    Content?: string | null
  }

  export type additionalinfoUpdateInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    application?: applicationUpdateOneWithoutAdditionalinfoNestedInput
  }

  export type additionalinfoUncheckedUpdateInput = {
    InfoID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type additionalinfoCreateManyInput = {
    InfoID?: number
    ApplicationID?: number | null
    Content?: string | null
  }

  export type additionalinfoUpdateManyMutationInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type additionalinfoUncheckedUpdateManyInput = {
    InfoID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type adminCreateInput = {
    FullName?: string | null
    Email?: string | null
    PasswordHash?: string | null
    Department?: string | null
    PhoneNumber?: string | null
    CreatedAt?: Date | string | null
    UpdatedAt?: Date | string | null
    isDeleted?: boolean | null
    applicationtemplate?: applicationtemplateCreateNestedManyWithoutAdminInput
    jobvacancy?: jobvacancyCreateNestedManyWithoutAdminInput
  }

  export type adminUncheckedCreateInput = {
    AdminID?: number
    FullName?: string | null
    Email?: string | null
    PasswordHash?: string | null
    Department?: string | null
    PhoneNumber?: string | null
    CreatedAt?: Date | string | null
    UpdatedAt?: Date | string | null
    isDeleted?: boolean | null
    applicationtemplate?: applicationtemplateUncheckedCreateNestedManyWithoutAdminInput
    jobvacancy?: jobvacancyUncheckedCreateNestedManyWithoutAdminInput
  }

  export type adminUpdateInput = {
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    Department?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    applicationtemplate?: applicationtemplateUpdateManyWithoutAdminNestedInput
    jobvacancy?: jobvacancyUpdateManyWithoutAdminNestedInput
  }

  export type adminUncheckedUpdateInput = {
    AdminID?: IntFieldUpdateOperationsInput | number
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    Department?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    applicationtemplate?: applicationtemplateUncheckedUpdateManyWithoutAdminNestedInput
    jobvacancy?: jobvacancyUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type adminCreateManyInput = {
    AdminID?: number
    FullName?: string | null
    Email?: string | null
    PasswordHash?: string | null
    Department?: string | null
    PhoneNumber?: string | null
    CreatedAt?: Date | string | null
    UpdatedAt?: Date | string | null
    isDeleted?: boolean | null
  }

  export type adminUpdateManyMutationInput = {
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    Department?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type adminUncheckedUpdateManyInput = {
    AdminID?: IntFieldUpdateOperationsInput | number
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    Department?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type applicationCreateInput = {
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoCreateNestedManyWithoutApplicationInput
    user?: userCreateNestedOneWithoutApplicationInput
    jobvacancy?: jobvacancyCreateNestedOneWithoutApplicationInput
    applicationattachments?: applicationattachmentsCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsCreateNestedManyWithoutApplicationInput
  }

  export type applicationUncheckedCreateInput = {
    ApplicationID?: number
    UserID?: number | null
    JobID?: number | null
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoUncheckedCreateNestedManyWithoutApplicationInput
    applicationattachments?: applicationattachmentsUncheckedCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesUncheckedCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesUncheckedCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsUncheckedCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsUncheckedCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsUncheckedCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesUncheckedCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsUncheckedCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type applicationUpdateInput = {
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUpdateManyWithoutApplicationNestedInput
    user?: userUpdateOneWithoutApplicationNestedInput
    jobvacancy?: jobvacancyUpdateOneWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUpdateManyWithoutApplicationNestedInput
  }

  export type applicationUncheckedUpdateInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    UserID?: NullableIntFieldUpdateOperationsInput | number | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUncheckedUpdateManyWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUncheckedUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUncheckedUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUncheckedUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUncheckedUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUncheckedUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type applicationCreateManyInput = {
    ApplicationID?: number
    UserID?: number | null
    JobID?: number | null
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
  }

  export type applicationUpdateManyMutationInput = {
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type applicationUncheckedUpdateManyInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    UserID?: NullableIntFieldUpdateOperationsInput | number | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type applicationattachmentsCreateInput = {
    FileType?: string | null
    FilePath?: string | null
    UploadedAt?: Date | string | null
    application?: applicationCreateNestedOneWithoutApplicationattachmentsInput
  }

  export type applicationattachmentsUncheckedCreateInput = {
    AttachmentID?: number
    ApplicationID?: number | null
    FileType?: string | null
    FilePath?: string | null
    UploadedAt?: Date | string | null
  }

  export type applicationattachmentsUpdateInput = {
    FileType?: NullableStringFieldUpdateOperationsInput | string | null
    FilePath?: NullableStringFieldUpdateOperationsInput | string | null
    UploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    application?: applicationUpdateOneWithoutApplicationattachmentsNestedInput
  }

  export type applicationattachmentsUncheckedUpdateInput = {
    AttachmentID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    FileType?: NullableStringFieldUpdateOperationsInput | string | null
    FilePath?: NullableStringFieldUpdateOperationsInput | string | null
    UploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type applicationattachmentsCreateManyInput = {
    AttachmentID?: number
    ApplicationID?: number | null
    FileType?: string | null
    FilePath?: string | null
    UploadedAt?: Date | string | null
  }

  export type applicationattachmentsUpdateManyMutationInput = {
    FileType?: NullableStringFieldUpdateOperationsInput | string | null
    FilePath?: NullableStringFieldUpdateOperationsInput | string | null
    UploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type applicationattachmentsUncheckedUpdateManyInput = {
    AttachmentID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    FileType?: NullableStringFieldUpdateOperationsInput | string | null
    FilePath?: NullableStringFieldUpdateOperationsInput | string | null
    UploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type applicationgeneraldetailsCreateInput = {
    PostApplied?: string | null
    FullName?: string | null
    NameWithInitials?: string | null
    NIC?: string | null
    DOB?: Date | string | null
    Gender?: $Enums.applicationgeneraldetails_Gender | null
    PhoneNumber?: string | null
    Email?: string | null
    PresentAddress?: string | null
    PermanentAddress?: string | null
    CivilStatus?: string | null
    CitizenshipType?: $Enums.applicationgeneraldetails_CitizenshipType | null
    CitizenshipDetails?: string | null
    EthnicityOrReligion?: string | null
    application: applicationCreateNestedOneWithoutApplicationgeneraldetailsInput
  }

  export type applicationgeneraldetailsUncheckedCreateInput = {
    ApplicationID: number
    PostApplied?: string | null
    FullName?: string | null
    NameWithInitials?: string | null
    NIC?: string | null
    DOB?: Date | string | null
    Gender?: $Enums.applicationgeneraldetails_Gender | null
    PhoneNumber?: string | null
    Email?: string | null
    PresentAddress?: string | null
    PermanentAddress?: string | null
    CivilStatus?: string | null
    CitizenshipType?: $Enums.applicationgeneraldetails_CitizenshipType | null
    CitizenshipDetails?: string | null
    EthnicityOrReligion?: string | null
  }

  export type applicationgeneraldetailsUpdateInput = {
    PostApplied?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    NameWithInitials?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Gender?: NullableEnumapplicationgeneraldetails_GenderFieldUpdateOperationsInput | $Enums.applicationgeneraldetails_Gender | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PresentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    PermanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    CivilStatus?: NullableStringFieldUpdateOperationsInput | string | null
    CitizenshipType?: NullableEnumapplicationgeneraldetails_CitizenshipTypeFieldUpdateOperationsInput | $Enums.applicationgeneraldetails_CitizenshipType | null
    CitizenshipDetails?: NullableStringFieldUpdateOperationsInput | string | null
    EthnicityOrReligion?: NullableStringFieldUpdateOperationsInput | string | null
    application?: applicationUpdateOneRequiredWithoutApplicationgeneraldetailsNestedInput
  }

  export type applicationgeneraldetailsUncheckedUpdateInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    PostApplied?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    NameWithInitials?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Gender?: NullableEnumapplicationgeneraldetails_GenderFieldUpdateOperationsInput | $Enums.applicationgeneraldetails_Gender | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PresentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    PermanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    CivilStatus?: NullableStringFieldUpdateOperationsInput | string | null
    CitizenshipType?: NullableEnumapplicationgeneraldetails_CitizenshipTypeFieldUpdateOperationsInput | $Enums.applicationgeneraldetails_CitizenshipType | null
    CitizenshipDetails?: NullableStringFieldUpdateOperationsInput | string | null
    EthnicityOrReligion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type applicationgeneraldetailsCreateManyInput = {
    ApplicationID: number
    PostApplied?: string | null
    FullName?: string | null
    NameWithInitials?: string | null
    NIC?: string | null
    DOB?: Date | string | null
    Gender?: $Enums.applicationgeneraldetails_Gender | null
    PhoneNumber?: string | null
    Email?: string | null
    PresentAddress?: string | null
    PermanentAddress?: string | null
    CivilStatus?: string | null
    CitizenshipType?: $Enums.applicationgeneraldetails_CitizenshipType | null
    CitizenshipDetails?: string | null
    EthnicityOrReligion?: string | null
  }

  export type applicationgeneraldetailsUpdateManyMutationInput = {
    PostApplied?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    NameWithInitials?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Gender?: NullableEnumapplicationgeneraldetails_GenderFieldUpdateOperationsInput | $Enums.applicationgeneraldetails_Gender | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PresentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    PermanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    CivilStatus?: NullableStringFieldUpdateOperationsInput | string | null
    CitizenshipType?: NullableEnumapplicationgeneraldetails_CitizenshipTypeFieldUpdateOperationsInput | $Enums.applicationgeneraldetails_CitizenshipType | null
    CitizenshipDetails?: NullableStringFieldUpdateOperationsInput | string | null
    EthnicityOrReligion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type applicationgeneraldetailsUncheckedUpdateManyInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    PostApplied?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    NameWithInitials?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Gender?: NullableEnumapplicationgeneraldetails_GenderFieldUpdateOperationsInput | $Enums.applicationgeneraldetails_Gender | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PresentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    PermanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    CivilStatus?: NullableStringFieldUpdateOperationsInput | string | null
    CitizenshipType?: NullableEnumapplicationgeneraldetails_CitizenshipTypeFieldUpdateOperationsInput | $Enums.applicationgeneraldetails_CitizenshipType | null
    CitizenshipDetails?: NullableStringFieldUpdateOperationsInput | string | null
    EthnicityOrReligion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type applicationreferencesCreateInput = {
    Name?: string | null
    Designation?: string | null
    Address?: string | null
    application?: applicationCreateNestedOneWithoutApplicationreferencesInput
  }

  export type applicationreferencesUncheckedCreateInput = {
    ReferenceID?: number
    ApplicationID?: number | null
    Name?: string | null
    Designation?: string | null
    Address?: string | null
  }

  export type applicationreferencesUpdateInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Designation?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    application?: applicationUpdateOneWithoutApplicationreferencesNestedInput
  }

  export type applicationreferencesUncheckedUpdateInput = {
    ReferenceID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Designation?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type applicationreferencesCreateManyInput = {
    ReferenceID?: number
    ApplicationID?: number | null
    Name?: string | null
    Designation?: string | null
    Address?: string | null
  }

  export type applicationreferencesUpdateManyMutationInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Designation?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type applicationreferencesUncheckedUpdateManyInput = {
    ReferenceID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Designation?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type applicationtemplateCreateInput = {
    Type?: $Enums.applicationtemplate_Type | null
    FilePath?: string | null
    UploadDate?: Date | string | null
    admin?: adminCreateNestedOneWithoutApplicationtemplateInput
    jobvacancy?: jobvacancyCreateNestedManyWithoutApplicationtemplateInput
  }

  export type applicationtemplateUncheckedCreateInput = {
    TemplateID?: number
    Type?: $Enums.applicationtemplate_Type | null
    FilePath?: string | null
    UploadedBy?: number | null
    UploadDate?: Date | string | null
    jobvacancy?: jobvacancyUncheckedCreateNestedManyWithoutApplicationtemplateInput
  }

  export type applicationtemplateUpdateInput = {
    Type?: NullableEnumapplicationtemplate_TypeFieldUpdateOperationsInput | $Enums.applicationtemplate_Type | null
    FilePath?: NullableStringFieldUpdateOperationsInput | string | null
    UploadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: adminUpdateOneWithoutApplicationtemplateNestedInput
    jobvacancy?: jobvacancyUpdateManyWithoutApplicationtemplateNestedInput
  }

  export type applicationtemplateUncheckedUpdateInput = {
    TemplateID?: IntFieldUpdateOperationsInput | number
    Type?: NullableEnumapplicationtemplate_TypeFieldUpdateOperationsInput | $Enums.applicationtemplate_Type | null
    FilePath?: NullableStringFieldUpdateOperationsInput | string | null
    UploadedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UploadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobvacancy?: jobvacancyUncheckedUpdateManyWithoutApplicationtemplateNestedInput
  }

  export type applicationtemplateCreateManyInput = {
    TemplateID?: number
    Type?: $Enums.applicationtemplate_Type | null
    FilePath?: string | null
    UploadedBy?: number | null
    UploadDate?: Date | string | null
  }

  export type applicationtemplateUpdateManyMutationInput = {
    Type?: NullableEnumapplicationtemplate_TypeFieldUpdateOperationsInput | $Enums.applicationtemplate_Type | null
    FilePath?: NullableStringFieldUpdateOperationsInput | string | null
    UploadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type applicationtemplateUncheckedUpdateManyInput = {
    TemplateID?: IntFieldUpdateOperationsInput | number
    Type?: NullableEnumapplicationtemplate_TypeFieldUpdateOperationsInput | $Enums.applicationtemplate_Type | null
    FilePath?: NullableStringFieldUpdateOperationsInput | string | null
    UploadedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UploadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auditlogCreateInput = {
    ActorID?: number | null
    ActorRole?: $Enums.auditlog_ActorRole | null
    Action?: string | null
    Timestamp?: Date | string | null
    Details?: string | null
  }

  export type auditlogUncheckedCreateInput = {
    LogID?: number
    ActorID?: number | null
    ActorRole?: $Enums.auditlog_ActorRole | null
    Action?: string | null
    Timestamp?: Date | string | null
    Details?: string | null
  }

  export type auditlogUpdateInput = {
    ActorID?: NullableIntFieldUpdateOperationsInput | number | null
    ActorRole?: NullableEnumauditlog_ActorRoleFieldUpdateOperationsInput | $Enums.auditlog_ActorRole | null
    Action?: NullableStringFieldUpdateOperationsInput | string | null
    Timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auditlogUncheckedUpdateInput = {
    LogID?: IntFieldUpdateOperationsInput | number
    ActorID?: NullableIntFieldUpdateOperationsInput | number | null
    ActorRole?: NullableEnumauditlog_ActorRoleFieldUpdateOperationsInput | $Enums.auditlog_ActorRole | null
    Action?: NullableStringFieldUpdateOperationsInput | string | null
    Timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auditlogCreateManyInput = {
    LogID?: number
    ActorID?: number | null
    ActorRole?: $Enums.auditlog_ActorRole | null
    Action?: string | null
    Timestamp?: Date | string | null
    Details?: string | null
  }

  export type auditlogUpdateManyMutationInput = {
    ActorID?: NullableIntFieldUpdateOperationsInput | number | null
    ActorRole?: NullableEnumauditlog_ActorRoleFieldUpdateOperationsInput | $Enums.auditlog_ActorRole | null
    Action?: NullableStringFieldUpdateOperationsInput | string | null
    Timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auditlogUncheckedUpdateManyInput = {
    LogID?: IntFieldUpdateOperationsInput | number
    ActorID?: NullableIntFieldUpdateOperationsInput | number | null
    ActorRole?: NullableEnumauditlog_ActorRoleFieldUpdateOperationsInput | $Enums.auditlog_ActorRole | null
    Action?: NullableStringFieldUpdateOperationsInput | string | null
    Timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type employmenthistoriesCreateInput = {
    PostHeld?: string | null
    Institution?: string | null
    FromDate?: Date | string | null
    ToDate?: Date | string | null
    LastSalary?: Decimal | DecimalJsLike | number | string | null
    application?: applicationCreateNestedOneWithoutEmploymenthistoriesInput
  }

  export type employmenthistoriesUncheckedCreateInput = {
    EmploymentID?: number
    ApplicationID?: number | null
    PostHeld?: string | null
    Institution?: string | null
    FromDate?: Date | string | null
    ToDate?: Date | string | null
    LastSalary?: Decimal | DecimalJsLike | number | string | null
  }

  export type employmenthistoriesUpdateInput = {
    PostHeld?: NullableStringFieldUpdateOperationsInput | string | null
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
    FromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    application?: applicationUpdateOneWithoutEmploymenthistoriesNestedInput
  }

  export type employmenthistoriesUncheckedUpdateInput = {
    EmploymentID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    PostHeld?: NullableStringFieldUpdateOperationsInput | string | null
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
    FromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type employmenthistoriesCreateManyInput = {
    EmploymentID?: number
    ApplicationID?: number | null
    PostHeld?: string | null
    Institution?: string | null
    FromDate?: Date | string | null
    ToDate?: Date | string | null
    LastSalary?: Decimal | DecimalJsLike | number | string | null
  }

  export type employmenthistoriesUpdateManyMutationInput = {
    PostHeld?: NullableStringFieldUpdateOperationsInput | string | null
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
    FromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type employmenthistoriesUncheckedUpdateManyInput = {
    EmploymentID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    PostHeld?: NullableStringFieldUpdateOperationsInput | string | null
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
    FromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type experiencedetailsCreateInput = {
    Description?: string | null
    application?: applicationCreateNestedOneWithoutExperiencedetailsInput
  }

  export type experiencedetailsUncheckedCreateInput = {
    ExperienceID?: number
    ApplicationID?: number | null
    Description?: string | null
  }

  export type experiencedetailsUpdateInput = {
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    application?: applicationUpdateOneWithoutExperiencedetailsNestedInput
  }

  export type experiencedetailsUncheckedUpdateInput = {
    ExperienceID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type experiencedetailsCreateManyInput = {
    ExperienceID?: number
    ApplicationID?: number | null
    Description?: string | null
  }

  export type experiencedetailsUpdateManyMutationInput = {
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type experiencedetailsUncheckedUpdateManyInput = {
    ExperienceID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gce_al_resultsCreateInput = {
    Subject?: string | null
    Grade?: string | null
    application?: applicationCreateNestedOneWithoutGce_al_resultsInput
  }

  export type gce_al_resultsUncheckedCreateInput = {
    AL_ID?: number
    ApplicationID?: number | null
    Subject?: string | null
    Grade?: string | null
  }

  export type gce_al_resultsUpdateInput = {
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Grade?: NullableStringFieldUpdateOperationsInput | string | null
    application?: applicationUpdateOneWithoutGce_al_resultsNestedInput
  }

  export type gce_al_resultsUncheckedUpdateInput = {
    AL_ID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gce_al_resultsCreateManyInput = {
    AL_ID?: number
    ApplicationID?: number | null
    Subject?: string | null
    Grade?: string | null
  }

  export type gce_al_resultsUpdateManyMutationInput = {
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gce_al_resultsUncheckedUpdateManyInput = {
    AL_ID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gce_ol_resultsCreateInput = {
    Subject?: string | null
    Grade?: string | null
    application?: applicationCreateNestedOneWithoutGce_ol_resultsInput
  }

  export type gce_ol_resultsUncheckedCreateInput = {
    OL_ID?: number
    ApplicationID?: number | null
    Subject?: string | null
    Grade?: string | null
  }

  export type gce_ol_resultsUpdateInput = {
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Grade?: NullableStringFieldUpdateOperationsInput | string | null
    application?: applicationUpdateOneWithoutGce_ol_resultsNestedInput
  }

  export type gce_ol_resultsUncheckedUpdateInput = {
    OL_ID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gce_ol_resultsCreateManyInput = {
    OL_ID?: number
    ApplicationID?: number | null
    Subject?: string | null
    Grade?: string | null
  }

  export type gce_ol_resultsUpdateManyMutationInput = {
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gce_ol_resultsUncheckedUpdateManyInput = {
    OL_ID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type jobvacancyCreateInput = {
    Title?: string | null
    Description?: string | null
    Type?: $Enums.jobvacancy_Type | null
    Department?: string | null
    Level?: string | null
    PostedDate?: Date | string | null
    ExpiryDate?: Date | string | null
    Status?: $Enums.jobvacancy_Status | null
    application?: applicationCreateNestedManyWithoutJobvacancyInput
    admin?: adminCreateNestedOneWithoutJobvacancyInput
    applicationtemplate?: applicationtemplateCreateNestedOneWithoutJobvacancyInput
  }

  export type jobvacancyUncheckedCreateInput = {
    JobID?: number
    Title?: string | null
    Description?: string | null
    Type?: $Enums.jobvacancy_Type | null
    Department?: string | null
    Level?: string | null
    PostedBy?: number | null
    PostedDate?: Date | string | null
    ExpiryDate?: Date | string | null
    Status?: $Enums.jobvacancy_Status | null
    TemplateID?: number | null
    application?: applicationUncheckedCreateNestedManyWithoutJobvacancyInput
  }

  export type jobvacancyUpdateInput = {
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableEnumjobvacancy_TypeFieldUpdateOperationsInput | $Enums.jobvacancy_Type | null
    Department?: NullableStringFieldUpdateOperationsInput | string | null
    Level?: NullableStringFieldUpdateOperationsInput | string | null
    PostedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumjobvacancy_StatusFieldUpdateOperationsInput | $Enums.jobvacancy_Status | null
    application?: applicationUpdateManyWithoutJobvacancyNestedInput
    admin?: adminUpdateOneWithoutJobvacancyNestedInput
    applicationtemplate?: applicationtemplateUpdateOneWithoutJobvacancyNestedInput
  }

  export type jobvacancyUncheckedUpdateInput = {
    JobID?: IntFieldUpdateOperationsInput | number
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableEnumjobvacancy_TypeFieldUpdateOperationsInput | $Enums.jobvacancy_Type | null
    Department?: NullableStringFieldUpdateOperationsInput | string | null
    Level?: NullableStringFieldUpdateOperationsInput | string | null
    PostedBy?: NullableIntFieldUpdateOperationsInput | number | null
    PostedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumjobvacancy_StatusFieldUpdateOperationsInput | $Enums.jobvacancy_Status | null
    TemplateID?: NullableIntFieldUpdateOperationsInput | number | null
    application?: applicationUncheckedUpdateManyWithoutJobvacancyNestedInput
  }

  export type jobvacancyCreateManyInput = {
    JobID?: number
    Title?: string | null
    Description?: string | null
    Type?: $Enums.jobvacancy_Type | null
    Department?: string | null
    Level?: string | null
    PostedBy?: number | null
    PostedDate?: Date | string | null
    ExpiryDate?: Date | string | null
    Status?: $Enums.jobvacancy_Status | null
    TemplateID?: number | null
  }

  export type jobvacancyUpdateManyMutationInput = {
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableEnumjobvacancy_TypeFieldUpdateOperationsInput | $Enums.jobvacancy_Type | null
    Department?: NullableStringFieldUpdateOperationsInput | string | null
    Level?: NullableStringFieldUpdateOperationsInput | string | null
    PostedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumjobvacancy_StatusFieldUpdateOperationsInput | $Enums.jobvacancy_Status | null
  }

  export type jobvacancyUncheckedUpdateManyInput = {
    JobID?: IntFieldUpdateOperationsInput | number
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableEnumjobvacancy_TypeFieldUpdateOperationsInput | $Enums.jobvacancy_Type | null
    Department?: NullableStringFieldUpdateOperationsInput | string | null
    Level?: NullableStringFieldUpdateOperationsInput | string | null
    PostedBy?: NullableIntFieldUpdateOperationsInput | number | null
    PostedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumjobvacancy_StatusFieldUpdateOperationsInput | $Enums.jobvacancy_Status | null
    TemplateID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type languageproficienciesCreateInput = {
    Language?: string | null
    CanSpeak?: $Enums.languageproficiencies_CanSpeak | null
    CanRead?: $Enums.languageproficiencies_CanRead | null
    CanWrite?: $Enums.languageproficiencies_CanWrite | null
    CanTeach?: $Enums.languageproficiencies_CanTeach | null
    application?: applicationCreateNestedOneWithoutLanguageproficienciesInput
  }

  export type languageproficienciesUncheckedCreateInput = {
    LangProfID?: number
    ApplicationID?: number | null
    Language?: string | null
    CanSpeak?: $Enums.languageproficiencies_CanSpeak | null
    CanRead?: $Enums.languageproficiencies_CanRead | null
    CanWrite?: $Enums.languageproficiencies_CanWrite | null
    CanTeach?: $Enums.languageproficiencies_CanTeach | null
  }

  export type languageproficienciesUpdateInput = {
    Language?: NullableStringFieldUpdateOperationsInput | string | null
    CanSpeak?: NullableEnumlanguageproficiencies_CanSpeakFieldUpdateOperationsInput | $Enums.languageproficiencies_CanSpeak | null
    CanRead?: NullableEnumlanguageproficiencies_CanReadFieldUpdateOperationsInput | $Enums.languageproficiencies_CanRead | null
    CanWrite?: NullableEnumlanguageproficiencies_CanWriteFieldUpdateOperationsInput | $Enums.languageproficiencies_CanWrite | null
    CanTeach?: NullableEnumlanguageproficiencies_CanTeachFieldUpdateOperationsInput | $Enums.languageproficiencies_CanTeach | null
    application?: applicationUpdateOneWithoutLanguageproficienciesNestedInput
  }

  export type languageproficienciesUncheckedUpdateInput = {
    LangProfID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    Language?: NullableStringFieldUpdateOperationsInput | string | null
    CanSpeak?: NullableEnumlanguageproficiencies_CanSpeakFieldUpdateOperationsInput | $Enums.languageproficiencies_CanSpeak | null
    CanRead?: NullableEnumlanguageproficiencies_CanReadFieldUpdateOperationsInput | $Enums.languageproficiencies_CanRead | null
    CanWrite?: NullableEnumlanguageproficiencies_CanWriteFieldUpdateOperationsInput | $Enums.languageproficiencies_CanWrite | null
    CanTeach?: NullableEnumlanguageproficiencies_CanTeachFieldUpdateOperationsInput | $Enums.languageproficiencies_CanTeach | null
  }

  export type languageproficienciesCreateManyInput = {
    LangProfID?: number
    ApplicationID?: number | null
    Language?: string | null
    CanSpeak?: $Enums.languageproficiencies_CanSpeak | null
    CanRead?: $Enums.languageproficiencies_CanRead | null
    CanWrite?: $Enums.languageproficiencies_CanWrite | null
    CanTeach?: $Enums.languageproficiencies_CanTeach | null
  }

  export type languageproficienciesUpdateManyMutationInput = {
    Language?: NullableStringFieldUpdateOperationsInput | string | null
    CanSpeak?: NullableEnumlanguageproficiencies_CanSpeakFieldUpdateOperationsInput | $Enums.languageproficiencies_CanSpeak | null
    CanRead?: NullableEnumlanguageproficiencies_CanReadFieldUpdateOperationsInput | $Enums.languageproficiencies_CanRead | null
    CanWrite?: NullableEnumlanguageproficiencies_CanWriteFieldUpdateOperationsInput | $Enums.languageproficiencies_CanWrite | null
    CanTeach?: NullableEnumlanguageproficiencies_CanTeachFieldUpdateOperationsInput | $Enums.languageproficiencies_CanTeach | null
  }

  export type languageproficienciesUncheckedUpdateManyInput = {
    LangProfID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    Language?: NullableStringFieldUpdateOperationsInput | string | null
    CanSpeak?: NullableEnumlanguageproficiencies_CanSpeakFieldUpdateOperationsInput | $Enums.languageproficiencies_CanSpeak | null
    CanRead?: NullableEnumlanguageproficiencies_CanReadFieldUpdateOperationsInput | $Enums.languageproficiencies_CanRead | null
    CanWrite?: NullableEnumlanguageproficiencies_CanWriteFieldUpdateOperationsInput | $Enums.languageproficiencies_CanWrite | null
    CanTeach?: NullableEnumlanguageproficiencies_CanTeachFieldUpdateOperationsInput | $Enums.languageproficiencies_CanTeach | null
  }

  export type professionalqualificationsCreateInput = {
    Institution?: string | null
    QualificationName?: string | null
    FromYear?: number | null
    ToYear?: number | null
    ResultOrExamPassed?: string | null
    application?: applicationCreateNestedOneWithoutProfessionalqualificationsInput
  }

  export type professionalqualificationsUncheckedCreateInput = {
    PQ_ID?: number
    ApplicationID?: number | null
    Institution?: string | null
    QualificationName?: string | null
    FromYear?: number | null
    ToYear?: number | null
    ResultOrExamPassed?: string | null
  }

  export type professionalqualificationsUpdateInput = {
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
    QualificationName?: NullableStringFieldUpdateOperationsInput | string | null
    FromYear?: NullableIntFieldUpdateOperationsInput | number | null
    ToYear?: NullableIntFieldUpdateOperationsInput | number | null
    ResultOrExamPassed?: NullableStringFieldUpdateOperationsInput | string | null
    application?: applicationUpdateOneWithoutProfessionalqualificationsNestedInput
  }

  export type professionalqualificationsUncheckedUpdateInput = {
    PQ_ID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
    QualificationName?: NullableStringFieldUpdateOperationsInput | string | null
    FromYear?: NullableIntFieldUpdateOperationsInput | number | null
    ToYear?: NullableIntFieldUpdateOperationsInput | number | null
    ResultOrExamPassed?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type professionalqualificationsCreateManyInput = {
    PQ_ID?: number
    ApplicationID?: number | null
    Institution?: string | null
    QualificationName?: string | null
    FromYear?: number | null
    ToYear?: number | null
    ResultOrExamPassed?: string | null
  }

  export type professionalqualificationsUpdateManyMutationInput = {
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
    QualificationName?: NullableStringFieldUpdateOperationsInput | string | null
    FromYear?: NullableIntFieldUpdateOperationsInput | number | null
    ToYear?: NullableIntFieldUpdateOperationsInput | number | null
    ResultOrExamPassed?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type professionalqualificationsUncheckedUpdateManyInput = {
    PQ_ID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
    QualificationName?: NullableStringFieldUpdateOperationsInput | string | null
    FromYear?: NullableIntFieldUpdateOperationsInput | number | null
    ToYear?: NullableIntFieldUpdateOperationsInput | number | null
    ResultOrExamPassed?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type researchandpublicationsCreateInput = {
    Description?: string | null
    application?: applicationCreateNestedOneWithoutResearchandpublicationsInput
  }

  export type researchandpublicationsUncheckedCreateInput = {
    ResearchID?: number
    ApplicationID?: number | null
    Description?: string | null
  }

  export type researchandpublicationsUpdateInput = {
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    application?: applicationUpdateOneWithoutResearchandpublicationsNestedInput
  }

  export type researchandpublicationsUncheckedUpdateInput = {
    ResearchID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type researchandpublicationsCreateManyInput = {
    ResearchID?: number
    ApplicationID?: number | null
    Description?: string | null
  }

  export type researchandpublicationsUpdateManyMutationInput = {
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type researchandpublicationsUncheckedUpdateManyInput = {
    ResearchID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type specialqualificationsCreateInput = {
    Description?: string | null
    application?: applicationCreateNestedOneWithoutSpecialqualificationsInput
  }

  export type specialqualificationsUncheckedCreateInput = {
    SpecialQualID?: number
    ApplicationID?: number | null
    Description?: string | null
  }

  export type specialqualificationsUpdateInput = {
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    application?: applicationUpdateOneWithoutSpecialqualificationsNestedInput
  }

  export type specialqualificationsUncheckedUpdateInput = {
    SpecialQualID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type specialqualificationsCreateManyInput = {
    SpecialQualID?: number
    ApplicationID?: number | null
    Description?: string | null
  }

  export type specialqualificationsUpdateManyMutationInput = {
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type specialqualificationsUncheckedUpdateManyInput = {
    SpecialQualID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type superadminCreateInput = {
    FullName?: string | null
    Email?: string | null
    PasswordHash?: string | null
    PhoneNumber?: string | null
    CreatedAt?: Date | string | null
  }

  export type superadminUncheckedCreateInput = {
    SuperAdminID?: number
    FullName?: string | null
    Email?: string | null
    PasswordHash?: string | null
    PhoneNumber?: string | null
    CreatedAt?: Date | string | null
  }

  export type superadminUpdateInput = {
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type superadminUncheckedUpdateInput = {
    SuperAdminID?: IntFieldUpdateOperationsInput | number
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type superadminCreateManyInput = {
    SuperAdminID?: number
    FullName?: string | null
    Email?: string | null
    PasswordHash?: string | null
    PhoneNumber?: string | null
    CreatedAt?: Date | string | null
  }

  export type superadminUpdateManyMutationInput = {
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type superadminUncheckedUpdateManyInput = {
    SuperAdminID?: IntFieldUpdateOperationsInput | number
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type universityeducationsCreateInput = {
    DegreeOrDiploma?: string | null
    Institute?: string | null
    FromYear?: number | null
    ToYear?: number | null
    Class?: string | null
    YearObtained?: number | null
    IndexNumber?: string | null
    application?: applicationCreateNestedOneWithoutUniversityeducationsInput
  }

  export type universityeducationsUncheckedCreateInput = {
    UE_ID?: number
    ApplicationID?: number | null
    DegreeOrDiploma?: string | null
    Institute?: string | null
    FromYear?: number | null
    ToYear?: number | null
    Class?: string | null
    YearObtained?: number | null
    IndexNumber?: string | null
  }

  export type universityeducationsUpdateInput = {
    DegreeOrDiploma?: NullableStringFieldUpdateOperationsInput | string | null
    Institute?: NullableStringFieldUpdateOperationsInput | string | null
    FromYear?: NullableIntFieldUpdateOperationsInput | number | null
    ToYear?: NullableIntFieldUpdateOperationsInput | number | null
    Class?: NullableStringFieldUpdateOperationsInput | string | null
    YearObtained?: NullableIntFieldUpdateOperationsInput | number | null
    IndexNumber?: NullableStringFieldUpdateOperationsInput | string | null
    application?: applicationUpdateOneWithoutUniversityeducationsNestedInput
  }

  export type universityeducationsUncheckedUpdateInput = {
    UE_ID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    DegreeOrDiploma?: NullableStringFieldUpdateOperationsInput | string | null
    Institute?: NullableStringFieldUpdateOperationsInput | string | null
    FromYear?: NullableIntFieldUpdateOperationsInput | number | null
    ToYear?: NullableIntFieldUpdateOperationsInput | number | null
    Class?: NullableStringFieldUpdateOperationsInput | string | null
    YearObtained?: NullableIntFieldUpdateOperationsInput | number | null
    IndexNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type universityeducationsCreateManyInput = {
    UE_ID?: number
    ApplicationID?: number | null
    DegreeOrDiploma?: string | null
    Institute?: string | null
    FromYear?: number | null
    ToYear?: number | null
    Class?: string | null
    YearObtained?: number | null
    IndexNumber?: string | null
  }

  export type universityeducationsUpdateManyMutationInput = {
    DegreeOrDiploma?: NullableStringFieldUpdateOperationsInput | string | null
    Institute?: NullableStringFieldUpdateOperationsInput | string | null
    FromYear?: NullableIntFieldUpdateOperationsInput | number | null
    ToYear?: NullableIntFieldUpdateOperationsInput | number | null
    Class?: NullableStringFieldUpdateOperationsInput | string | null
    YearObtained?: NullableIntFieldUpdateOperationsInput | number | null
    IndexNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type universityeducationsUncheckedUpdateManyInput = {
    UE_ID?: IntFieldUpdateOperationsInput | number
    ApplicationID?: NullableIntFieldUpdateOperationsInput | number | null
    DegreeOrDiploma?: NullableStringFieldUpdateOperationsInput | string | null
    Institute?: NullableStringFieldUpdateOperationsInput | string | null
    FromYear?: NullableIntFieldUpdateOperationsInput | number | null
    ToYear?: NullableIntFieldUpdateOperationsInput | number | null
    Class?: NullableStringFieldUpdateOperationsInput | string | null
    YearObtained?: NullableIntFieldUpdateOperationsInput | number | null
    IndexNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userCreateInput = {
    FullName?: string | null
    Email?: string | null
    PasswordHash?: string | null
    NIC?: string | null
    PhoneNumber?: string | null
    Address?: string | null
    AccountStatus?: $Enums.user_AccountStatus | null
    CreatedAt?: Date | string | null
    UpdatedAt?: Date | string | null
    application?: applicationCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    UserID?: number
    FullName?: string | null
    Email?: string | null
    PasswordHash?: string | null
    NIC?: string | null
    PhoneNumber?: string | null
    Address?: string | null
    AccountStatus?: $Enums.user_AccountStatus | null
    CreatedAt?: Date | string | null
    UpdatedAt?: Date | string | null
    application?: applicationUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    AccountStatus?: NullableEnumuser_AccountStatusFieldUpdateOperationsInput | $Enums.user_AccountStatus | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    application?: applicationUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    UserID?: IntFieldUpdateOperationsInput | number
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    AccountStatus?: NullableEnumuser_AccountStatusFieldUpdateOperationsInput | $Enums.user_AccountStatus | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    application?: applicationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    UserID?: number
    FullName?: string | null
    Email?: string | null
    PasswordHash?: string | null
    NIC?: string | null
    PhoneNumber?: string | null
    Address?: string | null
    AccountStatus?: $Enums.user_AccountStatus | null
    CreatedAt?: Date | string | null
    UpdatedAt?: Date | string | null
  }

  export type userUpdateManyMutationInput = {
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    AccountStatus?: NullableEnumuser_AccountStatusFieldUpdateOperationsInput | $Enums.user_AccountStatus | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUncheckedUpdateManyInput = {
    UserID?: IntFieldUpdateOperationsInput | number
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    AccountStatus?: NullableEnumuser_AccountStatusFieldUpdateOperationsInput | $Enums.user_AccountStatus | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ApplicationNullableScalarRelationFilter = {
    is?: applicationWhereInput | null
    isNot?: applicationWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type additionalinfoOrderByRelevanceInput = {
    fields: additionalinfoOrderByRelevanceFieldEnum | additionalinfoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type additionalinfoCountOrderByAggregateInput = {
    InfoID?: SortOrder
    ApplicationID?: SortOrder
    Content?: SortOrder
  }

  export type additionalinfoAvgOrderByAggregateInput = {
    InfoID?: SortOrder
    ApplicationID?: SortOrder
  }

  export type additionalinfoMaxOrderByAggregateInput = {
    InfoID?: SortOrder
    ApplicationID?: SortOrder
    Content?: SortOrder
  }

  export type additionalinfoMinOrderByAggregateInput = {
    InfoID?: SortOrder
    ApplicationID?: SortOrder
    Content?: SortOrder
  }

  export type additionalinfoSumOrderByAggregateInput = {
    InfoID?: SortOrder
    ApplicationID?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ApplicationtemplateListRelationFilter = {
    every?: applicationtemplateWhereInput
    some?: applicationtemplateWhereInput
    none?: applicationtemplateWhereInput
  }

  export type JobvacancyListRelationFilter = {
    every?: jobvacancyWhereInput
    some?: jobvacancyWhereInput
    none?: jobvacancyWhereInput
  }

  export type applicationtemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type jobvacancyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type adminOrderByRelevanceInput = {
    fields: adminOrderByRelevanceFieldEnum | adminOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type adminCountOrderByAggregateInput = {
    AdminID?: SortOrder
    FullName?: SortOrder
    Email?: SortOrder
    PasswordHash?: SortOrder
    Department?: SortOrder
    PhoneNumber?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type adminAvgOrderByAggregateInput = {
    AdminID?: SortOrder
  }

  export type adminMaxOrderByAggregateInput = {
    AdminID?: SortOrder
    FullName?: SortOrder
    Email?: SortOrder
    PasswordHash?: SortOrder
    Department?: SortOrder
    PhoneNumber?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type adminMinOrderByAggregateInput = {
    AdminID?: SortOrder
    FullName?: SortOrder
    Email?: SortOrder
    PasswordHash?: SortOrder
    Department?: SortOrder
    PhoneNumber?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type adminSumOrderByAggregateInput = {
    AdminID?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type Enumapplication_StatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.application_Status | Enumapplication_StatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.application_Status[] | null
    notIn?: $Enums.application_Status[] | null
    not?: NestedEnumapplication_StatusNullableFilter<$PrismaModel> | $Enums.application_Status | null
  }

  export type AdditionalinfoListRelationFilter = {
    every?: additionalinfoWhereInput
    some?: additionalinfoWhereInput
    none?: additionalinfoWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type JobvacancyNullableScalarRelationFilter = {
    is?: jobvacancyWhereInput | null
    isNot?: jobvacancyWhereInput | null
  }

  export type ApplicationattachmentsListRelationFilter = {
    every?: applicationattachmentsWhereInput
    some?: applicationattachmentsWhereInput
    none?: applicationattachmentsWhereInput
  }

  export type ApplicationgeneraldetailsNullableScalarRelationFilter = {
    is?: applicationgeneraldetailsWhereInput | null
    isNot?: applicationgeneraldetailsWhereInput | null
  }

  export type ApplicationreferencesListRelationFilter = {
    every?: applicationreferencesWhereInput
    some?: applicationreferencesWhereInput
    none?: applicationreferencesWhereInput
  }

  export type EmploymenthistoriesListRelationFilter = {
    every?: employmenthistoriesWhereInput
    some?: employmenthistoriesWhereInput
    none?: employmenthistoriesWhereInput
  }

  export type ExperiencedetailsListRelationFilter = {
    every?: experiencedetailsWhereInput
    some?: experiencedetailsWhereInput
    none?: experiencedetailsWhereInput
  }

  export type Gce_al_resultsListRelationFilter = {
    every?: gce_al_resultsWhereInput
    some?: gce_al_resultsWhereInput
    none?: gce_al_resultsWhereInput
  }

  export type Gce_ol_resultsListRelationFilter = {
    every?: gce_ol_resultsWhereInput
    some?: gce_ol_resultsWhereInput
    none?: gce_ol_resultsWhereInput
  }

  export type LanguageproficienciesListRelationFilter = {
    every?: languageproficienciesWhereInput
    some?: languageproficienciesWhereInput
    none?: languageproficienciesWhereInput
  }

  export type ProfessionalqualificationsListRelationFilter = {
    every?: professionalqualificationsWhereInput
    some?: professionalqualificationsWhereInput
    none?: professionalqualificationsWhereInput
  }

  export type ResearchandpublicationsListRelationFilter = {
    every?: researchandpublicationsWhereInput
    some?: researchandpublicationsWhereInput
    none?: researchandpublicationsWhereInput
  }

  export type SpecialqualificationsListRelationFilter = {
    every?: specialqualificationsWhereInput
    some?: specialqualificationsWhereInput
    none?: specialqualificationsWhereInput
  }

  export type UniversityeducationsListRelationFilter = {
    every?: universityeducationsWhereInput
    some?: universityeducationsWhereInput
    none?: universityeducationsWhereInput
  }

  export type additionalinfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type applicationattachmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type applicationreferencesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type employmenthistoriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type experiencedetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type gce_al_resultsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type gce_ol_resultsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type languageproficienciesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type professionalqualificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type researchandpublicationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type specialqualificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type universityeducationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type applicationOrderByRelevanceInput = {
    fields: applicationOrderByRelevanceFieldEnum | applicationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type applicationCountOrderByAggregateInput = {
    ApplicationID?: SortOrder
    UserID?: SortOrder
    JobID?: SortOrder
    SubmissionDate?: SortOrder
    Status?: SortOrder
    Remarks?: SortOrder
  }

  export type applicationAvgOrderByAggregateInput = {
    ApplicationID?: SortOrder
    UserID?: SortOrder
    JobID?: SortOrder
  }

  export type applicationMaxOrderByAggregateInput = {
    ApplicationID?: SortOrder
    UserID?: SortOrder
    JobID?: SortOrder
    SubmissionDate?: SortOrder
    Status?: SortOrder
    Remarks?: SortOrder
  }

  export type applicationMinOrderByAggregateInput = {
    ApplicationID?: SortOrder
    UserID?: SortOrder
    JobID?: SortOrder
    SubmissionDate?: SortOrder
    Status?: SortOrder
    Remarks?: SortOrder
  }

  export type applicationSumOrderByAggregateInput = {
    ApplicationID?: SortOrder
    UserID?: SortOrder
    JobID?: SortOrder
  }

  export type Enumapplication_StatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.application_Status | Enumapplication_StatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.application_Status[] | null
    notIn?: $Enums.application_Status[] | null
    not?: NestedEnumapplication_StatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.application_Status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumapplication_StatusNullableFilter<$PrismaModel>
    _max?: NestedEnumapplication_StatusNullableFilter<$PrismaModel>
  }

  export type applicationattachmentsOrderByRelevanceInput = {
    fields: applicationattachmentsOrderByRelevanceFieldEnum | applicationattachmentsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type applicationattachmentsCountOrderByAggregateInput = {
    AttachmentID?: SortOrder
    ApplicationID?: SortOrder
    FileType?: SortOrder
    FilePath?: SortOrder
    UploadedAt?: SortOrder
  }

  export type applicationattachmentsAvgOrderByAggregateInput = {
    AttachmentID?: SortOrder
    ApplicationID?: SortOrder
  }

  export type applicationattachmentsMaxOrderByAggregateInput = {
    AttachmentID?: SortOrder
    ApplicationID?: SortOrder
    FileType?: SortOrder
    FilePath?: SortOrder
    UploadedAt?: SortOrder
  }

  export type applicationattachmentsMinOrderByAggregateInput = {
    AttachmentID?: SortOrder
    ApplicationID?: SortOrder
    FileType?: SortOrder
    FilePath?: SortOrder
    UploadedAt?: SortOrder
  }

  export type applicationattachmentsSumOrderByAggregateInput = {
    AttachmentID?: SortOrder
    ApplicationID?: SortOrder
  }

  export type Enumapplicationgeneraldetails_GenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.applicationgeneraldetails_Gender | Enumapplicationgeneraldetails_GenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.applicationgeneraldetails_Gender[] | null
    notIn?: $Enums.applicationgeneraldetails_Gender[] | null
    not?: NestedEnumapplicationgeneraldetails_GenderNullableFilter<$PrismaModel> | $Enums.applicationgeneraldetails_Gender | null
  }

  export type Enumapplicationgeneraldetails_CitizenshipTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.applicationgeneraldetails_CitizenshipType | Enumapplicationgeneraldetails_CitizenshipTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.applicationgeneraldetails_CitizenshipType[] | null
    notIn?: $Enums.applicationgeneraldetails_CitizenshipType[] | null
    not?: NestedEnumapplicationgeneraldetails_CitizenshipTypeNullableFilter<$PrismaModel> | $Enums.applicationgeneraldetails_CitizenshipType | null
  }

  export type ApplicationScalarRelationFilter = {
    is?: applicationWhereInput
    isNot?: applicationWhereInput
  }

  export type applicationgeneraldetailsOrderByRelevanceInput = {
    fields: applicationgeneraldetailsOrderByRelevanceFieldEnum | applicationgeneraldetailsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type applicationgeneraldetailsCountOrderByAggregateInput = {
    ApplicationID?: SortOrder
    PostApplied?: SortOrder
    FullName?: SortOrder
    NameWithInitials?: SortOrder
    NIC?: SortOrder
    DOB?: SortOrder
    Gender?: SortOrder
    PhoneNumber?: SortOrder
    Email?: SortOrder
    PresentAddress?: SortOrder
    PermanentAddress?: SortOrder
    CivilStatus?: SortOrder
    CitizenshipType?: SortOrder
    CitizenshipDetails?: SortOrder
    EthnicityOrReligion?: SortOrder
  }

  export type applicationgeneraldetailsAvgOrderByAggregateInput = {
    ApplicationID?: SortOrder
  }

  export type applicationgeneraldetailsMaxOrderByAggregateInput = {
    ApplicationID?: SortOrder
    PostApplied?: SortOrder
    FullName?: SortOrder
    NameWithInitials?: SortOrder
    NIC?: SortOrder
    DOB?: SortOrder
    Gender?: SortOrder
    PhoneNumber?: SortOrder
    Email?: SortOrder
    PresentAddress?: SortOrder
    PermanentAddress?: SortOrder
    CivilStatus?: SortOrder
    CitizenshipType?: SortOrder
    CitizenshipDetails?: SortOrder
    EthnicityOrReligion?: SortOrder
  }

  export type applicationgeneraldetailsMinOrderByAggregateInput = {
    ApplicationID?: SortOrder
    PostApplied?: SortOrder
    FullName?: SortOrder
    NameWithInitials?: SortOrder
    NIC?: SortOrder
    DOB?: SortOrder
    Gender?: SortOrder
    PhoneNumber?: SortOrder
    Email?: SortOrder
    PresentAddress?: SortOrder
    PermanentAddress?: SortOrder
    CivilStatus?: SortOrder
    CitizenshipType?: SortOrder
    CitizenshipDetails?: SortOrder
    EthnicityOrReligion?: SortOrder
  }

  export type applicationgeneraldetailsSumOrderByAggregateInput = {
    ApplicationID?: SortOrder
  }

  export type Enumapplicationgeneraldetails_GenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.applicationgeneraldetails_Gender | Enumapplicationgeneraldetails_GenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.applicationgeneraldetails_Gender[] | null
    notIn?: $Enums.applicationgeneraldetails_Gender[] | null
    not?: NestedEnumapplicationgeneraldetails_GenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.applicationgeneraldetails_Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumapplicationgeneraldetails_GenderNullableFilter<$PrismaModel>
    _max?: NestedEnumapplicationgeneraldetails_GenderNullableFilter<$PrismaModel>
  }

  export type Enumapplicationgeneraldetails_CitizenshipTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.applicationgeneraldetails_CitizenshipType | Enumapplicationgeneraldetails_CitizenshipTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.applicationgeneraldetails_CitizenshipType[] | null
    notIn?: $Enums.applicationgeneraldetails_CitizenshipType[] | null
    not?: NestedEnumapplicationgeneraldetails_CitizenshipTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.applicationgeneraldetails_CitizenshipType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumapplicationgeneraldetails_CitizenshipTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumapplicationgeneraldetails_CitizenshipTypeNullableFilter<$PrismaModel>
  }

  export type applicationreferencesOrderByRelevanceInput = {
    fields: applicationreferencesOrderByRelevanceFieldEnum | applicationreferencesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type applicationreferencesCountOrderByAggregateInput = {
    ReferenceID?: SortOrder
    ApplicationID?: SortOrder
    Name?: SortOrder
    Designation?: SortOrder
    Address?: SortOrder
  }

  export type applicationreferencesAvgOrderByAggregateInput = {
    ReferenceID?: SortOrder
    ApplicationID?: SortOrder
  }

  export type applicationreferencesMaxOrderByAggregateInput = {
    ReferenceID?: SortOrder
    ApplicationID?: SortOrder
    Name?: SortOrder
    Designation?: SortOrder
    Address?: SortOrder
  }

  export type applicationreferencesMinOrderByAggregateInput = {
    ReferenceID?: SortOrder
    ApplicationID?: SortOrder
    Name?: SortOrder
    Designation?: SortOrder
    Address?: SortOrder
  }

  export type applicationreferencesSumOrderByAggregateInput = {
    ReferenceID?: SortOrder
    ApplicationID?: SortOrder
  }

  export type Enumapplicationtemplate_TypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.applicationtemplate_Type | Enumapplicationtemplate_TypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.applicationtemplate_Type[] | null
    notIn?: $Enums.applicationtemplate_Type[] | null
    not?: NestedEnumapplicationtemplate_TypeNullableFilter<$PrismaModel> | $Enums.applicationtemplate_Type | null
  }

  export type AdminNullableScalarRelationFilter = {
    is?: adminWhereInput | null
    isNot?: adminWhereInput | null
  }

  export type applicationtemplateOrderByRelevanceInput = {
    fields: applicationtemplateOrderByRelevanceFieldEnum | applicationtemplateOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type applicationtemplateCountOrderByAggregateInput = {
    TemplateID?: SortOrder
    Type?: SortOrder
    FilePath?: SortOrder
    UploadedBy?: SortOrder
    UploadDate?: SortOrder
  }

  export type applicationtemplateAvgOrderByAggregateInput = {
    TemplateID?: SortOrder
    UploadedBy?: SortOrder
  }

  export type applicationtemplateMaxOrderByAggregateInput = {
    TemplateID?: SortOrder
    Type?: SortOrder
    FilePath?: SortOrder
    UploadedBy?: SortOrder
    UploadDate?: SortOrder
  }

  export type applicationtemplateMinOrderByAggregateInput = {
    TemplateID?: SortOrder
    Type?: SortOrder
    FilePath?: SortOrder
    UploadedBy?: SortOrder
    UploadDate?: SortOrder
  }

  export type applicationtemplateSumOrderByAggregateInput = {
    TemplateID?: SortOrder
    UploadedBy?: SortOrder
  }

  export type Enumapplicationtemplate_TypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.applicationtemplate_Type | Enumapplicationtemplate_TypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.applicationtemplate_Type[] | null
    notIn?: $Enums.applicationtemplate_Type[] | null
    not?: NestedEnumapplicationtemplate_TypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.applicationtemplate_Type | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumapplicationtemplate_TypeNullableFilter<$PrismaModel>
    _max?: NestedEnumapplicationtemplate_TypeNullableFilter<$PrismaModel>
  }

  export type Enumauditlog_ActorRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.auditlog_ActorRole | Enumauditlog_ActorRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.auditlog_ActorRole[] | null
    notIn?: $Enums.auditlog_ActorRole[] | null
    not?: NestedEnumauditlog_ActorRoleNullableFilter<$PrismaModel> | $Enums.auditlog_ActorRole | null
  }

  export type auditlogOrderByRelevanceInput = {
    fields: auditlogOrderByRelevanceFieldEnum | auditlogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type auditlogCountOrderByAggregateInput = {
    LogID?: SortOrder
    ActorID?: SortOrder
    ActorRole?: SortOrder
    Action?: SortOrder
    Timestamp?: SortOrder
    Details?: SortOrder
  }

  export type auditlogAvgOrderByAggregateInput = {
    LogID?: SortOrder
    ActorID?: SortOrder
  }

  export type auditlogMaxOrderByAggregateInput = {
    LogID?: SortOrder
    ActorID?: SortOrder
    ActorRole?: SortOrder
    Action?: SortOrder
    Timestamp?: SortOrder
    Details?: SortOrder
  }

  export type auditlogMinOrderByAggregateInput = {
    LogID?: SortOrder
    ActorID?: SortOrder
    ActorRole?: SortOrder
    Action?: SortOrder
    Timestamp?: SortOrder
    Details?: SortOrder
  }

  export type auditlogSumOrderByAggregateInput = {
    LogID?: SortOrder
    ActorID?: SortOrder
  }

  export type Enumauditlog_ActorRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.auditlog_ActorRole | Enumauditlog_ActorRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.auditlog_ActorRole[] | null
    notIn?: $Enums.auditlog_ActorRole[] | null
    not?: NestedEnumauditlog_ActorRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.auditlog_ActorRole | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumauditlog_ActorRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumauditlog_ActorRoleNullableFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type employmenthistoriesOrderByRelevanceInput = {
    fields: employmenthistoriesOrderByRelevanceFieldEnum | employmenthistoriesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type employmenthistoriesCountOrderByAggregateInput = {
    EmploymentID?: SortOrder
    ApplicationID?: SortOrder
    PostHeld?: SortOrder
    Institution?: SortOrder
    FromDate?: SortOrder
    ToDate?: SortOrder
    LastSalary?: SortOrder
  }

  export type employmenthistoriesAvgOrderByAggregateInput = {
    EmploymentID?: SortOrder
    ApplicationID?: SortOrder
    LastSalary?: SortOrder
  }

  export type employmenthistoriesMaxOrderByAggregateInput = {
    EmploymentID?: SortOrder
    ApplicationID?: SortOrder
    PostHeld?: SortOrder
    Institution?: SortOrder
    FromDate?: SortOrder
    ToDate?: SortOrder
    LastSalary?: SortOrder
  }

  export type employmenthistoriesMinOrderByAggregateInput = {
    EmploymentID?: SortOrder
    ApplicationID?: SortOrder
    PostHeld?: SortOrder
    Institution?: SortOrder
    FromDate?: SortOrder
    ToDate?: SortOrder
    LastSalary?: SortOrder
  }

  export type employmenthistoriesSumOrderByAggregateInput = {
    EmploymentID?: SortOrder
    ApplicationID?: SortOrder
    LastSalary?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type experiencedetailsOrderByRelevanceInput = {
    fields: experiencedetailsOrderByRelevanceFieldEnum | experiencedetailsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type experiencedetailsCountOrderByAggregateInput = {
    ExperienceID?: SortOrder
    ApplicationID?: SortOrder
    Description?: SortOrder
  }

  export type experiencedetailsAvgOrderByAggregateInput = {
    ExperienceID?: SortOrder
    ApplicationID?: SortOrder
  }

  export type experiencedetailsMaxOrderByAggregateInput = {
    ExperienceID?: SortOrder
    ApplicationID?: SortOrder
    Description?: SortOrder
  }

  export type experiencedetailsMinOrderByAggregateInput = {
    ExperienceID?: SortOrder
    ApplicationID?: SortOrder
    Description?: SortOrder
  }

  export type experiencedetailsSumOrderByAggregateInput = {
    ExperienceID?: SortOrder
    ApplicationID?: SortOrder
  }

  export type gce_al_resultsOrderByRelevanceInput = {
    fields: gce_al_resultsOrderByRelevanceFieldEnum | gce_al_resultsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type gce_al_resultsCountOrderByAggregateInput = {
    AL_ID?: SortOrder
    ApplicationID?: SortOrder
    Subject?: SortOrder
    Grade?: SortOrder
  }

  export type gce_al_resultsAvgOrderByAggregateInput = {
    AL_ID?: SortOrder
    ApplicationID?: SortOrder
  }

  export type gce_al_resultsMaxOrderByAggregateInput = {
    AL_ID?: SortOrder
    ApplicationID?: SortOrder
    Subject?: SortOrder
    Grade?: SortOrder
  }

  export type gce_al_resultsMinOrderByAggregateInput = {
    AL_ID?: SortOrder
    ApplicationID?: SortOrder
    Subject?: SortOrder
    Grade?: SortOrder
  }

  export type gce_al_resultsSumOrderByAggregateInput = {
    AL_ID?: SortOrder
    ApplicationID?: SortOrder
  }

  export type gce_ol_resultsOrderByRelevanceInput = {
    fields: gce_ol_resultsOrderByRelevanceFieldEnum | gce_ol_resultsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type gce_ol_resultsCountOrderByAggregateInput = {
    OL_ID?: SortOrder
    ApplicationID?: SortOrder
    Subject?: SortOrder
    Grade?: SortOrder
  }

  export type gce_ol_resultsAvgOrderByAggregateInput = {
    OL_ID?: SortOrder
    ApplicationID?: SortOrder
  }

  export type gce_ol_resultsMaxOrderByAggregateInput = {
    OL_ID?: SortOrder
    ApplicationID?: SortOrder
    Subject?: SortOrder
    Grade?: SortOrder
  }

  export type gce_ol_resultsMinOrderByAggregateInput = {
    OL_ID?: SortOrder
    ApplicationID?: SortOrder
    Subject?: SortOrder
    Grade?: SortOrder
  }

  export type gce_ol_resultsSumOrderByAggregateInput = {
    OL_ID?: SortOrder
    ApplicationID?: SortOrder
  }

  export type Enumjobvacancy_TypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.jobvacancy_Type | Enumjobvacancy_TypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.jobvacancy_Type[] | null
    notIn?: $Enums.jobvacancy_Type[] | null
    not?: NestedEnumjobvacancy_TypeNullableFilter<$PrismaModel> | $Enums.jobvacancy_Type | null
  }

  export type Enumjobvacancy_StatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.jobvacancy_Status | Enumjobvacancy_StatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.jobvacancy_Status[] | null
    notIn?: $Enums.jobvacancy_Status[] | null
    not?: NestedEnumjobvacancy_StatusNullableFilter<$PrismaModel> | $Enums.jobvacancy_Status | null
  }

  export type ApplicationListRelationFilter = {
    every?: applicationWhereInput
    some?: applicationWhereInput
    none?: applicationWhereInput
  }

  export type ApplicationtemplateNullableScalarRelationFilter = {
    is?: applicationtemplateWhereInput | null
    isNot?: applicationtemplateWhereInput | null
  }

  export type applicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type jobvacancyOrderByRelevanceInput = {
    fields: jobvacancyOrderByRelevanceFieldEnum | jobvacancyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type jobvacancyCountOrderByAggregateInput = {
    JobID?: SortOrder
    Title?: SortOrder
    Description?: SortOrder
    Type?: SortOrder
    Department?: SortOrder
    Level?: SortOrder
    PostedBy?: SortOrder
    PostedDate?: SortOrder
    ExpiryDate?: SortOrder
    Status?: SortOrder
    TemplateID?: SortOrder
  }

  export type jobvacancyAvgOrderByAggregateInput = {
    JobID?: SortOrder
    PostedBy?: SortOrder
    TemplateID?: SortOrder
  }

  export type jobvacancyMaxOrderByAggregateInput = {
    JobID?: SortOrder
    Title?: SortOrder
    Description?: SortOrder
    Type?: SortOrder
    Department?: SortOrder
    Level?: SortOrder
    PostedBy?: SortOrder
    PostedDate?: SortOrder
    ExpiryDate?: SortOrder
    Status?: SortOrder
    TemplateID?: SortOrder
  }

  export type jobvacancyMinOrderByAggregateInput = {
    JobID?: SortOrder
    Title?: SortOrder
    Description?: SortOrder
    Type?: SortOrder
    Department?: SortOrder
    Level?: SortOrder
    PostedBy?: SortOrder
    PostedDate?: SortOrder
    ExpiryDate?: SortOrder
    Status?: SortOrder
    TemplateID?: SortOrder
  }

  export type jobvacancySumOrderByAggregateInput = {
    JobID?: SortOrder
    PostedBy?: SortOrder
    TemplateID?: SortOrder
  }

  export type Enumjobvacancy_TypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.jobvacancy_Type | Enumjobvacancy_TypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.jobvacancy_Type[] | null
    notIn?: $Enums.jobvacancy_Type[] | null
    not?: NestedEnumjobvacancy_TypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.jobvacancy_Type | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumjobvacancy_TypeNullableFilter<$PrismaModel>
    _max?: NestedEnumjobvacancy_TypeNullableFilter<$PrismaModel>
  }

  export type Enumjobvacancy_StatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.jobvacancy_Status | Enumjobvacancy_StatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.jobvacancy_Status[] | null
    notIn?: $Enums.jobvacancy_Status[] | null
    not?: NestedEnumjobvacancy_StatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.jobvacancy_Status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumjobvacancy_StatusNullableFilter<$PrismaModel>
    _max?: NestedEnumjobvacancy_StatusNullableFilter<$PrismaModel>
  }

  export type Enumlanguageproficiencies_CanSpeakNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.languageproficiencies_CanSpeak | Enumlanguageproficiencies_CanSpeakFieldRefInput<$PrismaModel> | null
    in?: $Enums.languageproficiencies_CanSpeak[] | null
    notIn?: $Enums.languageproficiencies_CanSpeak[] | null
    not?: NestedEnumlanguageproficiencies_CanSpeakNullableFilter<$PrismaModel> | $Enums.languageproficiencies_CanSpeak | null
  }

  export type Enumlanguageproficiencies_CanReadNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.languageproficiencies_CanRead | Enumlanguageproficiencies_CanReadFieldRefInput<$PrismaModel> | null
    in?: $Enums.languageproficiencies_CanRead[] | null
    notIn?: $Enums.languageproficiencies_CanRead[] | null
    not?: NestedEnumlanguageproficiencies_CanReadNullableFilter<$PrismaModel> | $Enums.languageproficiencies_CanRead | null
  }

  export type Enumlanguageproficiencies_CanWriteNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.languageproficiencies_CanWrite | Enumlanguageproficiencies_CanWriteFieldRefInput<$PrismaModel> | null
    in?: $Enums.languageproficiencies_CanWrite[] | null
    notIn?: $Enums.languageproficiencies_CanWrite[] | null
    not?: NestedEnumlanguageproficiencies_CanWriteNullableFilter<$PrismaModel> | $Enums.languageproficiencies_CanWrite | null
  }

  export type Enumlanguageproficiencies_CanTeachNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.languageproficiencies_CanTeach | Enumlanguageproficiencies_CanTeachFieldRefInput<$PrismaModel> | null
    in?: $Enums.languageproficiencies_CanTeach[] | null
    notIn?: $Enums.languageproficiencies_CanTeach[] | null
    not?: NestedEnumlanguageproficiencies_CanTeachNullableFilter<$PrismaModel> | $Enums.languageproficiencies_CanTeach | null
  }

  export type languageproficienciesOrderByRelevanceInput = {
    fields: languageproficienciesOrderByRelevanceFieldEnum | languageproficienciesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type languageproficienciesCountOrderByAggregateInput = {
    LangProfID?: SortOrder
    ApplicationID?: SortOrder
    Language?: SortOrder
    CanSpeak?: SortOrder
    CanRead?: SortOrder
    CanWrite?: SortOrder
    CanTeach?: SortOrder
  }

  export type languageproficienciesAvgOrderByAggregateInput = {
    LangProfID?: SortOrder
    ApplicationID?: SortOrder
  }

  export type languageproficienciesMaxOrderByAggregateInput = {
    LangProfID?: SortOrder
    ApplicationID?: SortOrder
    Language?: SortOrder
    CanSpeak?: SortOrder
    CanRead?: SortOrder
    CanWrite?: SortOrder
    CanTeach?: SortOrder
  }

  export type languageproficienciesMinOrderByAggregateInput = {
    LangProfID?: SortOrder
    ApplicationID?: SortOrder
    Language?: SortOrder
    CanSpeak?: SortOrder
    CanRead?: SortOrder
    CanWrite?: SortOrder
    CanTeach?: SortOrder
  }

  export type languageproficienciesSumOrderByAggregateInput = {
    LangProfID?: SortOrder
    ApplicationID?: SortOrder
  }

  export type Enumlanguageproficiencies_CanSpeakNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.languageproficiencies_CanSpeak | Enumlanguageproficiencies_CanSpeakFieldRefInput<$PrismaModel> | null
    in?: $Enums.languageproficiencies_CanSpeak[] | null
    notIn?: $Enums.languageproficiencies_CanSpeak[] | null
    not?: NestedEnumlanguageproficiencies_CanSpeakNullableWithAggregatesFilter<$PrismaModel> | $Enums.languageproficiencies_CanSpeak | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumlanguageproficiencies_CanSpeakNullableFilter<$PrismaModel>
    _max?: NestedEnumlanguageproficiencies_CanSpeakNullableFilter<$PrismaModel>
  }

  export type Enumlanguageproficiencies_CanReadNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.languageproficiencies_CanRead | Enumlanguageproficiencies_CanReadFieldRefInput<$PrismaModel> | null
    in?: $Enums.languageproficiencies_CanRead[] | null
    notIn?: $Enums.languageproficiencies_CanRead[] | null
    not?: NestedEnumlanguageproficiencies_CanReadNullableWithAggregatesFilter<$PrismaModel> | $Enums.languageproficiencies_CanRead | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumlanguageproficiencies_CanReadNullableFilter<$PrismaModel>
    _max?: NestedEnumlanguageproficiencies_CanReadNullableFilter<$PrismaModel>
  }

  export type Enumlanguageproficiencies_CanWriteNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.languageproficiencies_CanWrite | Enumlanguageproficiencies_CanWriteFieldRefInput<$PrismaModel> | null
    in?: $Enums.languageproficiencies_CanWrite[] | null
    notIn?: $Enums.languageproficiencies_CanWrite[] | null
    not?: NestedEnumlanguageproficiencies_CanWriteNullableWithAggregatesFilter<$PrismaModel> | $Enums.languageproficiencies_CanWrite | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumlanguageproficiencies_CanWriteNullableFilter<$PrismaModel>
    _max?: NestedEnumlanguageproficiencies_CanWriteNullableFilter<$PrismaModel>
  }

  export type Enumlanguageproficiencies_CanTeachNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.languageproficiencies_CanTeach | Enumlanguageproficiencies_CanTeachFieldRefInput<$PrismaModel> | null
    in?: $Enums.languageproficiencies_CanTeach[] | null
    notIn?: $Enums.languageproficiencies_CanTeach[] | null
    not?: NestedEnumlanguageproficiencies_CanTeachNullableWithAggregatesFilter<$PrismaModel> | $Enums.languageproficiencies_CanTeach | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumlanguageproficiencies_CanTeachNullableFilter<$PrismaModel>
    _max?: NestedEnumlanguageproficiencies_CanTeachNullableFilter<$PrismaModel>
  }

  export type professionalqualificationsOrderByRelevanceInput = {
    fields: professionalqualificationsOrderByRelevanceFieldEnum | professionalqualificationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type professionalqualificationsCountOrderByAggregateInput = {
    PQ_ID?: SortOrder
    ApplicationID?: SortOrder
    Institution?: SortOrder
    QualificationName?: SortOrder
    FromYear?: SortOrder
    ToYear?: SortOrder
    ResultOrExamPassed?: SortOrder
  }

  export type professionalqualificationsAvgOrderByAggregateInput = {
    PQ_ID?: SortOrder
    ApplicationID?: SortOrder
    FromYear?: SortOrder
    ToYear?: SortOrder
  }

  export type professionalqualificationsMaxOrderByAggregateInput = {
    PQ_ID?: SortOrder
    ApplicationID?: SortOrder
    Institution?: SortOrder
    QualificationName?: SortOrder
    FromYear?: SortOrder
    ToYear?: SortOrder
    ResultOrExamPassed?: SortOrder
  }

  export type professionalqualificationsMinOrderByAggregateInput = {
    PQ_ID?: SortOrder
    ApplicationID?: SortOrder
    Institution?: SortOrder
    QualificationName?: SortOrder
    FromYear?: SortOrder
    ToYear?: SortOrder
    ResultOrExamPassed?: SortOrder
  }

  export type professionalqualificationsSumOrderByAggregateInput = {
    PQ_ID?: SortOrder
    ApplicationID?: SortOrder
    FromYear?: SortOrder
    ToYear?: SortOrder
  }

  export type researchandpublicationsOrderByRelevanceInput = {
    fields: researchandpublicationsOrderByRelevanceFieldEnum | researchandpublicationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type researchandpublicationsCountOrderByAggregateInput = {
    ResearchID?: SortOrder
    ApplicationID?: SortOrder
    Description?: SortOrder
  }

  export type researchandpublicationsAvgOrderByAggregateInput = {
    ResearchID?: SortOrder
    ApplicationID?: SortOrder
  }

  export type researchandpublicationsMaxOrderByAggregateInput = {
    ResearchID?: SortOrder
    ApplicationID?: SortOrder
    Description?: SortOrder
  }

  export type researchandpublicationsMinOrderByAggregateInput = {
    ResearchID?: SortOrder
    ApplicationID?: SortOrder
    Description?: SortOrder
  }

  export type researchandpublicationsSumOrderByAggregateInput = {
    ResearchID?: SortOrder
    ApplicationID?: SortOrder
  }

  export type specialqualificationsOrderByRelevanceInput = {
    fields: specialqualificationsOrderByRelevanceFieldEnum | specialqualificationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type specialqualificationsCountOrderByAggregateInput = {
    SpecialQualID?: SortOrder
    ApplicationID?: SortOrder
    Description?: SortOrder
  }

  export type specialqualificationsAvgOrderByAggregateInput = {
    SpecialQualID?: SortOrder
    ApplicationID?: SortOrder
  }

  export type specialqualificationsMaxOrderByAggregateInput = {
    SpecialQualID?: SortOrder
    ApplicationID?: SortOrder
    Description?: SortOrder
  }

  export type specialqualificationsMinOrderByAggregateInput = {
    SpecialQualID?: SortOrder
    ApplicationID?: SortOrder
    Description?: SortOrder
  }

  export type specialqualificationsSumOrderByAggregateInput = {
    SpecialQualID?: SortOrder
    ApplicationID?: SortOrder
  }

  export type superadminOrderByRelevanceInput = {
    fields: superadminOrderByRelevanceFieldEnum | superadminOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type superadminCountOrderByAggregateInput = {
    SuperAdminID?: SortOrder
    FullName?: SortOrder
    Email?: SortOrder
    PasswordHash?: SortOrder
    PhoneNumber?: SortOrder
    CreatedAt?: SortOrder
  }

  export type superadminAvgOrderByAggregateInput = {
    SuperAdminID?: SortOrder
  }

  export type superadminMaxOrderByAggregateInput = {
    SuperAdminID?: SortOrder
    FullName?: SortOrder
    Email?: SortOrder
    PasswordHash?: SortOrder
    PhoneNumber?: SortOrder
    CreatedAt?: SortOrder
  }

  export type superadminMinOrderByAggregateInput = {
    SuperAdminID?: SortOrder
    FullName?: SortOrder
    Email?: SortOrder
    PasswordHash?: SortOrder
    PhoneNumber?: SortOrder
    CreatedAt?: SortOrder
  }

  export type superadminSumOrderByAggregateInput = {
    SuperAdminID?: SortOrder
  }

  export type universityeducationsOrderByRelevanceInput = {
    fields: universityeducationsOrderByRelevanceFieldEnum | universityeducationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type universityeducationsCountOrderByAggregateInput = {
    UE_ID?: SortOrder
    ApplicationID?: SortOrder
    DegreeOrDiploma?: SortOrder
    Institute?: SortOrder
    FromYear?: SortOrder
    ToYear?: SortOrder
    Class?: SortOrder
    YearObtained?: SortOrder
    IndexNumber?: SortOrder
  }

  export type universityeducationsAvgOrderByAggregateInput = {
    UE_ID?: SortOrder
    ApplicationID?: SortOrder
    FromYear?: SortOrder
    ToYear?: SortOrder
    YearObtained?: SortOrder
  }

  export type universityeducationsMaxOrderByAggregateInput = {
    UE_ID?: SortOrder
    ApplicationID?: SortOrder
    DegreeOrDiploma?: SortOrder
    Institute?: SortOrder
    FromYear?: SortOrder
    ToYear?: SortOrder
    Class?: SortOrder
    YearObtained?: SortOrder
    IndexNumber?: SortOrder
  }

  export type universityeducationsMinOrderByAggregateInput = {
    UE_ID?: SortOrder
    ApplicationID?: SortOrder
    DegreeOrDiploma?: SortOrder
    Institute?: SortOrder
    FromYear?: SortOrder
    ToYear?: SortOrder
    Class?: SortOrder
    YearObtained?: SortOrder
    IndexNumber?: SortOrder
  }

  export type universityeducationsSumOrderByAggregateInput = {
    UE_ID?: SortOrder
    ApplicationID?: SortOrder
    FromYear?: SortOrder
    ToYear?: SortOrder
    YearObtained?: SortOrder
  }

  export type Enumuser_AccountStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.user_AccountStatus | Enumuser_AccountStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.user_AccountStatus[] | null
    notIn?: $Enums.user_AccountStatus[] | null
    not?: NestedEnumuser_AccountStatusNullableFilter<$PrismaModel> | $Enums.user_AccountStatus | null
  }

  export type userOrderByRelevanceInput = {
    fields: userOrderByRelevanceFieldEnum | userOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type userCountOrderByAggregateInput = {
    UserID?: SortOrder
    FullName?: SortOrder
    Email?: SortOrder
    PasswordHash?: SortOrder
    NIC?: SortOrder
    PhoneNumber?: SortOrder
    Address?: SortOrder
    AccountStatus?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    UserID?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    UserID?: SortOrder
    FullName?: SortOrder
    Email?: SortOrder
    PasswordHash?: SortOrder
    NIC?: SortOrder
    PhoneNumber?: SortOrder
    Address?: SortOrder
    AccountStatus?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    UserID?: SortOrder
    FullName?: SortOrder
    Email?: SortOrder
    PasswordHash?: SortOrder
    NIC?: SortOrder
    PhoneNumber?: SortOrder
    Address?: SortOrder
    AccountStatus?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    UserID?: SortOrder
  }

  export type Enumuser_AccountStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_AccountStatus | Enumuser_AccountStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.user_AccountStatus[] | null
    notIn?: $Enums.user_AccountStatus[] | null
    not?: NestedEnumuser_AccountStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.user_AccountStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumuser_AccountStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumuser_AccountStatusNullableFilter<$PrismaModel>
  }

  export type applicationCreateNestedOneWithoutAdditionalinfoInput = {
    create?: XOR<applicationCreateWithoutAdditionalinfoInput, applicationUncheckedCreateWithoutAdditionalinfoInput>
    connectOrCreate?: applicationCreateOrConnectWithoutAdditionalinfoInput
    connect?: applicationWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type applicationUpdateOneWithoutAdditionalinfoNestedInput = {
    create?: XOR<applicationCreateWithoutAdditionalinfoInput, applicationUncheckedCreateWithoutAdditionalinfoInput>
    connectOrCreate?: applicationCreateOrConnectWithoutAdditionalinfoInput
    upsert?: applicationUpsertWithoutAdditionalinfoInput
    disconnect?: applicationWhereInput | boolean
    delete?: applicationWhereInput | boolean
    connect?: applicationWhereUniqueInput
    update?: XOR<XOR<applicationUpdateToOneWithWhereWithoutAdditionalinfoInput, applicationUpdateWithoutAdditionalinfoInput>, applicationUncheckedUpdateWithoutAdditionalinfoInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type applicationtemplateCreateNestedManyWithoutAdminInput = {
    create?: XOR<applicationtemplateCreateWithoutAdminInput, applicationtemplateUncheckedCreateWithoutAdminInput> | applicationtemplateCreateWithoutAdminInput[] | applicationtemplateUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: applicationtemplateCreateOrConnectWithoutAdminInput | applicationtemplateCreateOrConnectWithoutAdminInput[]
    createMany?: applicationtemplateCreateManyAdminInputEnvelope
    connect?: applicationtemplateWhereUniqueInput | applicationtemplateWhereUniqueInput[]
  }

  export type jobvacancyCreateNestedManyWithoutAdminInput = {
    create?: XOR<jobvacancyCreateWithoutAdminInput, jobvacancyUncheckedCreateWithoutAdminInput> | jobvacancyCreateWithoutAdminInput[] | jobvacancyUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: jobvacancyCreateOrConnectWithoutAdminInput | jobvacancyCreateOrConnectWithoutAdminInput[]
    createMany?: jobvacancyCreateManyAdminInputEnvelope
    connect?: jobvacancyWhereUniqueInput | jobvacancyWhereUniqueInput[]
  }

  export type applicationtemplateUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<applicationtemplateCreateWithoutAdminInput, applicationtemplateUncheckedCreateWithoutAdminInput> | applicationtemplateCreateWithoutAdminInput[] | applicationtemplateUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: applicationtemplateCreateOrConnectWithoutAdminInput | applicationtemplateCreateOrConnectWithoutAdminInput[]
    createMany?: applicationtemplateCreateManyAdminInputEnvelope
    connect?: applicationtemplateWhereUniqueInput | applicationtemplateWhereUniqueInput[]
  }

  export type jobvacancyUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<jobvacancyCreateWithoutAdminInput, jobvacancyUncheckedCreateWithoutAdminInput> | jobvacancyCreateWithoutAdminInput[] | jobvacancyUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: jobvacancyCreateOrConnectWithoutAdminInput | jobvacancyCreateOrConnectWithoutAdminInput[]
    createMany?: jobvacancyCreateManyAdminInputEnvelope
    connect?: jobvacancyWhereUniqueInput | jobvacancyWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type applicationtemplateUpdateManyWithoutAdminNestedInput = {
    create?: XOR<applicationtemplateCreateWithoutAdminInput, applicationtemplateUncheckedCreateWithoutAdminInput> | applicationtemplateCreateWithoutAdminInput[] | applicationtemplateUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: applicationtemplateCreateOrConnectWithoutAdminInput | applicationtemplateCreateOrConnectWithoutAdminInput[]
    upsert?: applicationtemplateUpsertWithWhereUniqueWithoutAdminInput | applicationtemplateUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: applicationtemplateCreateManyAdminInputEnvelope
    set?: applicationtemplateWhereUniqueInput | applicationtemplateWhereUniqueInput[]
    disconnect?: applicationtemplateWhereUniqueInput | applicationtemplateWhereUniqueInput[]
    delete?: applicationtemplateWhereUniqueInput | applicationtemplateWhereUniqueInput[]
    connect?: applicationtemplateWhereUniqueInput | applicationtemplateWhereUniqueInput[]
    update?: applicationtemplateUpdateWithWhereUniqueWithoutAdminInput | applicationtemplateUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: applicationtemplateUpdateManyWithWhereWithoutAdminInput | applicationtemplateUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: applicationtemplateScalarWhereInput | applicationtemplateScalarWhereInput[]
  }

  export type jobvacancyUpdateManyWithoutAdminNestedInput = {
    create?: XOR<jobvacancyCreateWithoutAdminInput, jobvacancyUncheckedCreateWithoutAdminInput> | jobvacancyCreateWithoutAdminInput[] | jobvacancyUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: jobvacancyCreateOrConnectWithoutAdminInput | jobvacancyCreateOrConnectWithoutAdminInput[]
    upsert?: jobvacancyUpsertWithWhereUniqueWithoutAdminInput | jobvacancyUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: jobvacancyCreateManyAdminInputEnvelope
    set?: jobvacancyWhereUniqueInput | jobvacancyWhereUniqueInput[]
    disconnect?: jobvacancyWhereUniqueInput | jobvacancyWhereUniqueInput[]
    delete?: jobvacancyWhereUniqueInput | jobvacancyWhereUniqueInput[]
    connect?: jobvacancyWhereUniqueInput | jobvacancyWhereUniqueInput[]
    update?: jobvacancyUpdateWithWhereUniqueWithoutAdminInput | jobvacancyUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: jobvacancyUpdateManyWithWhereWithoutAdminInput | jobvacancyUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: jobvacancyScalarWhereInput | jobvacancyScalarWhereInput[]
  }

  export type applicationtemplateUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<applicationtemplateCreateWithoutAdminInput, applicationtemplateUncheckedCreateWithoutAdminInput> | applicationtemplateCreateWithoutAdminInput[] | applicationtemplateUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: applicationtemplateCreateOrConnectWithoutAdminInput | applicationtemplateCreateOrConnectWithoutAdminInput[]
    upsert?: applicationtemplateUpsertWithWhereUniqueWithoutAdminInput | applicationtemplateUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: applicationtemplateCreateManyAdminInputEnvelope
    set?: applicationtemplateWhereUniqueInput | applicationtemplateWhereUniqueInput[]
    disconnect?: applicationtemplateWhereUniqueInput | applicationtemplateWhereUniqueInput[]
    delete?: applicationtemplateWhereUniqueInput | applicationtemplateWhereUniqueInput[]
    connect?: applicationtemplateWhereUniqueInput | applicationtemplateWhereUniqueInput[]
    update?: applicationtemplateUpdateWithWhereUniqueWithoutAdminInput | applicationtemplateUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: applicationtemplateUpdateManyWithWhereWithoutAdminInput | applicationtemplateUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: applicationtemplateScalarWhereInput | applicationtemplateScalarWhereInput[]
  }

  export type jobvacancyUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<jobvacancyCreateWithoutAdminInput, jobvacancyUncheckedCreateWithoutAdminInput> | jobvacancyCreateWithoutAdminInput[] | jobvacancyUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: jobvacancyCreateOrConnectWithoutAdminInput | jobvacancyCreateOrConnectWithoutAdminInput[]
    upsert?: jobvacancyUpsertWithWhereUniqueWithoutAdminInput | jobvacancyUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: jobvacancyCreateManyAdminInputEnvelope
    set?: jobvacancyWhereUniqueInput | jobvacancyWhereUniqueInput[]
    disconnect?: jobvacancyWhereUniqueInput | jobvacancyWhereUniqueInput[]
    delete?: jobvacancyWhereUniqueInput | jobvacancyWhereUniqueInput[]
    connect?: jobvacancyWhereUniqueInput | jobvacancyWhereUniqueInput[]
    update?: jobvacancyUpdateWithWhereUniqueWithoutAdminInput | jobvacancyUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: jobvacancyUpdateManyWithWhereWithoutAdminInput | jobvacancyUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: jobvacancyScalarWhereInput | jobvacancyScalarWhereInput[]
  }

  export type additionalinfoCreateNestedManyWithoutApplicationInput = {
    create?: XOR<additionalinfoCreateWithoutApplicationInput, additionalinfoUncheckedCreateWithoutApplicationInput> | additionalinfoCreateWithoutApplicationInput[] | additionalinfoUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: additionalinfoCreateOrConnectWithoutApplicationInput | additionalinfoCreateOrConnectWithoutApplicationInput[]
    createMany?: additionalinfoCreateManyApplicationInputEnvelope
    connect?: additionalinfoWhereUniqueInput | additionalinfoWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutApplicationInput = {
    create?: XOR<userCreateWithoutApplicationInput, userUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: userCreateOrConnectWithoutApplicationInput
    connect?: userWhereUniqueInput
  }

  export type jobvacancyCreateNestedOneWithoutApplicationInput = {
    create?: XOR<jobvacancyCreateWithoutApplicationInput, jobvacancyUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: jobvacancyCreateOrConnectWithoutApplicationInput
    connect?: jobvacancyWhereUniqueInput
  }

  export type applicationattachmentsCreateNestedManyWithoutApplicationInput = {
    create?: XOR<applicationattachmentsCreateWithoutApplicationInput, applicationattachmentsUncheckedCreateWithoutApplicationInput> | applicationattachmentsCreateWithoutApplicationInput[] | applicationattachmentsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: applicationattachmentsCreateOrConnectWithoutApplicationInput | applicationattachmentsCreateOrConnectWithoutApplicationInput[]
    createMany?: applicationattachmentsCreateManyApplicationInputEnvelope
    connect?: applicationattachmentsWhereUniqueInput | applicationattachmentsWhereUniqueInput[]
  }

  export type applicationgeneraldetailsCreateNestedOneWithoutApplicationInput = {
    create?: XOR<applicationgeneraldetailsCreateWithoutApplicationInput, applicationgeneraldetailsUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: applicationgeneraldetailsCreateOrConnectWithoutApplicationInput
    connect?: applicationgeneraldetailsWhereUniqueInput
  }

  export type applicationreferencesCreateNestedManyWithoutApplicationInput = {
    create?: XOR<applicationreferencesCreateWithoutApplicationInput, applicationreferencesUncheckedCreateWithoutApplicationInput> | applicationreferencesCreateWithoutApplicationInput[] | applicationreferencesUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: applicationreferencesCreateOrConnectWithoutApplicationInput | applicationreferencesCreateOrConnectWithoutApplicationInput[]
    createMany?: applicationreferencesCreateManyApplicationInputEnvelope
    connect?: applicationreferencesWhereUniqueInput | applicationreferencesWhereUniqueInput[]
  }

  export type employmenthistoriesCreateNestedManyWithoutApplicationInput = {
    create?: XOR<employmenthistoriesCreateWithoutApplicationInput, employmenthistoriesUncheckedCreateWithoutApplicationInput> | employmenthistoriesCreateWithoutApplicationInput[] | employmenthistoriesUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: employmenthistoriesCreateOrConnectWithoutApplicationInput | employmenthistoriesCreateOrConnectWithoutApplicationInput[]
    createMany?: employmenthistoriesCreateManyApplicationInputEnvelope
    connect?: employmenthistoriesWhereUniqueInput | employmenthistoriesWhereUniqueInput[]
  }

  export type experiencedetailsCreateNestedManyWithoutApplicationInput = {
    create?: XOR<experiencedetailsCreateWithoutApplicationInput, experiencedetailsUncheckedCreateWithoutApplicationInput> | experiencedetailsCreateWithoutApplicationInput[] | experiencedetailsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: experiencedetailsCreateOrConnectWithoutApplicationInput | experiencedetailsCreateOrConnectWithoutApplicationInput[]
    createMany?: experiencedetailsCreateManyApplicationInputEnvelope
    connect?: experiencedetailsWhereUniqueInput | experiencedetailsWhereUniqueInput[]
  }

  export type gce_al_resultsCreateNestedManyWithoutApplicationInput = {
    create?: XOR<gce_al_resultsCreateWithoutApplicationInput, gce_al_resultsUncheckedCreateWithoutApplicationInput> | gce_al_resultsCreateWithoutApplicationInput[] | gce_al_resultsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: gce_al_resultsCreateOrConnectWithoutApplicationInput | gce_al_resultsCreateOrConnectWithoutApplicationInput[]
    createMany?: gce_al_resultsCreateManyApplicationInputEnvelope
    connect?: gce_al_resultsWhereUniqueInput | gce_al_resultsWhereUniqueInput[]
  }

  export type gce_ol_resultsCreateNestedManyWithoutApplicationInput = {
    create?: XOR<gce_ol_resultsCreateWithoutApplicationInput, gce_ol_resultsUncheckedCreateWithoutApplicationInput> | gce_ol_resultsCreateWithoutApplicationInput[] | gce_ol_resultsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: gce_ol_resultsCreateOrConnectWithoutApplicationInput | gce_ol_resultsCreateOrConnectWithoutApplicationInput[]
    createMany?: gce_ol_resultsCreateManyApplicationInputEnvelope
    connect?: gce_ol_resultsWhereUniqueInput | gce_ol_resultsWhereUniqueInput[]
  }

  export type languageproficienciesCreateNestedManyWithoutApplicationInput = {
    create?: XOR<languageproficienciesCreateWithoutApplicationInput, languageproficienciesUncheckedCreateWithoutApplicationInput> | languageproficienciesCreateWithoutApplicationInput[] | languageproficienciesUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: languageproficienciesCreateOrConnectWithoutApplicationInput | languageproficienciesCreateOrConnectWithoutApplicationInput[]
    createMany?: languageproficienciesCreateManyApplicationInputEnvelope
    connect?: languageproficienciesWhereUniqueInput | languageproficienciesWhereUniqueInput[]
  }

  export type professionalqualificationsCreateNestedManyWithoutApplicationInput = {
    create?: XOR<professionalqualificationsCreateWithoutApplicationInput, professionalqualificationsUncheckedCreateWithoutApplicationInput> | professionalqualificationsCreateWithoutApplicationInput[] | professionalqualificationsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: professionalqualificationsCreateOrConnectWithoutApplicationInput | professionalqualificationsCreateOrConnectWithoutApplicationInput[]
    createMany?: professionalqualificationsCreateManyApplicationInputEnvelope
    connect?: professionalqualificationsWhereUniqueInput | professionalqualificationsWhereUniqueInput[]
  }

  export type researchandpublicationsCreateNestedManyWithoutApplicationInput = {
    create?: XOR<researchandpublicationsCreateWithoutApplicationInput, researchandpublicationsUncheckedCreateWithoutApplicationInput> | researchandpublicationsCreateWithoutApplicationInput[] | researchandpublicationsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: researchandpublicationsCreateOrConnectWithoutApplicationInput | researchandpublicationsCreateOrConnectWithoutApplicationInput[]
    createMany?: researchandpublicationsCreateManyApplicationInputEnvelope
    connect?: researchandpublicationsWhereUniqueInput | researchandpublicationsWhereUniqueInput[]
  }

  export type specialqualificationsCreateNestedManyWithoutApplicationInput = {
    create?: XOR<specialqualificationsCreateWithoutApplicationInput, specialqualificationsUncheckedCreateWithoutApplicationInput> | specialqualificationsCreateWithoutApplicationInput[] | specialqualificationsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: specialqualificationsCreateOrConnectWithoutApplicationInput | specialqualificationsCreateOrConnectWithoutApplicationInput[]
    createMany?: specialqualificationsCreateManyApplicationInputEnvelope
    connect?: specialqualificationsWhereUniqueInput | specialqualificationsWhereUniqueInput[]
  }

  export type universityeducationsCreateNestedManyWithoutApplicationInput = {
    create?: XOR<universityeducationsCreateWithoutApplicationInput, universityeducationsUncheckedCreateWithoutApplicationInput> | universityeducationsCreateWithoutApplicationInput[] | universityeducationsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: universityeducationsCreateOrConnectWithoutApplicationInput | universityeducationsCreateOrConnectWithoutApplicationInput[]
    createMany?: universityeducationsCreateManyApplicationInputEnvelope
    connect?: universityeducationsWhereUniqueInput | universityeducationsWhereUniqueInput[]
  }

  export type additionalinfoUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<additionalinfoCreateWithoutApplicationInput, additionalinfoUncheckedCreateWithoutApplicationInput> | additionalinfoCreateWithoutApplicationInput[] | additionalinfoUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: additionalinfoCreateOrConnectWithoutApplicationInput | additionalinfoCreateOrConnectWithoutApplicationInput[]
    createMany?: additionalinfoCreateManyApplicationInputEnvelope
    connect?: additionalinfoWhereUniqueInput | additionalinfoWhereUniqueInput[]
  }

  export type applicationattachmentsUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<applicationattachmentsCreateWithoutApplicationInput, applicationattachmentsUncheckedCreateWithoutApplicationInput> | applicationattachmentsCreateWithoutApplicationInput[] | applicationattachmentsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: applicationattachmentsCreateOrConnectWithoutApplicationInput | applicationattachmentsCreateOrConnectWithoutApplicationInput[]
    createMany?: applicationattachmentsCreateManyApplicationInputEnvelope
    connect?: applicationattachmentsWhereUniqueInput | applicationattachmentsWhereUniqueInput[]
  }

  export type applicationgeneraldetailsUncheckedCreateNestedOneWithoutApplicationInput = {
    create?: XOR<applicationgeneraldetailsCreateWithoutApplicationInput, applicationgeneraldetailsUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: applicationgeneraldetailsCreateOrConnectWithoutApplicationInput
    connect?: applicationgeneraldetailsWhereUniqueInput
  }

  export type applicationreferencesUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<applicationreferencesCreateWithoutApplicationInput, applicationreferencesUncheckedCreateWithoutApplicationInput> | applicationreferencesCreateWithoutApplicationInput[] | applicationreferencesUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: applicationreferencesCreateOrConnectWithoutApplicationInput | applicationreferencesCreateOrConnectWithoutApplicationInput[]
    createMany?: applicationreferencesCreateManyApplicationInputEnvelope
    connect?: applicationreferencesWhereUniqueInput | applicationreferencesWhereUniqueInput[]
  }

  export type employmenthistoriesUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<employmenthistoriesCreateWithoutApplicationInput, employmenthistoriesUncheckedCreateWithoutApplicationInput> | employmenthistoriesCreateWithoutApplicationInput[] | employmenthistoriesUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: employmenthistoriesCreateOrConnectWithoutApplicationInput | employmenthistoriesCreateOrConnectWithoutApplicationInput[]
    createMany?: employmenthistoriesCreateManyApplicationInputEnvelope
    connect?: employmenthistoriesWhereUniqueInput | employmenthistoriesWhereUniqueInput[]
  }

  export type experiencedetailsUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<experiencedetailsCreateWithoutApplicationInput, experiencedetailsUncheckedCreateWithoutApplicationInput> | experiencedetailsCreateWithoutApplicationInput[] | experiencedetailsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: experiencedetailsCreateOrConnectWithoutApplicationInput | experiencedetailsCreateOrConnectWithoutApplicationInput[]
    createMany?: experiencedetailsCreateManyApplicationInputEnvelope
    connect?: experiencedetailsWhereUniqueInput | experiencedetailsWhereUniqueInput[]
  }

  export type gce_al_resultsUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<gce_al_resultsCreateWithoutApplicationInput, gce_al_resultsUncheckedCreateWithoutApplicationInput> | gce_al_resultsCreateWithoutApplicationInput[] | gce_al_resultsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: gce_al_resultsCreateOrConnectWithoutApplicationInput | gce_al_resultsCreateOrConnectWithoutApplicationInput[]
    createMany?: gce_al_resultsCreateManyApplicationInputEnvelope
    connect?: gce_al_resultsWhereUniqueInput | gce_al_resultsWhereUniqueInput[]
  }

  export type gce_ol_resultsUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<gce_ol_resultsCreateWithoutApplicationInput, gce_ol_resultsUncheckedCreateWithoutApplicationInput> | gce_ol_resultsCreateWithoutApplicationInput[] | gce_ol_resultsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: gce_ol_resultsCreateOrConnectWithoutApplicationInput | gce_ol_resultsCreateOrConnectWithoutApplicationInput[]
    createMany?: gce_ol_resultsCreateManyApplicationInputEnvelope
    connect?: gce_ol_resultsWhereUniqueInput | gce_ol_resultsWhereUniqueInput[]
  }

  export type languageproficienciesUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<languageproficienciesCreateWithoutApplicationInput, languageproficienciesUncheckedCreateWithoutApplicationInput> | languageproficienciesCreateWithoutApplicationInput[] | languageproficienciesUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: languageproficienciesCreateOrConnectWithoutApplicationInput | languageproficienciesCreateOrConnectWithoutApplicationInput[]
    createMany?: languageproficienciesCreateManyApplicationInputEnvelope
    connect?: languageproficienciesWhereUniqueInput | languageproficienciesWhereUniqueInput[]
  }

  export type professionalqualificationsUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<professionalqualificationsCreateWithoutApplicationInput, professionalqualificationsUncheckedCreateWithoutApplicationInput> | professionalqualificationsCreateWithoutApplicationInput[] | professionalqualificationsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: professionalqualificationsCreateOrConnectWithoutApplicationInput | professionalqualificationsCreateOrConnectWithoutApplicationInput[]
    createMany?: professionalqualificationsCreateManyApplicationInputEnvelope
    connect?: professionalqualificationsWhereUniqueInput | professionalqualificationsWhereUniqueInput[]
  }

  export type researchandpublicationsUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<researchandpublicationsCreateWithoutApplicationInput, researchandpublicationsUncheckedCreateWithoutApplicationInput> | researchandpublicationsCreateWithoutApplicationInput[] | researchandpublicationsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: researchandpublicationsCreateOrConnectWithoutApplicationInput | researchandpublicationsCreateOrConnectWithoutApplicationInput[]
    createMany?: researchandpublicationsCreateManyApplicationInputEnvelope
    connect?: researchandpublicationsWhereUniqueInput | researchandpublicationsWhereUniqueInput[]
  }

  export type specialqualificationsUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<specialqualificationsCreateWithoutApplicationInput, specialqualificationsUncheckedCreateWithoutApplicationInput> | specialqualificationsCreateWithoutApplicationInput[] | specialqualificationsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: specialqualificationsCreateOrConnectWithoutApplicationInput | specialqualificationsCreateOrConnectWithoutApplicationInput[]
    createMany?: specialqualificationsCreateManyApplicationInputEnvelope
    connect?: specialqualificationsWhereUniqueInput | specialqualificationsWhereUniqueInput[]
  }

  export type universityeducationsUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<universityeducationsCreateWithoutApplicationInput, universityeducationsUncheckedCreateWithoutApplicationInput> | universityeducationsCreateWithoutApplicationInput[] | universityeducationsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: universityeducationsCreateOrConnectWithoutApplicationInput | universityeducationsCreateOrConnectWithoutApplicationInput[]
    createMany?: universityeducationsCreateManyApplicationInputEnvelope
    connect?: universityeducationsWhereUniqueInput | universityeducationsWhereUniqueInput[]
  }

  export type NullableEnumapplication_StatusFieldUpdateOperationsInput = {
    set?: $Enums.application_Status | null
  }

  export type additionalinfoUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<additionalinfoCreateWithoutApplicationInput, additionalinfoUncheckedCreateWithoutApplicationInput> | additionalinfoCreateWithoutApplicationInput[] | additionalinfoUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: additionalinfoCreateOrConnectWithoutApplicationInput | additionalinfoCreateOrConnectWithoutApplicationInput[]
    upsert?: additionalinfoUpsertWithWhereUniqueWithoutApplicationInput | additionalinfoUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: additionalinfoCreateManyApplicationInputEnvelope
    set?: additionalinfoWhereUniqueInput | additionalinfoWhereUniqueInput[]
    disconnect?: additionalinfoWhereUniqueInput | additionalinfoWhereUniqueInput[]
    delete?: additionalinfoWhereUniqueInput | additionalinfoWhereUniqueInput[]
    connect?: additionalinfoWhereUniqueInput | additionalinfoWhereUniqueInput[]
    update?: additionalinfoUpdateWithWhereUniqueWithoutApplicationInput | additionalinfoUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: additionalinfoUpdateManyWithWhereWithoutApplicationInput | additionalinfoUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: additionalinfoScalarWhereInput | additionalinfoScalarWhereInput[]
  }

  export type userUpdateOneWithoutApplicationNestedInput = {
    create?: XOR<userCreateWithoutApplicationInput, userUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: userCreateOrConnectWithoutApplicationInput
    upsert?: userUpsertWithoutApplicationInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutApplicationInput, userUpdateWithoutApplicationInput>, userUncheckedUpdateWithoutApplicationInput>
  }

  export type jobvacancyUpdateOneWithoutApplicationNestedInput = {
    create?: XOR<jobvacancyCreateWithoutApplicationInput, jobvacancyUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: jobvacancyCreateOrConnectWithoutApplicationInput
    upsert?: jobvacancyUpsertWithoutApplicationInput
    disconnect?: jobvacancyWhereInput | boolean
    delete?: jobvacancyWhereInput | boolean
    connect?: jobvacancyWhereUniqueInput
    update?: XOR<XOR<jobvacancyUpdateToOneWithWhereWithoutApplicationInput, jobvacancyUpdateWithoutApplicationInput>, jobvacancyUncheckedUpdateWithoutApplicationInput>
  }

  export type applicationattachmentsUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<applicationattachmentsCreateWithoutApplicationInput, applicationattachmentsUncheckedCreateWithoutApplicationInput> | applicationattachmentsCreateWithoutApplicationInput[] | applicationattachmentsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: applicationattachmentsCreateOrConnectWithoutApplicationInput | applicationattachmentsCreateOrConnectWithoutApplicationInput[]
    upsert?: applicationattachmentsUpsertWithWhereUniqueWithoutApplicationInput | applicationattachmentsUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: applicationattachmentsCreateManyApplicationInputEnvelope
    set?: applicationattachmentsWhereUniqueInput | applicationattachmentsWhereUniqueInput[]
    disconnect?: applicationattachmentsWhereUniqueInput | applicationattachmentsWhereUniqueInput[]
    delete?: applicationattachmentsWhereUniqueInput | applicationattachmentsWhereUniqueInput[]
    connect?: applicationattachmentsWhereUniqueInput | applicationattachmentsWhereUniqueInput[]
    update?: applicationattachmentsUpdateWithWhereUniqueWithoutApplicationInput | applicationattachmentsUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: applicationattachmentsUpdateManyWithWhereWithoutApplicationInput | applicationattachmentsUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: applicationattachmentsScalarWhereInput | applicationattachmentsScalarWhereInput[]
  }

  export type applicationgeneraldetailsUpdateOneWithoutApplicationNestedInput = {
    create?: XOR<applicationgeneraldetailsCreateWithoutApplicationInput, applicationgeneraldetailsUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: applicationgeneraldetailsCreateOrConnectWithoutApplicationInput
    upsert?: applicationgeneraldetailsUpsertWithoutApplicationInput
    disconnect?: applicationgeneraldetailsWhereInput | boolean
    delete?: applicationgeneraldetailsWhereInput | boolean
    connect?: applicationgeneraldetailsWhereUniqueInput
    update?: XOR<XOR<applicationgeneraldetailsUpdateToOneWithWhereWithoutApplicationInput, applicationgeneraldetailsUpdateWithoutApplicationInput>, applicationgeneraldetailsUncheckedUpdateWithoutApplicationInput>
  }

  export type applicationreferencesUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<applicationreferencesCreateWithoutApplicationInput, applicationreferencesUncheckedCreateWithoutApplicationInput> | applicationreferencesCreateWithoutApplicationInput[] | applicationreferencesUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: applicationreferencesCreateOrConnectWithoutApplicationInput | applicationreferencesCreateOrConnectWithoutApplicationInput[]
    upsert?: applicationreferencesUpsertWithWhereUniqueWithoutApplicationInput | applicationreferencesUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: applicationreferencesCreateManyApplicationInputEnvelope
    set?: applicationreferencesWhereUniqueInput | applicationreferencesWhereUniqueInput[]
    disconnect?: applicationreferencesWhereUniqueInput | applicationreferencesWhereUniqueInput[]
    delete?: applicationreferencesWhereUniqueInput | applicationreferencesWhereUniqueInput[]
    connect?: applicationreferencesWhereUniqueInput | applicationreferencesWhereUniqueInput[]
    update?: applicationreferencesUpdateWithWhereUniqueWithoutApplicationInput | applicationreferencesUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: applicationreferencesUpdateManyWithWhereWithoutApplicationInput | applicationreferencesUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: applicationreferencesScalarWhereInput | applicationreferencesScalarWhereInput[]
  }

  export type employmenthistoriesUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<employmenthistoriesCreateWithoutApplicationInput, employmenthistoriesUncheckedCreateWithoutApplicationInput> | employmenthistoriesCreateWithoutApplicationInput[] | employmenthistoriesUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: employmenthistoriesCreateOrConnectWithoutApplicationInput | employmenthistoriesCreateOrConnectWithoutApplicationInput[]
    upsert?: employmenthistoriesUpsertWithWhereUniqueWithoutApplicationInput | employmenthistoriesUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: employmenthistoriesCreateManyApplicationInputEnvelope
    set?: employmenthistoriesWhereUniqueInput | employmenthistoriesWhereUniqueInput[]
    disconnect?: employmenthistoriesWhereUniqueInput | employmenthistoriesWhereUniqueInput[]
    delete?: employmenthistoriesWhereUniqueInput | employmenthistoriesWhereUniqueInput[]
    connect?: employmenthistoriesWhereUniqueInput | employmenthistoriesWhereUniqueInput[]
    update?: employmenthistoriesUpdateWithWhereUniqueWithoutApplicationInput | employmenthistoriesUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: employmenthistoriesUpdateManyWithWhereWithoutApplicationInput | employmenthistoriesUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: employmenthistoriesScalarWhereInput | employmenthistoriesScalarWhereInput[]
  }

  export type experiencedetailsUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<experiencedetailsCreateWithoutApplicationInput, experiencedetailsUncheckedCreateWithoutApplicationInput> | experiencedetailsCreateWithoutApplicationInput[] | experiencedetailsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: experiencedetailsCreateOrConnectWithoutApplicationInput | experiencedetailsCreateOrConnectWithoutApplicationInput[]
    upsert?: experiencedetailsUpsertWithWhereUniqueWithoutApplicationInput | experiencedetailsUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: experiencedetailsCreateManyApplicationInputEnvelope
    set?: experiencedetailsWhereUniqueInput | experiencedetailsWhereUniqueInput[]
    disconnect?: experiencedetailsWhereUniqueInput | experiencedetailsWhereUniqueInput[]
    delete?: experiencedetailsWhereUniqueInput | experiencedetailsWhereUniqueInput[]
    connect?: experiencedetailsWhereUniqueInput | experiencedetailsWhereUniqueInput[]
    update?: experiencedetailsUpdateWithWhereUniqueWithoutApplicationInput | experiencedetailsUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: experiencedetailsUpdateManyWithWhereWithoutApplicationInput | experiencedetailsUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: experiencedetailsScalarWhereInput | experiencedetailsScalarWhereInput[]
  }

  export type gce_al_resultsUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<gce_al_resultsCreateWithoutApplicationInput, gce_al_resultsUncheckedCreateWithoutApplicationInput> | gce_al_resultsCreateWithoutApplicationInput[] | gce_al_resultsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: gce_al_resultsCreateOrConnectWithoutApplicationInput | gce_al_resultsCreateOrConnectWithoutApplicationInput[]
    upsert?: gce_al_resultsUpsertWithWhereUniqueWithoutApplicationInput | gce_al_resultsUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: gce_al_resultsCreateManyApplicationInputEnvelope
    set?: gce_al_resultsWhereUniqueInput | gce_al_resultsWhereUniqueInput[]
    disconnect?: gce_al_resultsWhereUniqueInput | gce_al_resultsWhereUniqueInput[]
    delete?: gce_al_resultsWhereUniqueInput | gce_al_resultsWhereUniqueInput[]
    connect?: gce_al_resultsWhereUniqueInput | gce_al_resultsWhereUniqueInput[]
    update?: gce_al_resultsUpdateWithWhereUniqueWithoutApplicationInput | gce_al_resultsUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: gce_al_resultsUpdateManyWithWhereWithoutApplicationInput | gce_al_resultsUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: gce_al_resultsScalarWhereInput | gce_al_resultsScalarWhereInput[]
  }

  export type gce_ol_resultsUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<gce_ol_resultsCreateWithoutApplicationInput, gce_ol_resultsUncheckedCreateWithoutApplicationInput> | gce_ol_resultsCreateWithoutApplicationInput[] | gce_ol_resultsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: gce_ol_resultsCreateOrConnectWithoutApplicationInput | gce_ol_resultsCreateOrConnectWithoutApplicationInput[]
    upsert?: gce_ol_resultsUpsertWithWhereUniqueWithoutApplicationInput | gce_ol_resultsUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: gce_ol_resultsCreateManyApplicationInputEnvelope
    set?: gce_ol_resultsWhereUniqueInput | gce_ol_resultsWhereUniqueInput[]
    disconnect?: gce_ol_resultsWhereUniqueInput | gce_ol_resultsWhereUniqueInput[]
    delete?: gce_ol_resultsWhereUniqueInput | gce_ol_resultsWhereUniqueInput[]
    connect?: gce_ol_resultsWhereUniqueInput | gce_ol_resultsWhereUniqueInput[]
    update?: gce_ol_resultsUpdateWithWhereUniqueWithoutApplicationInput | gce_ol_resultsUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: gce_ol_resultsUpdateManyWithWhereWithoutApplicationInput | gce_ol_resultsUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: gce_ol_resultsScalarWhereInput | gce_ol_resultsScalarWhereInput[]
  }

  export type languageproficienciesUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<languageproficienciesCreateWithoutApplicationInput, languageproficienciesUncheckedCreateWithoutApplicationInput> | languageproficienciesCreateWithoutApplicationInput[] | languageproficienciesUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: languageproficienciesCreateOrConnectWithoutApplicationInput | languageproficienciesCreateOrConnectWithoutApplicationInput[]
    upsert?: languageproficienciesUpsertWithWhereUniqueWithoutApplicationInput | languageproficienciesUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: languageproficienciesCreateManyApplicationInputEnvelope
    set?: languageproficienciesWhereUniqueInput | languageproficienciesWhereUniqueInput[]
    disconnect?: languageproficienciesWhereUniqueInput | languageproficienciesWhereUniqueInput[]
    delete?: languageproficienciesWhereUniqueInput | languageproficienciesWhereUniqueInput[]
    connect?: languageproficienciesWhereUniqueInput | languageproficienciesWhereUniqueInput[]
    update?: languageproficienciesUpdateWithWhereUniqueWithoutApplicationInput | languageproficienciesUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: languageproficienciesUpdateManyWithWhereWithoutApplicationInput | languageproficienciesUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: languageproficienciesScalarWhereInput | languageproficienciesScalarWhereInput[]
  }

  export type professionalqualificationsUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<professionalqualificationsCreateWithoutApplicationInput, professionalqualificationsUncheckedCreateWithoutApplicationInput> | professionalqualificationsCreateWithoutApplicationInput[] | professionalqualificationsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: professionalqualificationsCreateOrConnectWithoutApplicationInput | professionalqualificationsCreateOrConnectWithoutApplicationInput[]
    upsert?: professionalqualificationsUpsertWithWhereUniqueWithoutApplicationInput | professionalqualificationsUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: professionalqualificationsCreateManyApplicationInputEnvelope
    set?: professionalqualificationsWhereUniqueInput | professionalqualificationsWhereUniqueInput[]
    disconnect?: professionalqualificationsWhereUniqueInput | professionalqualificationsWhereUniqueInput[]
    delete?: professionalqualificationsWhereUniqueInput | professionalqualificationsWhereUniqueInput[]
    connect?: professionalqualificationsWhereUniqueInput | professionalqualificationsWhereUniqueInput[]
    update?: professionalqualificationsUpdateWithWhereUniqueWithoutApplicationInput | professionalqualificationsUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: professionalqualificationsUpdateManyWithWhereWithoutApplicationInput | professionalqualificationsUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: professionalqualificationsScalarWhereInput | professionalqualificationsScalarWhereInput[]
  }

  export type researchandpublicationsUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<researchandpublicationsCreateWithoutApplicationInput, researchandpublicationsUncheckedCreateWithoutApplicationInput> | researchandpublicationsCreateWithoutApplicationInput[] | researchandpublicationsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: researchandpublicationsCreateOrConnectWithoutApplicationInput | researchandpublicationsCreateOrConnectWithoutApplicationInput[]
    upsert?: researchandpublicationsUpsertWithWhereUniqueWithoutApplicationInput | researchandpublicationsUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: researchandpublicationsCreateManyApplicationInputEnvelope
    set?: researchandpublicationsWhereUniqueInput | researchandpublicationsWhereUniqueInput[]
    disconnect?: researchandpublicationsWhereUniqueInput | researchandpublicationsWhereUniqueInput[]
    delete?: researchandpublicationsWhereUniqueInput | researchandpublicationsWhereUniqueInput[]
    connect?: researchandpublicationsWhereUniqueInput | researchandpublicationsWhereUniqueInput[]
    update?: researchandpublicationsUpdateWithWhereUniqueWithoutApplicationInput | researchandpublicationsUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: researchandpublicationsUpdateManyWithWhereWithoutApplicationInput | researchandpublicationsUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: researchandpublicationsScalarWhereInput | researchandpublicationsScalarWhereInput[]
  }

  export type specialqualificationsUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<specialqualificationsCreateWithoutApplicationInput, specialqualificationsUncheckedCreateWithoutApplicationInput> | specialqualificationsCreateWithoutApplicationInput[] | specialqualificationsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: specialqualificationsCreateOrConnectWithoutApplicationInput | specialqualificationsCreateOrConnectWithoutApplicationInput[]
    upsert?: specialqualificationsUpsertWithWhereUniqueWithoutApplicationInput | specialqualificationsUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: specialqualificationsCreateManyApplicationInputEnvelope
    set?: specialqualificationsWhereUniqueInput | specialqualificationsWhereUniqueInput[]
    disconnect?: specialqualificationsWhereUniqueInput | specialqualificationsWhereUniqueInput[]
    delete?: specialqualificationsWhereUniqueInput | specialqualificationsWhereUniqueInput[]
    connect?: specialqualificationsWhereUniqueInput | specialqualificationsWhereUniqueInput[]
    update?: specialqualificationsUpdateWithWhereUniqueWithoutApplicationInput | specialqualificationsUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: specialqualificationsUpdateManyWithWhereWithoutApplicationInput | specialqualificationsUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: specialqualificationsScalarWhereInput | specialqualificationsScalarWhereInput[]
  }

  export type universityeducationsUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<universityeducationsCreateWithoutApplicationInput, universityeducationsUncheckedCreateWithoutApplicationInput> | universityeducationsCreateWithoutApplicationInput[] | universityeducationsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: universityeducationsCreateOrConnectWithoutApplicationInput | universityeducationsCreateOrConnectWithoutApplicationInput[]
    upsert?: universityeducationsUpsertWithWhereUniqueWithoutApplicationInput | universityeducationsUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: universityeducationsCreateManyApplicationInputEnvelope
    set?: universityeducationsWhereUniqueInput | universityeducationsWhereUniqueInput[]
    disconnect?: universityeducationsWhereUniqueInput | universityeducationsWhereUniqueInput[]
    delete?: universityeducationsWhereUniqueInput | universityeducationsWhereUniqueInput[]
    connect?: universityeducationsWhereUniqueInput | universityeducationsWhereUniqueInput[]
    update?: universityeducationsUpdateWithWhereUniqueWithoutApplicationInput | universityeducationsUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: universityeducationsUpdateManyWithWhereWithoutApplicationInput | universityeducationsUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: universityeducationsScalarWhereInput | universityeducationsScalarWhereInput[]
  }

  export type additionalinfoUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<additionalinfoCreateWithoutApplicationInput, additionalinfoUncheckedCreateWithoutApplicationInput> | additionalinfoCreateWithoutApplicationInput[] | additionalinfoUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: additionalinfoCreateOrConnectWithoutApplicationInput | additionalinfoCreateOrConnectWithoutApplicationInput[]
    upsert?: additionalinfoUpsertWithWhereUniqueWithoutApplicationInput | additionalinfoUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: additionalinfoCreateManyApplicationInputEnvelope
    set?: additionalinfoWhereUniqueInput | additionalinfoWhereUniqueInput[]
    disconnect?: additionalinfoWhereUniqueInput | additionalinfoWhereUniqueInput[]
    delete?: additionalinfoWhereUniqueInput | additionalinfoWhereUniqueInput[]
    connect?: additionalinfoWhereUniqueInput | additionalinfoWhereUniqueInput[]
    update?: additionalinfoUpdateWithWhereUniqueWithoutApplicationInput | additionalinfoUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: additionalinfoUpdateManyWithWhereWithoutApplicationInput | additionalinfoUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: additionalinfoScalarWhereInput | additionalinfoScalarWhereInput[]
  }

  export type applicationattachmentsUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<applicationattachmentsCreateWithoutApplicationInput, applicationattachmentsUncheckedCreateWithoutApplicationInput> | applicationattachmentsCreateWithoutApplicationInput[] | applicationattachmentsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: applicationattachmentsCreateOrConnectWithoutApplicationInput | applicationattachmentsCreateOrConnectWithoutApplicationInput[]
    upsert?: applicationattachmentsUpsertWithWhereUniqueWithoutApplicationInput | applicationattachmentsUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: applicationattachmentsCreateManyApplicationInputEnvelope
    set?: applicationattachmentsWhereUniqueInput | applicationattachmentsWhereUniqueInput[]
    disconnect?: applicationattachmentsWhereUniqueInput | applicationattachmentsWhereUniqueInput[]
    delete?: applicationattachmentsWhereUniqueInput | applicationattachmentsWhereUniqueInput[]
    connect?: applicationattachmentsWhereUniqueInput | applicationattachmentsWhereUniqueInput[]
    update?: applicationattachmentsUpdateWithWhereUniqueWithoutApplicationInput | applicationattachmentsUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: applicationattachmentsUpdateManyWithWhereWithoutApplicationInput | applicationattachmentsUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: applicationattachmentsScalarWhereInput | applicationattachmentsScalarWhereInput[]
  }

  export type applicationgeneraldetailsUncheckedUpdateOneWithoutApplicationNestedInput = {
    create?: XOR<applicationgeneraldetailsCreateWithoutApplicationInput, applicationgeneraldetailsUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: applicationgeneraldetailsCreateOrConnectWithoutApplicationInput
    upsert?: applicationgeneraldetailsUpsertWithoutApplicationInput
    disconnect?: applicationgeneraldetailsWhereInput | boolean
    delete?: applicationgeneraldetailsWhereInput | boolean
    connect?: applicationgeneraldetailsWhereUniqueInput
    update?: XOR<XOR<applicationgeneraldetailsUpdateToOneWithWhereWithoutApplicationInput, applicationgeneraldetailsUpdateWithoutApplicationInput>, applicationgeneraldetailsUncheckedUpdateWithoutApplicationInput>
  }

  export type applicationreferencesUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<applicationreferencesCreateWithoutApplicationInput, applicationreferencesUncheckedCreateWithoutApplicationInput> | applicationreferencesCreateWithoutApplicationInput[] | applicationreferencesUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: applicationreferencesCreateOrConnectWithoutApplicationInput | applicationreferencesCreateOrConnectWithoutApplicationInput[]
    upsert?: applicationreferencesUpsertWithWhereUniqueWithoutApplicationInput | applicationreferencesUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: applicationreferencesCreateManyApplicationInputEnvelope
    set?: applicationreferencesWhereUniqueInput | applicationreferencesWhereUniqueInput[]
    disconnect?: applicationreferencesWhereUniqueInput | applicationreferencesWhereUniqueInput[]
    delete?: applicationreferencesWhereUniqueInput | applicationreferencesWhereUniqueInput[]
    connect?: applicationreferencesWhereUniqueInput | applicationreferencesWhereUniqueInput[]
    update?: applicationreferencesUpdateWithWhereUniqueWithoutApplicationInput | applicationreferencesUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: applicationreferencesUpdateManyWithWhereWithoutApplicationInput | applicationreferencesUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: applicationreferencesScalarWhereInput | applicationreferencesScalarWhereInput[]
  }

  export type employmenthistoriesUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<employmenthistoriesCreateWithoutApplicationInput, employmenthistoriesUncheckedCreateWithoutApplicationInput> | employmenthistoriesCreateWithoutApplicationInput[] | employmenthistoriesUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: employmenthistoriesCreateOrConnectWithoutApplicationInput | employmenthistoriesCreateOrConnectWithoutApplicationInput[]
    upsert?: employmenthistoriesUpsertWithWhereUniqueWithoutApplicationInput | employmenthistoriesUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: employmenthistoriesCreateManyApplicationInputEnvelope
    set?: employmenthistoriesWhereUniqueInput | employmenthistoriesWhereUniqueInput[]
    disconnect?: employmenthistoriesWhereUniqueInput | employmenthistoriesWhereUniqueInput[]
    delete?: employmenthistoriesWhereUniqueInput | employmenthistoriesWhereUniqueInput[]
    connect?: employmenthistoriesWhereUniqueInput | employmenthistoriesWhereUniqueInput[]
    update?: employmenthistoriesUpdateWithWhereUniqueWithoutApplicationInput | employmenthistoriesUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: employmenthistoriesUpdateManyWithWhereWithoutApplicationInput | employmenthistoriesUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: employmenthistoriesScalarWhereInput | employmenthistoriesScalarWhereInput[]
  }

  export type experiencedetailsUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<experiencedetailsCreateWithoutApplicationInput, experiencedetailsUncheckedCreateWithoutApplicationInput> | experiencedetailsCreateWithoutApplicationInput[] | experiencedetailsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: experiencedetailsCreateOrConnectWithoutApplicationInput | experiencedetailsCreateOrConnectWithoutApplicationInput[]
    upsert?: experiencedetailsUpsertWithWhereUniqueWithoutApplicationInput | experiencedetailsUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: experiencedetailsCreateManyApplicationInputEnvelope
    set?: experiencedetailsWhereUniqueInput | experiencedetailsWhereUniqueInput[]
    disconnect?: experiencedetailsWhereUniqueInput | experiencedetailsWhereUniqueInput[]
    delete?: experiencedetailsWhereUniqueInput | experiencedetailsWhereUniqueInput[]
    connect?: experiencedetailsWhereUniqueInput | experiencedetailsWhereUniqueInput[]
    update?: experiencedetailsUpdateWithWhereUniqueWithoutApplicationInput | experiencedetailsUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: experiencedetailsUpdateManyWithWhereWithoutApplicationInput | experiencedetailsUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: experiencedetailsScalarWhereInput | experiencedetailsScalarWhereInput[]
  }

  export type gce_al_resultsUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<gce_al_resultsCreateWithoutApplicationInput, gce_al_resultsUncheckedCreateWithoutApplicationInput> | gce_al_resultsCreateWithoutApplicationInput[] | gce_al_resultsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: gce_al_resultsCreateOrConnectWithoutApplicationInput | gce_al_resultsCreateOrConnectWithoutApplicationInput[]
    upsert?: gce_al_resultsUpsertWithWhereUniqueWithoutApplicationInput | gce_al_resultsUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: gce_al_resultsCreateManyApplicationInputEnvelope
    set?: gce_al_resultsWhereUniqueInput | gce_al_resultsWhereUniqueInput[]
    disconnect?: gce_al_resultsWhereUniqueInput | gce_al_resultsWhereUniqueInput[]
    delete?: gce_al_resultsWhereUniqueInput | gce_al_resultsWhereUniqueInput[]
    connect?: gce_al_resultsWhereUniqueInput | gce_al_resultsWhereUniqueInput[]
    update?: gce_al_resultsUpdateWithWhereUniqueWithoutApplicationInput | gce_al_resultsUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: gce_al_resultsUpdateManyWithWhereWithoutApplicationInput | gce_al_resultsUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: gce_al_resultsScalarWhereInput | gce_al_resultsScalarWhereInput[]
  }

  export type gce_ol_resultsUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<gce_ol_resultsCreateWithoutApplicationInput, gce_ol_resultsUncheckedCreateWithoutApplicationInput> | gce_ol_resultsCreateWithoutApplicationInput[] | gce_ol_resultsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: gce_ol_resultsCreateOrConnectWithoutApplicationInput | gce_ol_resultsCreateOrConnectWithoutApplicationInput[]
    upsert?: gce_ol_resultsUpsertWithWhereUniqueWithoutApplicationInput | gce_ol_resultsUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: gce_ol_resultsCreateManyApplicationInputEnvelope
    set?: gce_ol_resultsWhereUniqueInput | gce_ol_resultsWhereUniqueInput[]
    disconnect?: gce_ol_resultsWhereUniqueInput | gce_ol_resultsWhereUniqueInput[]
    delete?: gce_ol_resultsWhereUniqueInput | gce_ol_resultsWhereUniqueInput[]
    connect?: gce_ol_resultsWhereUniqueInput | gce_ol_resultsWhereUniqueInput[]
    update?: gce_ol_resultsUpdateWithWhereUniqueWithoutApplicationInput | gce_ol_resultsUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: gce_ol_resultsUpdateManyWithWhereWithoutApplicationInput | gce_ol_resultsUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: gce_ol_resultsScalarWhereInput | gce_ol_resultsScalarWhereInput[]
  }

  export type languageproficienciesUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<languageproficienciesCreateWithoutApplicationInput, languageproficienciesUncheckedCreateWithoutApplicationInput> | languageproficienciesCreateWithoutApplicationInput[] | languageproficienciesUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: languageproficienciesCreateOrConnectWithoutApplicationInput | languageproficienciesCreateOrConnectWithoutApplicationInput[]
    upsert?: languageproficienciesUpsertWithWhereUniqueWithoutApplicationInput | languageproficienciesUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: languageproficienciesCreateManyApplicationInputEnvelope
    set?: languageproficienciesWhereUniqueInput | languageproficienciesWhereUniqueInput[]
    disconnect?: languageproficienciesWhereUniqueInput | languageproficienciesWhereUniqueInput[]
    delete?: languageproficienciesWhereUniqueInput | languageproficienciesWhereUniqueInput[]
    connect?: languageproficienciesWhereUniqueInput | languageproficienciesWhereUniqueInput[]
    update?: languageproficienciesUpdateWithWhereUniqueWithoutApplicationInput | languageproficienciesUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: languageproficienciesUpdateManyWithWhereWithoutApplicationInput | languageproficienciesUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: languageproficienciesScalarWhereInput | languageproficienciesScalarWhereInput[]
  }

  export type professionalqualificationsUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<professionalqualificationsCreateWithoutApplicationInput, professionalqualificationsUncheckedCreateWithoutApplicationInput> | professionalqualificationsCreateWithoutApplicationInput[] | professionalqualificationsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: professionalqualificationsCreateOrConnectWithoutApplicationInput | professionalqualificationsCreateOrConnectWithoutApplicationInput[]
    upsert?: professionalqualificationsUpsertWithWhereUniqueWithoutApplicationInput | professionalqualificationsUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: professionalqualificationsCreateManyApplicationInputEnvelope
    set?: professionalqualificationsWhereUniqueInput | professionalqualificationsWhereUniqueInput[]
    disconnect?: professionalqualificationsWhereUniqueInput | professionalqualificationsWhereUniqueInput[]
    delete?: professionalqualificationsWhereUniqueInput | professionalqualificationsWhereUniqueInput[]
    connect?: professionalqualificationsWhereUniqueInput | professionalqualificationsWhereUniqueInput[]
    update?: professionalqualificationsUpdateWithWhereUniqueWithoutApplicationInput | professionalqualificationsUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: professionalqualificationsUpdateManyWithWhereWithoutApplicationInput | professionalqualificationsUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: professionalqualificationsScalarWhereInput | professionalqualificationsScalarWhereInput[]
  }

  export type researchandpublicationsUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<researchandpublicationsCreateWithoutApplicationInput, researchandpublicationsUncheckedCreateWithoutApplicationInput> | researchandpublicationsCreateWithoutApplicationInput[] | researchandpublicationsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: researchandpublicationsCreateOrConnectWithoutApplicationInput | researchandpublicationsCreateOrConnectWithoutApplicationInput[]
    upsert?: researchandpublicationsUpsertWithWhereUniqueWithoutApplicationInput | researchandpublicationsUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: researchandpublicationsCreateManyApplicationInputEnvelope
    set?: researchandpublicationsWhereUniqueInput | researchandpublicationsWhereUniqueInput[]
    disconnect?: researchandpublicationsWhereUniqueInput | researchandpublicationsWhereUniqueInput[]
    delete?: researchandpublicationsWhereUniqueInput | researchandpublicationsWhereUniqueInput[]
    connect?: researchandpublicationsWhereUniqueInput | researchandpublicationsWhereUniqueInput[]
    update?: researchandpublicationsUpdateWithWhereUniqueWithoutApplicationInput | researchandpublicationsUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: researchandpublicationsUpdateManyWithWhereWithoutApplicationInput | researchandpublicationsUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: researchandpublicationsScalarWhereInput | researchandpublicationsScalarWhereInput[]
  }

  export type specialqualificationsUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<specialqualificationsCreateWithoutApplicationInput, specialqualificationsUncheckedCreateWithoutApplicationInput> | specialqualificationsCreateWithoutApplicationInput[] | specialqualificationsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: specialqualificationsCreateOrConnectWithoutApplicationInput | specialqualificationsCreateOrConnectWithoutApplicationInput[]
    upsert?: specialqualificationsUpsertWithWhereUniqueWithoutApplicationInput | specialqualificationsUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: specialqualificationsCreateManyApplicationInputEnvelope
    set?: specialqualificationsWhereUniqueInput | specialqualificationsWhereUniqueInput[]
    disconnect?: specialqualificationsWhereUniqueInput | specialqualificationsWhereUniqueInput[]
    delete?: specialqualificationsWhereUniqueInput | specialqualificationsWhereUniqueInput[]
    connect?: specialqualificationsWhereUniqueInput | specialqualificationsWhereUniqueInput[]
    update?: specialqualificationsUpdateWithWhereUniqueWithoutApplicationInput | specialqualificationsUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: specialqualificationsUpdateManyWithWhereWithoutApplicationInput | specialqualificationsUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: specialqualificationsScalarWhereInput | specialqualificationsScalarWhereInput[]
  }

  export type universityeducationsUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<universityeducationsCreateWithoutApplicationInput, universityeducationsUncheckedCreateWithoutApplicationInput> | universityeducationsCreateWithoutApplicationInput[] | universityeducationsUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: universityeducationsCreateOrConnectWithoutApplicationInput | universityeducationsCreateOrConnectWithoutApplicationInput[]
    upsert?: universityeducationsUpsertWithWhereUniqueWithoutApplicationInput | universityeducationsUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: universityeducationsCreateManyApplicationInputEnvelope
    set?: universityeducationsWhereUniqueInput | universityeducationsWhereUniqueInput[]
    disconnect?: universityeducationsWhereUniqueInput | universityeducationsWhereUniqueInput[]
    delete?: universityeducationsWhereUniqueInput | universityeducationsWhereUniqueInput[]
    connect?: universityeducationsWhereUniqueInput | universityeducationsWhereUniqueInput[]
    update?: universityeducationsUpdateWithWhereUniqueWithoutApplicationInput | universityeducationsUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: universityeducationsUpdateManyWithWhereWithoutApplicationInput | universityeducationsUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: universityeducationsScalarWhereInput | universityeducationsScalarWhereInput[]
  }

  export type applicationCreateNestedOneWithoutApplicationattachmentsInput = {
    create?: XOR<applicationCreateWithoutApplicationattachmentsInput, applicationUncheckedCreateWithoutApplicationattachmentsInput>
    connectOrCreate?: applicationCreateOrConnectWithoutApplicationattachmentsInput
    connect?: applicationWhereUniqueInput
  }

  export type applicationUpdateOneWithoutApplicationattachmentsNestedInput = {
    create?: XOR<applicationCreateWithoutApplicationattachmentsInput, applicationUncheckedCreateWithoutApplicationattachmentsInput>
    connectOrCreate?: applicationCreateOrConnectWithoutApplicationattachmentsInput
    upsert?: applicationUpsertWithoutApplicationattachmentsInput
    disconnect?: applicationWhereInput | boolean
    delete?: applicationWhereInput | boolean
    connect?: applicationWhereUniqueInput
    update?: XOR<XOR<applicationUpdateToOneWithWhereWithoutApplicationattachmentsInput, applicationUpdateWithoutApplicationattachmentsInput>, applicationUncheckedUpdateWithoutApplicationattachmentsInput>
  }

  export type applicationCreateNestedOneWithoutApplicationgeneraldetailsInput = {
    create?: XOR<applicationCreateWithoutApplicationgeneraldetailsInput, applicationUncheckedCreateWithoutApplicationgeneraldetailsInput>
    connectOrCreate?: applicationCreateOrConnectWithoutApplicationgeneraldetailsInput
    connect?: applicationWhereUniqueInput
  }

  export type NullableEnumapplicationgeneraldetails_GenderFieldUpdateOperationsInput = {
    set?: $Enums.applicationgeneraldetails_Gender | null
  }

  export type NullableEnumapplicationgeneraldetails_CitizenshipTypeFieldUpdateOperationsInput = {
    set?: $Enums.applicationgeneraldetails_CitizenshipType | null
  }

  export type applicationUpdateOneRequiredWithoutApplicationgeneraldetailsNestedInput = {
    create?: XOR<applicationCreateWithoutApplicationgeneraldetailsInput, applicationUncheckedCreateWithoutApplicationgeneraldetailsInput>
    connectOrCreate?: applicationCreateOrConnectWithoutApplicationgeneraldetailsInput
    upsert?: applicationUpsertWithoutApplicationgeneraldetailsInput
    connect?: applicationWhereUniqueInput
    update?: XOR<XOR<applicationUpdateToOneWithWhereWithoutApplicationgeneraldetailsInput, applicationUpdateWithoutApplicationgeneraldetailsInput>, applicationUncheckedUpdateWithoutApplicationgeneraldetailsInput>
  }

  export type applicationCreateNestedOneWithoutApplicationreferencesInput = {
    create?: XOR<applicationCreateWithoutApplicationreferencesInput, applicationUncheckedCreateWithoutApplicationreferencesInput>
    connectOrCreate?: applicationCreateOrConnectWithoutApplicationreferencesInput
    connect?: applicationWhereUniqueInput
  }

  export type applicationUpdateOneWithoutApplicationreferencesNestedInput = {
    create?: XOR<applicationCreateWithoutApplicationreferencesInput, applicationUncheckedCreateWithoutApplicationreferencesInput>
    connectOrCreate?: applicationCreateOrConnectWithoutApplicationreferencesInput
    upsert?: applicationUpsertWithoutApplicationreferencesInput
    disconnect?: applicationWhereInput | boolean
    delete?: applicationWhereInput | boolean
    connect?: applicationWhereUniqueInput
    update?: XOR<XOR<applicationUpdateToOneWithWhereWithoutApplicationreferencesInput, applicationUpdateWithoutApplicationreferencesInput>, applicationUncheckedUpdateWithoutApplicationreferencesInput>
  }

  export type adminCreateNestedOneWithoutApplicationtemplateInput = {
    create?: XOR<adminCreateWithoutApplicationtemplateInput, adminUncheckedCreateWithoutApplicationtemplateInput>
    connectOrCreate?: adminCreateOrConnectWithoutApplicationtemplateInput
    connect?: adminWhereUniqueInput
  }

  export type jobvacancyCreateNestedManyWithoutApplicationtemplateInput = {
    create?: XOR<jobvacancyCreateWithoutApplicationtemplateInput, jobvacancyUncheckedCreateWithoutApplicationtemplateInput> | jobvacancyCreateWithoutApplicationtemplateInput[] | jobvacancyUncheckedCreateWithoutApplicationtemplateInput[]
    connectOrCreate?: jobvacancyCreateOrConnectWithoutApplicationtemplateInput | jobvacancyCreateOrConnectWithoutApplicationtemplateInput[]
    createMany?: jobvacancyCreateManyApplicationtemplateInputEnvelope
    connect?: jobvacancyWhereUniqueInput | jobvacancyWhereUniqueInput[]
  }

  export type jobvacancyUncheckedCreateNestedManyWithoutApplicationtemplateInput = {
    create?: XOR<jobvacancyCreateWithoutApplicationtemplateInput, jobvacancyUncheckedCreateWithoutApplicationtemplateInput> | jobvacancyCreateWithoutApplicationtemplateInput[] | jobvacancyUncheckedCreateWithoutApplicationtemplateInput[]
    connectOrCreate?: jobvacancyCreateOrConnectWithoutApplicationtemplateInput | jobvacancyCreateOrConnectWithoutApplicationtemplateInput[]
    createMany?: jobvacancyCreateManyApplicationtemplateInputEnvelope
    connect?: jobvacancyWhereUniqueInput | jobvacancyWhereUniqueInput[]
  }

  export type NullableEnumapplicationtemplate_TypeFieldUpdateOperationsInput = {
    set?: $Enums.applicationtemplate_Type | null
  }

  export type adminUpdateOneWithoutApplicationtemplateNestedInput = {
    create?: XOR<adminCreateWithoutApplicationtemplateInput, adminUncheckedCreateWithoutApplicationtemplateInput>
    connectOrCreate?: adminCreateOrConnectWithoutApplicationtemplateInput
    upsert?: adminUpsertWithoutApplicationtemplateInput
    disconnect?: adminWhereInput | boolean
    delete?: adminWhereInput | boolean
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutApplicationtemplateInput, adminUpdateWithoutApplicationtemplateInput>, adminUncheckedUpdateWithoutApplicationtemplateInput>
  }

  export type jobvacancyUpdateManyWithoutApplicationtemplateNestedInput = {
    create?: XOR<jobvacancyCreateWithoutApplicationtemplateInput, jobvacancyUncheckedCreateWithoutApplicationtemplateInput> | jobvacancyCreateWithoutApplicationtemplateInput[] | jobvacancyUncheckedCreateWithoutApplicationtemplateInput[]
    connectOrCreate?: jobvacancyCreateOrConnectWithoutApplicationtemplateInput | jobvacancyCreateOrConnectWithoutApplicationtemplateInput[]
    upsert?: jobvacancyUpsertWithWhereUniqueWithoutApplicationtemplateInput | jobvacancyUpsertWithWhereUniqueWithoutApplicationtemplateInput[]
    createMany?: jobvacancyCreateManyApplicationtemplateInputEnvelope
    set?: jobvacancyWhereUniqueInput | jobvacancyWhereUniqueInput[]
    disconnect?: jobvacancyWhereUniqueInput | jobvacancyWhereUniqueInput[]
    delete?: jobvacancyWhereUniqueInput | jobvacancyWhereUniqueInput[]
    connect?: jobvacancyWhereUniqueInput | jobvacancyWhereUniqueInput[]
    update?: jobvacancyUpdateWithWhereUniqueWithoutApplicationtemplateInput | jobvacancyUpdateWithWhereUniqueWithoutApplicationtemplateInput[]
    updateMany?: jobvacancyUpdateManyWithWhereWithoutApplicationtemplateInput | jobvacancyUpdateManyWithWhereWithoutApplicationtemplateInput[]
    deleteMany?: jobvacancyScalarWhereInput | jobvacancyScalarWhereInput[]
  }

  export type jobvacancyUncheckedUpdateManyWithoutApplicationtemplateNestedInput = {
    create?: XOR<jobvacancyCreateWithoutApplicationtemplateInput, jobvacancyUncheckedCreateWithoutApplicationtemplateInput> | jobvacancyCreateWithoutApplicationtemplateInput[] | jobvacancyUncheckedCreateWithoutApplicationtemplateInput[]
    connectOrCreate?: jobvacancyCreateOrConnectWithoutApplicationtemplateInput | jobvacancyCreateOrConnectWithoutApplicationtemplateInput[]
    upsert?: jobvacancyUpsertWithWhereUniqueWithoutApplicationtemplateInput | jobvacancyUpsertWithWhereUniqueWithoutApplicationtemplateInput[]
    createMany?: jobvacancyCreateManyApplicationtemplateInputEnvelope
    set?: jobvacancyWhereUniqueInput | jobvacancyWhereUniqueInput[]
    disconnect?: jobvacancyWhereUniqueInput | jobvacancyWhereUniqueInput[]
    delete?: jobvacancyWhereUniqueInput | jobvacancyWhereUniqueInput[]
    connect?: jobvacancyWhereUniqueInput | jobvacancyWhereUniqueInput[]
    update?: jobvacancyUpdateWithWhereUniqueWithoutApplicationtemplateInput | jobvacancyUpdateWithWhereUniqueWithoutApplicationtemplateInput[]
    updateMany?: jobvacancyUpdateManyWithWhereWithoutApplicationtemplateInput | jobvacancyUpdateManyWithWhereWithoutApplicationtemplateInput[]
    deleteMany?: jobvacancyScalarWhereInput | jobvacancyScalarWhereInput[]
  }

  export type NullableEnumauditlog_ActorRoleFieldUpdateOperationsInput = {
    set?: $Enums.auditlog_ActorRole | null
  }

  export type applicationCreateNestedOneWithoutEmploymenthistoriesInput = {
    create?: XOR<applicationCreateWithoutEmploymenthistoriesInput, applicationUncheckedCreateWithoutEmploymenthistoriesInput>
    connectOrCreate?: applicationCreateOrConnectWithoutEmploymenthistoriesInput
    connect?: applicationWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type applicationUpdateOneWithoutEmploymenthistoriesNestedInput = {
    create?: XOR<applicationCreateWithoutEmploymenthistoriesInput, applicationUncheckedCreateWithoutEmploymenthistoriesInput>
    connectOrCreate?: applicationCreateOrConnectWithoutEmploymenthistoriesInput
    upsert?: applicationUpsertWithoutEmploymenthistoriesInput
    disconnect?: applicationWhereInput | boolean
    delete?: applicationWhereInput | boolean
    connect?: applicationWhereUniqueInput
    update?: XOR<XOR<applicationUpdateToOneWithWhereWithoutEmploymenthistoriesInput, applicationUpdateWithoutEmploymenthistoriesInput>, applicationUncheckedUpdateWithoutEmploymenthistoriesInput>
  }

  export type applicationCreateNestedOneWithoutExperiencedetailsInput = {
    create?: XOR<applicationCreateWithoutExperiencedetailsInput, applicationUncheckedCreateWithoutExperiencedetailsInput>
    connectOrCreate?: applicationCreateOrConnectWithoutExperiencedetailsInput
    connect?: applicationWhereUniqueInput
  }

  export type applicationUpdateOneWithoutExperiencedetailsNestedInput = {
    create?: XOR<applicationCreateWithoutExperiencedetailsInput, applicationUncheckedCreateWithoutExperiencedetailsInput>
    connectOrCreate?: applicationCreateOrConnectWithoutExperiencedetailsInput
    upsert?: applicationUpsertWithoutExperiencedetailsInput
    disconnect?: applicationWhereInput | boolean
    delete?: applicationWhereInput | boolean
    connect?: applicationWhereUniqueInput
    update?: XOR<XOR<applicationUpdateToOneWithWhereWithoutExperiencedetailsInput, applicationUpdateWithoutExperiencedetailsInput>, applicationUncheckedUpdateWithoutExperiencedetailsInput>
  }

  export type applicationCreateNestedOneWithoutGce_al_resultsInput = {
    create?: XOR<applicationCreateWithoutGce_al_resultsInput, applicationUncheckedCreateWithoutGce_al_resultsInput>
    connectOrCreate?: applicationCreateOrConnectWithoutGce_al_resultsInput
    connect?: applicationWhereUniqueInput
  }

  export type applicationUpdateOneWithoutGce_al_resultsNestedInput = {
    create?: XOR<applicationCreateWithoutGce_al_resultsInput, applicationUncheckedCreateWithoutGce_al_resultsInput>
    connectOrCreate?: applicationCreateOrConnectWithoutGce_al_resultsInput
    upsert?: applicationUpsertWithoutGce_al_resultsInput
    disconnect?: applicationWhereInput | boolean
    delete?: applicationWhereInput | boolean
    connect?: applicationWhereUniqueInput
    update?: XOR<XOR<applicationUpdateToOneWithWhereWithoutGce_al_resultsInput, applicationUpdateWithoutGce_al_resultsInput>, applicationUncheckedUpdateWithoutGce_al_resultsInput>
  }

  export type applicationCreateNestedOneWithoutGce_ol_resultsInput = {
    create?: XOR<applicationCreateWithoutGce_ol_resultsInput, applicationUncheckedCreateWithoutGce_ol_resultsInput>
    connectOrCreate?: applicationCreateOrConnectWithoutGce_ol_resultsInput
    connect?: applicationWhereUniqueInput
  }

  export type applicationUpdateOneWithoutGce_ol_resultsNestedInput = {
    create?: XOR<applicationCreateWithoutGce_ol_resultsInput, applicationUncheckedCreateWithoutGce_ol_resultsInput>
    connectOrCreate?: applicationCreateOrConnectWithoutGce_ol_resultsInput
    upsert?: applicationUpsertWithoutGce_ol_resultsInput
    disconnect?: applicationWhereInput | boolean
    delete?: applicationWhereInput | boolean
    connect?: applicationWhereUniqueInput
    update?: XOR<XOR<applicationUpdateToOneWithWhereWithoutGce_ol_resultsInput, applicationUpdateWithoutGce_ol_resultsInput>, applicationUncheckedUpdateWithoutGce_ol_resultsInput>
  }

  export type applicationCreateNestedManyWithoutJobvacancyInput = {
    create?: XOR<applicationCreateWithoutJobvacancyInput, applicationUncheckedCreateWithoutJobvacancyInput> | applicationCreateWithoutJobvacancyInput[] | applicationUncheckedCreateWithoutJobvacancyInput[]
    connectOrCreate?: applicationCreateOrConnectWithoutJobvacancyInput | applicationCreateOrConnectWithoutJobvacancyInput[]
    createMany?: applicationCreateManyJobvacancyInputEnvelope
    connect?: applicationWhereUniqueInput | applicationWhereUniqueInput[]
  }

  export type adminCreateNestedOneWithoutJobvacancyInput = {
    create?: XOR<adminCreateWithoutJobvacancyInput, adminUncheckedCreateWithoutJobvacancyInput>
    connectOrCreate?: adminCreateOrConnectWithoutJobvacancyInput
    connect?: adminWhereUniqueInput
  }

  export type applicationtemplateCreateNestedOneWithoutJobvacancyInput = {
    create?: XOR<applicationtemplateCreateWithoutJobvacancyInput, applicationtemplateUncheckedCreateWithoutJobvacancyInput>
    connectOrCreate?: applicationtemplateCreateOrConnectWithoutJobvacancyInput
    connect?: applicationtemplateWhereUniqueInput
  }

  export type applicationUncheckedCreateNestedManyWithoutJobvacancyInput = {
    create?: XOR<applicationCreateWithoutJobvacancyInput, applicationUncheckedCreateWithoutJobvacancyInput> | applicationCreateWithoutJobvacancyInput[] | applicationUncheckedCreateWithoutJobvacancyInput[]
    connectOrCreate?: applicationCreateOrConnectWithoutJobvacancyInput | applicationCreateOrConnectWithoutJobvacancyInput[]
    createMany?: applicationCreateManyJobvacancyInputEnvelope
    connect?: applicationWhereUniqueInput | applicationWhereUniqueInput[]
  }

  export type NullableEnumjobvacancy_TypeFieldUpdateOperationsInput = {
    set?: $Enums.jobvacancy_Type | null
  }

  export type NullableEnumjobvacancy_StatusFieldUpdateOperationsInput = {
    set?: $Enums.jobvacancy_Status | null
  }

  export type applicationUpdateManyWithoutJobvacancyNestedInput = {
    create?: XOR<applicationCreateWithoutJobvacancyInput, applicationUncheckedCreateWithoutJobvacancyInput> | applicationCreateWithoutJobvacancyInput[] | applicationUncheckedCreateWithoutJobvacancyInput[]
    connectOrCreate?: applicationCreateOrConnectWithoutJobvacancyInput | applicationCreateOrConnectWithoutJobvacancyInput[]
    upsert?: applicationUpsertWithWhereUniqueWithoutJobvacancyInput | applicationUpsertWithWhereUniqueWithoutJobvacancyInput[]
    createMany?: applicationCreateManyJobvacancyInputEnvelope
    set?: applicationWhereUniqueInput | applicationWhereUniqueInput[]
    disconnect?: applicationWhereUniqueInput | applicationWhereUniqueInput[]
    delete?: applicationWhereUniqueInput | applicationWhereUniqueInput[]
    connect?: applicationWhereUniqueInput | applicationWhereUniqueInput[]
    update?: applicationUpdateWithWhereUniqueWithoutJobvacancyInput | applicationUpdateWithWhereUniqueWithoutJobvacancyInput[]
    updateMany?: applicationUpdateManyWithWhereWithoutJobvacancyInput | applicationUpdateManyWithWhereWithoutJobvacancyInput[]
    deleteMany?: applicationScalarWhereInput | applicationScalarWhereInput[]
  }

  export type adminUpdateOneWithoutJobvacancyNestedInput = {
    create?: XOR<adminCreateWithoutJobvacancyInput, adminUncheckedCreateWithoutJobvacancyInput>
    connectOrCreate?: adminCreateOrConnectWithoutJobvacancyInput
    upsert?: adminUpsertWithoutJobvacancyInput
    disconnect?: adminWhereInput | boolean
    delete?: adminWhereInput | boolean
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutJobvacancyInput, adminUpdateWithoutJobvacancyInput>, adminUncheckedUpdateWithoutJobvacancyInput>
  }

  export type applicationtemplateUpdateOneWithoutJobvacancyNestedInput = {
    create?: XOR<applicationtemplateCreateWithoutJobvacancyInput, applicationtemplateUncheckedCreateWithoutJobvacancyInput>
    connectOrCreate?: applicationtemplateCreateOrConnectWithoutJobvacancyInput
    upsert?: applicationtemplateUpsertWithoutJobvacancyInput
    disconnect?: applicationtemplateWhereInput | boolean
    delete?: applicationtemplateWhereInput | boolean
    connect?: applicationtemplateWhereUniqueInput
    update?: XOR<XOR<applicationtemplateUpdateToOneWithWhereWithoutJobvacancyInput, applicationtemplateUpdateWithoutJobvacancyInput>, applicationtemplateUncheckedUpdateWithoutJobvacancyInput>
  }

  export type applicationUncheckedUpdateManyWithoutJobvacancyNestedInput = {
    create?: XOR<applicationCreateWithoutJobvacancyInput, applicationUncheckedCreateWithoutJobvacancyInput> | applicationCreateWithoutJobvacancyInput[] | applicationUncheckedCreateWithoutJobvacancyInput[]
    connectOrCreate?: applicationCreateOrConnectWithoutJobvacancyInput | applicationCreateOrConnectWithoutJobvacancyInput[]
    upsert?: applicationUpsertWithWhereUniqueWithoutJobvacancyInput | applicationUpsertWithWhereUniqueWithoutJobvacancyInput[]
    createMany?: applicationCreateManyJobvacancyInputEnvelope
    set?: applicationWhereUniqueInput | applicationWhereUniqueInput[]
    disconnect?: applicationWhereUniqueInput | applicationWhereUniqueInput[]
    delete?: applicationWhereUniqueInput | applicationWhereUniqueInput[]
    connect?: applicationWhereUniqueInput | applicationWhereUniqueInput[]
    update?: applicationUpdateWithWhereUniqueWithoutJobvacancyInput | applicationUpdateWithWhereUniqueWithoutJobvacancyInput[]
    updateMany?: applicationUpdateManyWithWhereWithoutJobvacancyInput | applicationUpdateManyWithWhereWithoutJobvacancyInput[]
    deleteMany?: applicationScalarWhereInput | applicationScalarWhereInput[]
  }

  export type applicationCreateNestedOneWithoutLanguageproficienciesInput = {
    create?: XOR<applicationCreateWithoutLanguageproficienciesInput, applicationUncheckedCreateWithoutLanguageproficienciesInput>
    connectOrCreate?: applicationCreateOrConnectWithoutLanguageproficienciesInput
    connect?: applicationWhereUniqueInput
  }

  export type NullableEnumlanguageproficiencies_CanSpeakFieldUpdateOperationsInput = {
    set?: $Enums.languageproficiencies_CanSpeak | null
  }

  export type NullableEnumlanguageproficiencies_CanReadFieldUpdateOperationsInput = {
    set?: $Enums.languageproficiencies_CanRead | null
  }

  export type NullableEnumlanguageproficiencies_CanWriteFieldUpdateOperationsInput = {
    set?: $Enums.languageproficiencies_CanWrite | null
  }

  export type NullableEnumlanguageproficiencies_CanTeachFieldUpdateOperationsInput = {
    set?: $Enums.languageproficiencies_CanTeach | null
  }

  export type applicationUpdateOneWithoutLanguageproficienciesNestedInput = {
    create?: XOR<applicationCreateWithoutLanguageproficienciesInput, applicationUncheckedCreateWithoutLanguageproficienciesInput>
    connectOrCreate?: applicationCreateOrConnectWithoutLanguageproficienciesInput
    upsert?: applicationUpsertWithoutLanguageproficienciesInput
    disconnect?: applicationWhereInput | boolean
    delete?: applicationWhereInput | boolean
    connect?: applicationWhereUniqueInput
    update?: XOR<XOR<applicationUpdateToOneWithWhereWithoutLanguageproficienciesInput, applicationUpdateWithoutLanguageproficienciesInput>, applicationUncheckedUpdateWithoutLanguageproficienciesInput>
  }

  export type applicationCreateNestedOneWithoutProfessionalqualificationsInput = {
    create?: XOR<applicationCreateWithoutProfessionalqualificationsInput, applicationUncheckedCreateWithoutProfessionalqualificationsInput>
    connectOrCreate?: applicationCreateOrConnectWithoutProfessionalqualificationsInput
    connect?: applicationWhereUniqueInput
  }

  export type applicationUpdateOneWithoutProfessionalqualificationsNestedInput = {
    create?: XOR<applicationCreateWithoutProfessionalqualificationsInput, applicationUncheckedCreateWithoutProfessionalqualificationsInput>
    connectOrCreate?: applicationCreateOrConnectWithoutProfessionalqualificationsInput
    upsert?: applicationUpsertWithoutProfessionalqualificationsInput
    disconnect?: applicationWhereInput | boolean
    delete?: applicationWhereInput | boolean
    connect?: applicationWhereUniqueInput
    update?: XOR<XOR<applicationUpdateToOneWithWhereWithoutProfessionalqualificationsInput, applicationUpdateWithoutProfessionalqualificationsInput>, applicationUncheckedUpdateWithoutProfessionalqualificationsInput>
  }

  export type applicationCreateNestedOneWithoutResearchandpublicationsInput = {
    create?: XOR<applicationCreateWithoutResearchandpublicationsInput, applicationUncheckedCreateWithoutResearchandpublicationsInput>
    connectOrCreate?: applicationCreateOrConnectWithoutResearchandpublicationsInput
    connect?: applicationWhereUniqueInput
  }

  export type applicationUpdateOneWithoutResearchandpublicationsNestedInput = {
    create?: XOR<applicationCreateWithoutResearchandpublicationsInput, applicationUncheckedCreateWithoutResearchandpublicationsInput>
    connectOrCreate?: applicationCreateOrConnectWithoutResearchandpublicationsInput
    upsert?: applicationUpsertWithoutResearchandpublicationsInput
    disconnect?: applicationWhereInput | boolean
    delete?: applicationWhereInput | boolean
    connect?: applicationWhereUniqueInput
    update?: XOR<XOR<applicationUpdateToOneWithWhereWithoutResearchandpublicationsInput, applicationUpdateWithoutResearchandpublicationsInput>, applicationUncheckedUpdateWithoutResearchandpublicationsInput>
  }

  export type applicationCreateNestedOneWithoutSpecialqualificationsInput = {
    create?: XOR<applicationCreateWithoutSpecialqualificationsInput, applicationUncheckedCreateWithoutSpecialqualificationsInput>
    connectOrCreate?: applicationCreateOrConnectWithoutSpecialqualificationsInput
    connect?: applicationWhereUniqueInput
  }

  export type applicationUpdateOneWithoutSpecialqualificationsNestedInput = {
    create?: XOR<applicationCreateWithoutSpecialqualificationsInput, applicationUncheckedCreateWithoutSpecialqualificationsInput>
    connectOrCreate?: applicationCreateOrConnectWithoutSpecialqualificationsInput
    upsert?: applicationUpsertWithoutSpecialqualificationsInput
    disconnect?: applicationWhereInput | boolean
    delete?: applicationWhereInput | boolean
    connect?: applicationWhereUniqueInput
    update?: XOR<XOR<applicationUpdateToOneWithWhereWithoutSpecialqualificationsInput, applicationUpdateWithoutSpecialqualificationsInput>, applicationUncheckedUpdateWithoutSpecialqualificationsInput>
  }

  export type applicationCreateNestedOneWithoutUniversityeducationsInput = {
    create?: XOR<applicationCreateWithoutUniversityeducationsInput, applicationUncheckedCreateWithoutUniversityeducationsInput>
    connectOrCreate?: applicationCreateOrConnectWithoutUniversityeducationsInput
    connect?: applicationWhereUniqueInput
  }

  export type applicationUpdateOneWithoutUniversityeducationsNestedInput = {
    create?: XOR<applicationCreateWithoutUniversityeducationsInput, applicationUncheckedCreateWithoutUniversityeducationsInput>
    connectOrCreate?: applicationCreateOrConnectWithoutUniversityeducationsInput
    upsert?: applicationUpsertWithoutUniversityeducationsInput
    disconnect?: applicationWhereInput | boolean
    delete?: applicationWhereInput | boolean
    connect?: applicationWhereUniqueInput
    update?: XOR<XOR<applicationUpdateToOneWithWhereWithoutUniversityeducationsInput, applicationUpdateWithoutUniversityeducationsInput>, applicationUncheckedUpdateWithoutUniversityeducationsInput>
  }

  export type applicationCreateNestedManyWithoutUserInput = {
    create?: XOR<applicationCreateWithoutUserInput, applicationUncheckedCreateWithoutUserInput> | applicationCreateWithoutUserInput[] | applicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: applicationCreateOrConnectWithoutUserInput | applicationCreateOrConnectWithoutUserInput[]
    createMany?: applicationCreateManyUserInputEnvelope
    connect?: applicationWhereUniqueInput | applicationWhereUniqueInput[]
  }

  export type applicationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<applicationCreateWithoutUserInput, applicationUncheckedCreateWithoutUserInput> | applicationCreateWithoutUserInput[] | applicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: applicationCreateOrConnectWithoutUserInput | applicationCreateOrConnectWithoutUserInput[]
    createMany?: applicationCreateManyUserInputEnvelope
    connect?: applicationWhereUniqueInput | applicationWhereUniqueInput[]
  }

  export type NullableEnumuser_AccountStatusFieldUpdateOperationsInput = {
    set?: $Enums.user_AccountStatus | null
  }

  export type applicationUpdateManyWithoutUserNestedInput = {
    create?: XOR<applicationCreateWithoutUserInput, applicationUncheckedCreateWithoutUserInput> | applicationCreateWithoutUserInput[] | applicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: applicationCreateOrConnectWithoutUserInput | applicationCreateOrConnectWithoutUserInput[]
    upsert?: applicationUpsertWithWhereUniqueWithoutUserInput | applicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: applicationCreateManyUserInputEnvelope
    set?: applicationWhereUniqueInput | applicationWhereUniqueInput[]
    disconnect?: applicationWhereUniqueInput | applicationWhereUniqueInput[]
    delete?: applicationWhereUniqueInput | applicationWhereUniqueInput[]
    connect?: applicationWhereUniqueInput | applicationWhereUniqueInput[]
    update?: applicationUpdateWithWhereUniqueWithoutUserInput | applicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: applicationUpdateManyWithWhereWithoutUserInput | applicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: applicationScalarWhereInput | applicationScalarWhereInput[]
  }

  export type applicationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<applicationCreateWithoutUserInput, applicationUncheckedCreateWithoutUserInput> | applicationCreateWithoutUserInput[] | applicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: applicationCreateOrConnectWithoutUserInput | applicationCreateOrConnectWithoutUserInput[]
    upsert?: applicationUpsertWithWhereUniqueWithoutUserInput | applicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: applicationCreateManyUserInputEnvelope
    set?: applicationWhereUniqueInput | applicationWhereUniqueInput[]
    disconnect?: applicationWhereUniqueInput | applicationWhereUniqueInput[]
    delete?: applicationWhereUniqueInput | applicationWhereUniqueInput[]
    connect?: applicationWhereUniqueInput | applicationWhereUniqueInput[]
    update?: applicationUpdateWithWhereUniqueWithoutUserInput | applicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: applicationUpdateManyWithWhereWithoutUserInput | applicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: applicationScalarWhereInput | applicationScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumapplication_StatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.application_Status | Enumapplication_StatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.application_Status[] | null
    notIn?: $Enums.application_Status[] | null
    not?: NestedEnumapplication_StatusNullableFilter<$PrismaModel> | $Enums.application_Status | null
  }

  export type NestedEnumapplication_StatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.application_Status | Enumapplication_StatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.application_Status[] | null
    notIn?: $Enums.application_Status[] | null
    not?: NestedEnumapplication_StatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.application_Status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumapplication_StatusNullableFilter<$PrismaModel>
    _max?: NestedEnumapplication_StatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumapplicationgeneraldetails_GenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.applicationgeneraldetails_Gender | Enumapplicationgeneraldetails_GenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.applicationgeneraldetails_Gender[] | null
    notIn?: $Enums.applicationgeneraldetails_Gender[] | null
    not?: NestedEnumapplicationgeneraldetails_GenderNullableFilter<$PrismaModel> | $Enums.applicationgeneraldetails_Gender | null
  }

  export type NestedEnumapplicationgeneraldetails_CitizenshipTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.applicationgeneraldetails_CitizenshipType | Enumapplicationgeneraldetails_CitizenshipTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.applicationgeneraldetails_CitizenshipType[] | null
    notIn?: $Enums.applicationgeneraldetails_CitizenshipType[] | null
    not?: NestedEnumapplicationgeneraldetails_CitizenshipTypeNullableFilter<$PrismaModel> | $Enums.applicationgeneraldetails_CitizenshipType | null
  }

  export type NestedEnumapplicationgeneraldetails_GenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.applicationgeneraldetails_Gender | Enumapplicationgeneraldetails_GenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.applicationgeneraldetails_Gender[] | null
    notIn?: $Enums.applicationgeneraldetails_Gender[] | null
    not?: NestedEnumapplicationgeneraldetails_GenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.applicationgeneraldetails_Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumapplicationgeneraldetails_GenderNullableFilter<$PrismaModel>
    _max?: NestedEnumapplicationgeneraldetails_GenderNullableFilter<$PrismaModel>
  }

  export type NestedEnumapplicationgeneraldetails_CitizenshipTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.applicationgeneraldetails_CitizenshipType | Enumapplicationgeneraldetails_CitizenshipTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.applicationgeneraldetails_CitizenshipType[] | null
    notIn?: $Enums.applicationgeneraldetails_CitizenshipType[] | null
    not?: NestedEnumapplicationgeneraldetails_CitizenshipTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.applicationgeneraldetails_CitizenshipType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumapplicationgeneraldetails_CitizenshipTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumapplicationgeneraldetails_CitizenshipTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumapplicationtemplate_TypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.applicationtemplate_Type | Enumapplicationtemplate_TypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.applicationtemplate_Type[] | null
    notIn?: $Enums.applicationtemplate_Type[] | null
    not?: NestedEnumapplicationtemplate_TypeNullableFilter<$PrismaModel> | $Enums.applicationtemplate_Type | null
  }

  export type NestedEnumapplicationtemplate_TypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.applicationtemplate_Type | Enumapplicationtemplate_TypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.applicationtemplate_Type[] | null
    notIn?: $Enums.applicationtemplate_Type[] | null
    not?: NestedEnumapplicationtemplate_TypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.applicationtemplate_Type | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumapplicationtemplate_TypeNullableFilter<$PrismaModel>
    _max?: NestedEnumapplicationtemplate_TypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumauditlog_ActorRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.auditlog_ActorRole | Enumauditlog_ActorRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.auditlog_ActorRole[] | null
    notIn?: $Enums.auditlog_ActorRole[] | null
    not?: NestedEnumauditlog_ActorRoleNullableFilter<$PrismaModel> | $Enums.auditlog_ActorRole | null
  }

  export type NestedEnumauditlog_ActorRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.auditlog_ActorRole | Enumauditlog_ActorRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.auditlog_ActorRole[] | null
    notIn?: $Enums.auditlog_ActorRole[] | null
    not?: NestedEnumauditlog_ActorRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.auditlog_ActorRole | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumauditlog_ActorRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumauditlog_ActorRoleNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumjobvacancy_TypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.jobvacancy_Type | Enumjobvacancy_TypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.jobvacancy_Type[] | null
    notIn?: $Enums.jobvacancy_Type[] | null
    not?: NestedEnumjobvacancy_TypeNullableFilter<$PrismaModel> | $Enums.jobvacancy_Type | null
  }

  export type NestedEnumjobvacancy_StatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.jobvacancy_Status | Enumjobvacancy_StatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.jobvacancy_Status[] | null
    notIn?: $Enums.jobvacancy_Status[] | null
    not?: NestedEnumjobvacancy_StatusNullableFilter<$PrismaModel> | $Enums.jobvacancy_Status | null
  }

  export type NestedEnumjobvacancy_TypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.jobvacancy_Type | Enumjobvacancy_TypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.jobvacancy_Type[] | null
    notIn?: $Enums.jobvacancy_Type[] | null
    not?: NestedEnumjobvacancy_TypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.jobvacancy_Type | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumjobvacancy_TypeNullableFilter<$PrismaModel>
    _max?: NestedEnumjobvacancy_TypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumjobvacancy_StatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.jobvacancy_Status | Enumjobvacancy_StatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.jobvacancy_Status[] | null
    notIn?: $Enums.jobvacancy_Status[] | null
    not?: NestedEnumjobvacancy_StatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.jobvacancy_Status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumjobvacancy_StatusNullableFilter<$PrismaModel>
    _max?: NestedEnumjobvacancy_StatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumlanguageproficiencies_CanSpeakNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.languageproficiencies_CanSpeak | Enumlanguageproficiencies_CanSpeakFieldRefInput<$PrismaModel> | null
    in?: $Enums.languageproficiencies_CanSpeak[] | null
    notIn?: $Enums.languageproficiencies_CanSpeak[] | null
    not?: NestedEnumlanguageproficiencies_CanSpeakNullableFilter<$PrismaModel> | $Enums.languageproficiencies_CanSpeak | null
  }

  export type NestedEnumlanguageproficiencies_CanReadNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.languageproficiencies_CanRead | Enumlanguageproficiencies_CanReadFieldRefInput<$PrismaModel> | null
    in?: $Enums.languageproficiencies_CanRead[] | null
    notIn?: $Enums.languageproficiencies_CanRead[] | null
    not?: NestedEnumlanguageproficiencies_CanReadNullableFilter<$PrismaModel> | $Enums.languageproficiencies_CanRead | null
  }

  export type NestedEnumlanguageproficiencies_CanWriteNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.languageproficiencies_CanWrite | Enumlanguageproficiencies_CanWriteFieldRefInput<$PrismaModel> | null
    in?: $Enums.languageproficiencies_CanWrite[] | null
    notIn?: $Enums.languageproficiencies_CanWrite[] | null
    not?: NestedEnumlanguageproficiencies_CanWriteNullableFilter<$PrismaModel> | $Enums.languageproficiencies_CanWrite | null
  }

  export type NestedEnumlanguageproficiencies_CanTeachNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.languageproficiencies_CanTeach | Enumlanguageproficiencies_CanTeachFieldRefInput<$PrismaModel> | null
    in?: $Enums.languageproficiencies_CanTeach[] | null
    notIn?: $Enums.languageproficiencies_CanTeach[] | null
    not?: NestedEnumlanguageproficiencies_CanTeachNullableFilter<$PrismaModel> | $Enums.languageproficiencies_CanTeach | null
  }

  export type NestedEnumlanguageproficiencies_CanSpeakNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.languageproficiencies_CanSpeak | Enumlanguageproficiencies_CanSpeakFieldRefInput<$PrismaModel> | null
    in?: $Enums.languageproficiencies_CanSpeak[] | null
    notIn?: $Enums.languageproficiencies_CanSpeak[] | null
    not?: NestedEnumlanguageproficiencies_CanSpeakNullableWithAggregatesFilter<$PrismaModel> | $Enums.languageproficiencies_CanSpeak | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumlanguageproficiencies_CanSpeakNullableFilter<$PrismaModel>
    _max?: NestedEnumlanguageproficiencies_CanSpeakNullableFilter<$PrismaModel>
  }

  export type NestedEnumlanguageproficiencies_CanReadNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.languageproficiencies_CanRead | Enumlanguageproficiencies_CanReadFieldRefInput<$PrismaModel> | null
    in?: $Enums.languageproficiencies_CanRead[] | null
    notIn?: $Enums.languageproficiencies_CanRead[] | null
    not?: NestedEnumlanguageproficiencies_CanReadNullableWithAggregatesFilter<$PrismaModel> | $Enums.languageproficiencies_CanRead | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumlanguageproficiencies_CanReadNullableFilter<$PrismaModel>
    _max?: NestedEnumlanguageproficiencies_CanReadNullableFilter<$PrismaModel>
  }

  export type NestedEnumlanguageproficiencies_CanWriteNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.languageproficiencies_CanWrite | Enumlanguageproficiencies_CanWriteFieldRefInput<$PrismaModel> | null
    in?: $Enums.languageproficiencies_CanWrite[] | null
    notIn?: $Enums.languageproficiencies_CanWrite[] | null
    not?: NestedEnumlanguageproficiencies_CanWriteNullableWithAggregatesFilter<$PrismaModel> | $Enums.languageproficiencies_CanWrite | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumlanguageproficiencies_CanWriteNullableFilter<$PrismaModel>
    _max?: NestedEnumlanguageproficiencies_CanWriteNullableFilter<$PrismaModel>
  }

  export type NestedEnumlanguageproficiencies_CanTeachNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.languageproficiencies_CanTeach | Enumlanguageproficiencies_CanTeachFieldRefInput<$PrismaModel> | null
    in?: $Enums.languageproficiencies_CanTeach[] | null
    notIn?: $Enums.languageproficiencies_CanTeach[] | null
    not?: NestedEnumlanguageproficiencies_CanTeachNullableWithAggregatesFilter<$PrismaModel> | $Enums.languageproficiencies_CanTeach | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumlanguageproficiencies_CanTeachNullableFilter<$PrismaModel>
    _max?: NestedEnumlanguageproficiencies_CanTeachNullableFilter<$PrismaModel>
  }

  export type NestedEnumuser_AccountStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.user_AccountStatus | Enumuser_AccountStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.user_AccountStatus[] | null
    notIn?: $Enums.user_AccountStatus[] | null
    not?: NestedEnumuser_AccountStatusNullableFilter<$PrismaModel> | $Enums.user_AccountStatus | null
  }

  export type NestedEnumuser_AccountStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_AccountStatus | Enumuser_AccountStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.user_AccountStatus[] | null
    notIn?: $Enums.user_AccountStatus[] | null
    not?: NestedEnumuser_AccountStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.user_AccountStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumuser_AccountStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumuser_AccountStatusNullableFilter<$PrismaModel>
  }

  export type applicationCreateWithoutAdditionalinfoInput = {
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    user?: userCreateNestedOneWithoutApplicationInput
    jobvacancy?: jobvacancyCreateNestedOneWithoutApplicationInput
    applicationattachments?: applicationattachmentsCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsCreateNestedManyWithoutApplicationInput
  }

  export type applicationUncheckedCreateWithoutAdditionalinfoInput = {
    ApplicationID?: number
    UserID?: number | null
    JobID?: number | null
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    applicationattachments?: applicationattachmentsUncheckedCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesUncheckedCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesUncheckedCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsUncheckedCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsUncheckedCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsUncheckedCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesUncheckedCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsUncheckedCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type applicationCreateOrConnectWithoutAdditionalinfoInput = {
    where: applicationWhereUniqueInput
    create: XOR<applicationCreateWithoutAdditionalinfoInput, applicationUncheckedCreateWithoutAdditionalinfoInput>
  }

  export type applicationUpsertWithoutAdditionalinfoInput = {
    update: XOR<applicationUpdateWithoutAdditionalinfoInput, applicationUncheckedUpdateWithoutAdditionalinfoInput>
    create: XOR<applicationCreateWithoutAdditionalinfoInput, applicationUncheckedCreateWithoutAdditionalinfoInput>
    where?: applicationWhereInput
  }

  export type applicationUpdateToOneWithWhereWithoutAdditionalinfoInput = {
    where?: applicationWhereInput
    data: XOR<applicationUpdateWithoutAdditionalinfoInput, applicationUncheckedUpdateWithoutAdditionalinfoInput>
  }

  export type applicationUpdateWithoutAdditionalinfoInput = {
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneWithoutApplicationNestedInput
    jobvacancy?: jobvacancyUpdateOneWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUpdateManyWithoutApplicationNestedInput
  }

  export type applicationUncheckedUpdateWithoutAdditionalinfoInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    UserID?: NullableIntFieldUpdateOperationsInput | number | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    applicationattachments?: applicationattachmentsUncheckedUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUncheckedUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUncheckedUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUncheckedUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUncheckedUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type applicationtemplateCreateWithoutAdminInput = {
    Type?: $Enums.applicationtemplate_Type | null
    FilePath?: string | null
    UploadDate?: Date | string | null
    jobvacancy?: jobvacancyCreateNestedManyWithoutApplicationtemplateInput
  }

  export type applicationtemplateUncheckedCreateWithoutAdminInput = {
    TemplateID?: number
    Type?: $Enums.applicationtemplate_Type | null
    FilePath?: string | null
    UploadDate?: Date | string | null
    jobvacancy?: jobvacancyUncheckedCreateNestedManyWithoutApplicationtemplateInput
  }

  export type applicationtemplateCreateOrConnectWithoutAdminInput = {
    where: applicationtemplateWhereUniqueInput
    create: XOR<applicationtemplateCreateWithoutAdminInput, applicationtemplateUncheckedCreateWithoutAdminInput>
  }

  export type applicationtemplateCreateManyAdminInputEnvelope = {
    data: applicationtemplateCreateManyAdminInput | applicationtemplateCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type jobvacancyCreateWithoutAdminInput = {
    Title?: string | null
    Description?: string | null
    Type?: $Enums.jobvacancy_Type | null
    Department?: string | null
    Level?: string | null
    PostedDate?: Date | string | null
    ExpiryDate?: Date | string | null
    Status?: $Enums.jobvacancy_Status | null
    application?: applicationCreateNestedManyWithoutJobvacancyInput
    applicationtemplate?: applicationtemplateCreateNestedOneWithoutJobvacancyInput
  }

  export type jobvacancyUncheckedCreateWithoutAdminInput = {
    JobID?: number
    Title?: string | null
    Description?: string | null
    Type?: $Enums.jobvacancy_Type | null
    Department?: string | null
    Level?: string | null
    PostedDate?: Date | string | null
    ExpiryDate?: Date | string | null
    Status?: $Enums.jobvacancy_Status | null
    TemplateID?: number | null
    application?: applicationUncheckedCreateNestedManyWithoutJobvacancyInput
  }

  export type jobvacancyCreateOrConnectWithoutAdminInput = {
    where: jobvacancyWhereUniqueInput
    create: XOR<jobvacancyCreateWithoutAdminInput, jobvacancyUncheckedCreateWithoutAdminInput>
  }

  export type jobvacancyCreateManyAdminInputEnvelope = {
    data: jobvacancyCreateManyAdminInput | jobvacancyCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type applicationtemplateUpsertWithWhereUniqueWithoutAdminInput = {
    where: applicationtemplateWhereUniqueInput
    update: XOR<applicationtemplateUpdateWithoutAdminInput, applicationtemplateUncheckedUpdateWithoutAdminInput>
    create: XOR<applicationtemplateCreateWithoutAdminInput, applicationtemplateUncheckedCreateWithoutAdminInput>
  }

  export type applicationtemplateUpdateWithWhereUniqueWithoutAdminInput = {
    where: applicationtemplateWhereUniqueInput
    data: XOR<applicationtemplateUpdateWithoutAdminInput, applicationtemplateUncheckedUpdateWithoutAdminInput>
  }

  export type applicationtemplateUpdateManyWithWhereWithoutAdminInput = {
    where: applicationtemplateScalarWhereInput
    data: XOR<applicationtemplateUpdateManyMutationInput, applicationtemplateUncheckedUpdateManyWithoutAdminInput>
  }

  export type applicationtemplateScalarWhereInput = {
    AND?: applicationtemplateScalarWhereInput | applicationtemplateScalarWhereInput[]
    OR?: applicationtemplateScalarWhereInput[]
    NOT?: applicationtemplateScalarWhereInput | applicationtemplateScalarWhereInput[]
    TemplateID?: IntFilter<"applicationtemplate"> | number
    Type?: Enumapplicationtemplate_TypeNullableFilter<"applicationtemplate"> | $Enums.applicationtemplate_Type | null
    FilePath?: StringNullableFilter<"applicationtemplate"> | string | null
    UploadedBy?: IntNullableFilter<"applicationtemplate"> | number | null
    UploadDate?: DateTimeNullableFilter<"applicationtemplate"> | Date | string | null
  }

  export type jobvacancyUpsertWithWhereUniqueWithoutAdminInput = {
    where: jobvacancyWhereUniqueInput
    update: XOR<jobvacancyUpdateWithoutAdminInput, jobvacancyUncheckedUpdateWithoutAdminInput>
    create: XOR<jobvacancyCreateWithoutAdminInput, jobvacancyUncheckedCreateWithoutAdminInput>
  }

  export type jobvacancyUpdateWithWhereUniqueWithoutAdminInput = {
    where: jobvacancyWhereUniqueInput
    data: XOR<jobvacancyUpdateWithoutAdminInput, jobvacancyUncheckedUpdateWithoutAdminInput>
  }

  export type jobvacancyUpdateManyWithWhereWithoutAdminInput = {
    where: jobvacancyScalarWhereInput
    data: XOR<jobvacancyUpdateManyMutationInput, jobvacancyUncheckedUpdateManyWithoutAdminInput>
  }

  export type jobvacancyScalarWhereInput = {
    AND?: jobvacancyScalarWhereInput | jobvacancyScalarWhereInput[]
    OR?: jobvacancyScalarWhereInput[]
    NOT?: jobvacancyScalarWhereInput | jobvacancyScalarWhereInput[]
    JobID?: IntFilter<"jobvacancy"> | number
    Title?: StringNullableFilter<"jobvacancy"> | string | null
    Description?: StringNullableFilter<"jobvacancy"> | string | null
    Type?: Enumjobvacancy_TypeNullableFilter<"jobvacancy"> | $Enums.jobvacancy_Type | null
    Department?: StringNullableFilter<"jobvacancy"> | string | null
    Level?: StringNullableFilter<"jobvacancy"> | string | null
    PostedBy?: IntNullableFilter<"jobvacancy"> | number | null
    PostedDate?: DateTimeNullableFilter<"jobvacancy"> | Date | string | null
    ExpiryDate?: DateTimeNullableFilter<"jobvacancy"> | Date | string | null
    Status?: Enumjobvacancy_StatusNullableFilter<"jobvacancy"> | $Enums.jobvacancy_Status | null
    TemplateID?: IntNullableFilter<"jobvacancy"> | number | null
  }

  export type additionalinfoCreateWithoutApplicationInput = {
    Content?: string | null
  }

  export type additionalinfoUncheckedCreateWithoutApplicationInput = {
    InfoID?: number
    Content?: string | null
  }

  export type additionalinfoCreateOrConnectWithoutApplicationInput = {
    where: additionalinfoWhereUniqueInput
    create: XOR<additionalinfoCreateWithoutApplicationInput, additionalinfoUncheckedCreateWithoutApplicationInput>
  }

  export type additionalinfoCreateManyApplicationInputEnvelope = {
    data: additionalinfoCreateManyApplicationInput | additionalinfoCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutApplicationInput = {
    FullName?: string | null
    Email?: string | null
    PasswordHash?: string | null
    NIC?: string | null
    PhoneNumber?: string | null
    Address?: string | null
    AccountStatus?: $Enums.user_AccountStatus | null
    CreatedAt?: Date | string | null
    UpdatedAt?: Date | string | null
  }

  export type userUncheckedCreateWithoutApplicationInput = {
    UserID?: number
    FullName?: string | null
    Email?: string | null
    PasswordHash?: string | null
    NIC?: string | null
    PhoneNumber?: string | null
    Address?: string | null
    AccountStatus?: $Enums.user_AccountStatus | null
    CreatedAt?: Date | string | null
    UpdatedAt?: Date | string | null
  }

  export type userCreateOrConnectWithoutApplicationInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutApplicationInput, userUncheckedCreateWithoutApplicationInput>
  }

  export type jobvacancyCreateWithoutApplicationInput = {
    Title?: string | null
    Description?: string | null
    Type?: $Enums.jobvacancy_Type | null
    Department?: string | null
    Level?: string | null
    PostedDate?: Date | string | null
    ExpiryDate?: Date | string | null
    Status?: $Enums.jobvacancy_Status | null
    admin?: adminCreateNestedOneWithoutJobvacancyInput
    applicationtemplate?: applicationtemplateCreateNestedOneWithoutJobvacancyInput
  }

  export type jobvacancyUncheckedCreateWithoutApplicationInput = {
    JobID?: number
    Title?: string | null
    Description?: string | null
    Type?: $Enums.jobvacancy_Type | null
    Department?: string | null
    Level?: string | null
    PostedBy?: number | null
    PostedDate?: Date | string | null
    ExpiryDate?: Date | string | null
    Status?: $Enums.jobvacancy_Status | null
    TemplateID?: number | null
  }

  export type jobvacancyCreateOrConnectWithoutApplicationInput = {
    where: jobvacancyWhereUniqueInput
    create: XOR<jobvacancyCreateWithoutApplicationInput, jobvacancyUncheckedCreateWithoutApplicationInput>
  }

  export type applicationattachmentsCreateWithoutApplicationInput = {
    FileType?: string | null
    FilePath?: string | null
    UploadedAt?: Date | string | null
  }

  export type applicationattachmentsUncheckedCreateWithoutApplicationInput = {
    AttachmentID?: number
    FileType?: string | null
    FilePath?: string | null
    UploadedAt?: Date | string | null
  }

  export type applicationattachmentsCreateOrConnectWithoutApplicationInput = {
    where: applicationattachmentsWhereUniqueInput
    create: XOR<applicationattachmentsCreateWithoutApplicationInput, applicationattachmentsUncheckedCreateWithoutApplicationInput>
  }

  export type applicationattachmentsCreateManyApplicationInputEnvelope = {
    data: applicationattachmentsCreateManyApplicationInput | applicationattachmentsCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type applicationgeneraldetailsCreateWithoutApplicationInput = {
    PostApplied?: string | null
    FullName?: string | null
    NameWithInitials?: string | null
    NIC?: string | null
    DOB?: Date | string | null
    Gender?: $Enums.applicationgeneraldetails_Gender | null
    PhoneNumber?: string | null
    Email?: string | null
    PresentAddress?: string | null
    PermanentAddress?: string | null
    CivilStatus?: string | null
    CitizenshipType?: $Enums.applicationgeneraldetails_CitizenshipType | null
    CitizenshipDetails?: string | null
    EthnicityOrReligion?: string | null
  }

  export type applicationgeneraldetailsUncheckedCreateWithoutApplicationInput = {
    PostApplied?: string | null
    FullName?: string | null
    NameWithInitials?: string | null
    NIC?: string | null
    DOB?: Date | string | null
    Gender?: $Enums.applicationgeneraldetails_Gender | null
    PhoneNumber?: string | null
    Email?: string | null
    PresentAddress?: string | null
    PermanentAddress?: string | null
    CivilStatus?: string | null
    CitizenshipType?: $Enums.applicationgeneraldetails_CitizenshipType | null
    CitizenshipDetails?: string | null
    EthnicityOrReligion?: string | null
  }

  export type applicationgeneraldetailsCreateOrConnectWithoutApplicationInput = {
    where: applicationgeneraldetailsWhereUniqueInput
    create: XOR<applicationgeneraldetailsCreateWithoutApplicationInput, applicationgeneraldetailsUncheckedCreateWithoutApplicationInput>
  }

  export type applicationreferencesCreateWithoutApplicationInput = {
    Name?: string | null
    Designation?: string | null
    Address?: string | null
  }

  export type applicationreferencesUncheckedCreateWithoutApplicationInput = {
    ReferenceID?: number
    Name?: string | null
    Designation?: string | null
    Address?: string | null
  }

  export type applicationreferencesCreateOrConnectWithoutApplicationInput = {
    where: applicationreferencesWhereUniqueInput
    create: XOR<applicationreferencesCreateWithoutApplicationInput, applicationreferencesUncheckedCreateWithoutApplicationInput>
  }

  export type applicationreferencesCreateManyApplicationInputEnvelope = {
    data: applicationreferencesCreateManyApplicationInput | applicationreferencesCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type employmenthistoriesCreateWithoutApplicationInput = {
    PostHeld?: string | null
    Institution?: string | null
    FromDate?: Date | string | null
    ToDate?: Date | string | null
    LastSalary?: Decimal | DecimalJsLike | number | string | null
  }

  export type employmenthistoriesUncheckedCreateWithoutApplicationInput = {
    EmploymentID?: number
    PostHeld?: string | null
    Institution?: string | null
    FromDate?: Date | string | null
    ToDate?: Date | string | null
    LastSalary?: Decimal | DecimalJsLike | number | string | null
  }

  export type employmenthistoriesCreateOrConnectWithoutApplicationInput = {
    where: employmenthistoriesWhereUniqueInput
    create: XOR<employmenthistoriesCreateWithoutApplicationInput, employmenthistoriesUncheckedCreateWithoutApplicationInput>
  }

  export type employmenthistoriesCreateManyApplicationInputEnvelope = {
    data: employmenthistoriesCreateManyApplicationInput | employmenthistoriesCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type experiencedetailsCreateWithoutApplicationInput = {
    Description?: string | null
  }

  export type experiencedetailsUncheckedCreateWithoutApplicationInput = {
    ExperienceID?: number
    Description?: string | null
  }

  export type experiencedetailsCreateOrConnectWithoutApplicationInput = {
    where: experiencedetailsWhereUniqueInput
    create: XOR<experiencedetailsCreateWithoutApplicationInput, experiencedetailsUncheckedCreateWithoutApplicationInput>
  }

  export type experiencedetailsCreateManyApplicationInputEnvelope = {
    data: experiencedetailsCreateManyApplicationInput | experiencedetailsCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type gce_al_resultsCreateWithoutApplicationInput = {
    Subject?: string | null
    Grade?: string | null
  }

  export type gce_al_resultsUncheckedCreateWithoutApplicationInput = {
    AL_ID?: number
    Subject?: string | null
    Grade?: string | null
  }

  export type gce_al_resultsCreateOrConnectWithoutApplicationInput = {
    where: gce_al_resultsWhereUniqueInput
    create: XOR<gce_al_resultsCreateWithoutApplicationInput, gce_al_resultsUncheckedCreateWithoutApplicationInput>
  }

  export type gce_al_resultsCreateManyApplicationInputEnvelope = {
    data: gce_al_resultsCreateManyApplicationInput | gce_al_resultsCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type gce_ol_resultsCreateWithoutApplicationInput = {
    Subject?: string | null
    Grade?: string | null
  }

  export type gce_ol_resultsUncheckedCreateWithoutApplicationInput = {
    OL_ID?: number
    Subject?: string | null
    Grade?: string | null
  }

  export type gce_ol_resultsCreateOrConnectWithoutApplicationInput = {
    where: gce_ol_resultsWhereUniqueInput
    create: XOR<gce_ol_resultsCreateWithoutApplicationInput, gce_ol_resultsUncheckedCreateWithoutApplicationInput>
  }

  export type gce_ol_resultsCreateManyApplicationInputEnvelope = {
    data: gce_ol_resultsCreateManyApplicationInput | gce_ol_resultsCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type languageproficienciesCreateWithoutApplicationInput = {
    Language?: string | null
    CanSpeak?: $Enums.languageproficiencies_CanSpeak | null
    CanRead?: $Enums.languageproficiencies_CanRead | null
    CanWrite?: $Enums.languageproficiencies_CanWrite | null
    CanTeach?: $Enums.languageproficiencies_CanTeach | null
  }

  export type languageproficienciesUncheckedCreateWithoutApplicationInput = {
    LangProfID?: number
    Language?: string | null
    CanSpeak?: $Enums.languageproficiencies_CanSpeak | null
    CanRead?: $Enums.languageproficiencies_CanRead | null
    CanWrite?: $Enums.languageproficiencies_CanWrite | null
    CanTeach?: $Enums.languageproficiencies_CanTeach | null
  }

  export type languageproficienciesCreateOrConnectWithoutApplicationInput = {
    where: languageproficienciesWhereUniqueInput
    create: XOR<languageproficienciesCreateWithoutApplicationInput, languageproficienciesUncheckedCreateWithoutApplicationInput>
  }

  export type languageproficienciesCreateManyApplicationInputEnvelope = {
    data: languageproficienciesCreateManyApplicationInput | languageproficienciesCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type professionalqualificationsCreateWithoutApplicationInput = {
    Institution?: string | null
    QualificationName?: string | null
    FromYear?: number | null
    ToYear?: number | null
    ResultOrExamPassed?: string | null
  }

  export type professionalqualificationsUncheckedCreateWithoutApplicationInput = {
    PQ_ID?: number
    Institution?: string | null
    QualificationName?: string | null
    FromYear?: number | null
    ToYear?: number | null
    ResultOrExamPassed?: string | null
  }

  export type professionalqualificationsCreateOrConnectWithoutApplicationInput = {
    where: professionalqualificationsWhereUniqueInput
    create: XOR<professionalqualificationsCreateWithoutApplicationInput, professionalqualificationsUncheckedCreateWithoutApplicationInput>
  }

  export type professionalqualificationsCreateManyApplicationInputEnvelope = {
    data: professionalqualificationsCreateManyApplicationInput | professionalqualificationsCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type researchandpublicationsCreateWithoutApplicationInput = {
    Description?: string | null
  }

  export type researchandpublicationsUncheckedCreateWithoutApplicationInput = {
    ResearchID?: number
    Description?: string | null
  }

  export type researchandpublicationsCreateOrConnectWithoutApplicationInput = {
    where: researchandpublicationsWhereUniqueInput
    create: XOR<researchandpublicationsCreateWithoutApplicationInput, researchandpublicationsUncheckedCreateWithoutApplicationInput>
  }

  export type researchandpublicationsCreateManyApplicationInputEnvelope = {
    data: researchandpublicationsCreateManyApplicationInput | researchandpublicationsCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type specialqualificationsCreateWithoutApplicationInput = {
    Description?: string | null
  }

  export type specialqualificationsUncheckedCreateWithoutApplicationInput = {
    SpecialQualID?: number
    Description?: string | null
  }

  export type specialqualificationsCreateOrConnectWithoutApplicationInput = {
    where: specialqualificationsWhereUniqueInput
    create: XOR<specialqualificationsCreateWithoutApplicationInput, specialqualificationsUncheckedCreateWithoutApplicationInput>
  }

  export type specialqualificationsCreateManyApplicationInputEnvelope = {
    data: specialqualificationsCreateManyApplicationInput | specialqualificationsCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type universityeducationsCreateWithoutApplicationInput = {
    DegreeOrDiploma?: string | null
    Institute?: string | null
    FromYear?: number | null
    ToYear?: number | null
    Class?: string | null
    YearObtained?: number | null
    IndexNumber?: string | null
  }

  export type universityeducationsUncheckedCreateWithoutApplicationInput = {
    UE_ID?: number
    DegreeOrDiploma?: string | null
    Institute?: string | null
    FromYear?: number | null
    ToYear?: number | null
    Class?: string | null
    YearObtained?: number | null
    IndexNumber?: string | null
  }

  export type universityeducationsCreateOrConnectWithoutApplicationInput = {
    where: universityeducationsWhereUniqueInput
    create: XOR<universityeducationsCreateWithoutApplicationInput, universityeducationsUncheckedCreateWithoutApplicationInput>
  }

  export type universityeducationsCreateManyApplicationInputEnvelope = {
    data: universityeducationsCreateManyApplicationInput | universityeducationsCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type additionalinfoUpsertWithWhereUniqueWithoutApplicationInput = {
    where: additionalinfoWhereUniqueInput
    update: XOR<additionalinfoUpdateWithoutApplicationInput, additionalinfoUncheckedUpdateWithoutApplicationInput>
    create: XOR<additionalinfoCreateWithoutApplicationInput, additionalinfoUncheckedCreateWithoutApplicationInput>
  }

  export type additionalinfoUpdateWithWhereUniqueWithoutApplicationInput = {
    where: additionalinfoWhereUniqueInput
    data: XOR<additionalinfoUpdateWithoutApplicationInput, additionalinfoUncheckedUpdateWithoutApplicationInput>
  }

  export type additionalinfoUpdateManyWithWhereWithoutApplicationInput = {
    where: additionalinfoScalarWhereInput
    data: XOR<additionalinfoUpdateManyMutationInput, additionalinfoUncheckedUpdateManyWithoutApplicationInput>
  }

  export type additionalinfoScalarWhereInput = {
    AND?: additionalinfoScalarWhereInput | additionalinfoScalarWhereInput[]
    OR?: additionalinfoScalarWhereInput[]
    NOT?: additionalinfoScalarWhereInput | additionalinfoScalarWhereInput[]
    InfoID?: IntFilter<"additionalinfo"> | number
    ApplicationID?: IntNullableFilter<"additionalinfo"> | number | null
    Content?: StringNullableFilter<"additionalinfo"> | string | null
  }

  export type userUpsertWithoutApplicationInput = {
    update: XOR<userUpdateWithoutApplicationInput, userUncheckedUpdateWithoutApplicationInput>
    create: XOR<userCreateWithoutApplicationInput, userUncheckedCreateWithoutApplicationInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutApplicationInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutApplicationInput, userUncheckedUpdateWithoutApplicationInput>
  }

  export type userUpdateWithoutApplicationInput = {
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    AccountStatus?: NullableEnumuser_AccountStatusFieldUpdateOperationsInput | $Enums.user_AccountStatus | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUncheckedUpdateWithoutApplicationInput = {
    UserID?: IntFieldUpdateOperationsInput | number
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    AccountStatus?: NullableEnumuser_AccountStatusFieldUpdateOperationsInput | $Enums.user_AccountStatus | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type jobvacancyUpsertWithoutApplicationInput = {
    update: XOR<jobvacancyUpdateWithoutApplicationInput, jobvacancyUncheckedUpdateWithoutApplicationInput>
    create: XOR<jobvacancyCreateWithoutApplicationInput, jobvacancyUncheckedCreateWithoutApplicationInput>
    where?: jobvacancyWhereInput
  }

  export type jobvacancyUpdateToOneWithWhereWithoutApplicationInput = {
    where?: jobvacancyWhereInput
    data: XOR<jobvacancyUpdateWithoutApplicationInput, jobvacancyUncheckedUpdateWithoutApplicationInput>
  }

  export type jobvacancyUpdateWithoutApplicationInput = {
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableEnumjobvacancy_TypeFieldUpdateOperationsInput | $Enums.jobvacancy_Type | null
    Department?: NullableStringFieldUpdateOperationsInput | string | null
    Level?: NullableStringFieldUpdateOperationsInput | string | null
    PostedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumjobvacancy_StatusFieldUpdateOperationsInput | $Enums.jobvacancy_Status | null
    admin?: adminUpdateOneWithoutJobvacancyNestedInput
    applicationtemplate?: applicationtemplateUpdateOneWithoutJobvacancyNestedInput
  }

  export type jobvacancyUncheckedUpdateWithoutApplicationInput = {
    JobID?: IntFieldUpdateOperationsInput | number
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableEnumjobvacancy_TypeFieldUpdateOperationsInput | $Enums.jobvacancy_Type | null
    Department?: NullableStringFieldUpdateOperationsInput | string | null
    Level?: NullableStringFieldUpdateOperationsInput | string | null
    PostedBy?: NullableIntFieldUpdateOperationsInput | number | null
    PostedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumjobvacancy_StatusFieldUpdateOperationsInput | $Enums.jobvacancy_Status | null
    TemplateID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type applicationattachmentsUpsertWithWhereUniqueWithoutApplicationInput = {
    where: applicationattachmentsWhereUniqueInput
    update: XOR<applicationattachmentsUpdateWithoutApplicationInput, applicationattachmentsUncheckedUpdateWithoutApplicationInput>
    create: XOR<applicationattachmentsCreateWithoutApplicationInput, applicationattachmentsUncheckedCreateWithoutApplicationInput>
  }

  export type applicationattachmentsUpdateWithWhereUniqueWithoutApplicationInput = {
    where: applicationattachmentsWhereUniqueInput
    data: XOR<applicationattachmentsUpdateWithoutApplicationInput, applicationattachmentsUncheckedUpdateWithoutApplicationInput>
  }

  export type applicationattachmentsUpdateManyWithWhereWithoutApplicationInput = {
    where: applicationattachmentsScalarWhereInput
    data: XOR<applicationattachmentsUpdateManyMutationInput, applicationattachmentsUncheckedUpdateManyWithoutApplicationInput>
  }

  export type applicationattachmentsScalarWhereInput = {
    AND?: applicationattachmentsScalarWhereInput | applicationattachmentsScalarWhereInput[]
    OR?: applicationattachmentsScalarWhereInput[]
    NOT?: applicationattachmentsScalarWhereInput | applicationattachmentsScalarWhereInput[]
    AttachmentID?: IntFilter<"applicationattachments"> | number
    ApplicationID?: IntNullableFilter<"applicationattachments"> | number | null
    FileType?: StringNullableFilter<"applicationattachments"> | string | null
    FilePath?: StringNullableFilter<"applicationattachments"> | string | null
    UploadedAt?: DateTimeNullableFilter<"applicationattachments"> | Date | string | null
  }

  export type applicationgeneraldetailsUpsertWithoutApplicationInput = {
    update: XOR<applicationgeneraldetailsUpdateWithoutApplicationInput, applicationgeneraldetailsUncheckedUpdateWithoutApplicationInput>
    create: XOR<applicationgeneraldetailsCreateWithoutApplicationInput, applicationgeneraldetailsUncheckedCreateWithoutApplicationInput>
    where?: applicationgeneraldetailsWhereInput
  }

  export type applicationgeneraldetailsUpdateToOneWithWhereWithoutApplicationInput = {
    where?: applicationgeneraldetailsWhereInput
    data: XOR<applicationgeneraldetailsUpdateWithoutApplicationInput, applicationgeneraldetailsUncheckedUpdateWithoutApplicationInput>
  }

  export type applicationgeneraldetailsUpdateWithoutApplicationInput = {
    PostApplied?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    NameWithInitials?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Gender?: NullableEnumapplicationgeneraldetails_GenderFieldUpdateOperationsInput | $Enums.applicationgeneraldetails_Gender | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PresentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    PermanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    CivilStatus?: NullableStringFieldUpdateOperationsInput | string | null
    CitizenshipType?: NullableEnumapplicationgeneraldetails_CitizenshipTypeFieldUpdateOperationsInput | $Enums.applicationgeneraldetails_CitizenshipType | null
    CitizenshipDetails?: NullableStringFieldUpdateOperationsInput | string | null
    EthnicityOrReligion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type applicationgeneraldetailsUncheckedUpdateWithoutApplicationInput = {
    PostApplied?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    NameWithInitials?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Gender?: NullableEnumapplicationgeneraldetails_GenderFieldUpdateOperationsInput | $Enums.applicationgeneraldetails_Gender | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PresentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    PermanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    CivilStatus?: NullableStringFieldUpdateOperationsInput | string | null
    CitizenshipType?: NullableEnumapplicationgeneraldetails_CitizenshipTypeFieldUpdateOperationsInput | $Enums.applicationgeneraldetails_CitizenshipType | null
    CitizenshipDetails?: NullableStringFieldUpdateOperationsInput | string | null
    EthnicityOrReligion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type applicationreferencesUpsertWithWhereUniqueWithoutApplicationInput = {
    where: applicationreferencesWhereUniqueInput
    update: XOR<applicationreferencesUpdateWithoutApplicationInput, applicationreferencesUncheckedUpdateWithoutApplicationInput>
    create: XOR<applicationreferencesCreateWithoutApplicationInput, applicationreferencesUncheckedCreateWithoutApplicationInput>
  }

  export type applicationreferencesUpdateWithWhereUniqueWithoutApplicationInput = {
    where: applicationreferencesWhereUniqueInput
    data: XOR<applicationreferencesUpdateWithoutApplicationInput, applicationreferencesUncheckedUpdateWithoutApplicationInput>
  }

  export type applicationreferencesUpdateManyWithWhereWithoutApplicationInput = {
    where: applicationreferencesScalarWhereInput
    data: XOR<applicationreferencesUpdateManyMutationInput, applicationreferencesUncheckedUpdateManyWithoutApplicationInput>
  }

  export type applicationreferencesScalarWhereInput = {
    AND?: applicationreferencesScalarWhereInput | applicationreferencesScalarWhereInput[]
    OR?: applicationreferencesScalarWhereInput[]
    NOT?: applicationreferencesScalarWhereInput | applicationreferencesScalarWhereInput[]
    ReferenceID?: IntFilter<"applicationreferences"> | number
    ApplicationID?: IntNullableFilter<"applicationreferences"> | number | null
    Name?: StringNullableFilter<"applicationreferences"> | string | null
    Designation?: StringNullableFilter<"applicationreferences"> | string | null
    Address?: StringNullableFilter<"applicationreferences"> | string | null
  }

  export type employmenthistoriesUpsertWithWhereUniqueWithoutApplicationInput = {
    where: employmenthistoriesWhereUniqueInput
    update: XOR<employmenthistoriesUpdateWithoutApplicationInput, employmenthistoriesUncheckedUpdateWithoutApplicationInput>
    create: XOR<employmenthistoriesCreateWithoutApplicationInput, employmenthistoriesUncheckedCreateWithoutApplicationInput>
  }

  export type employmenthistoriesUpdateWithWhereUniqueWithoutApplicationInput = {
    where: employmenthistoriesWhereUniqueInput
    data: XOR<employmenthistoriesUpdateWithoutApplicationInput, employmenthistoriesUncheckedUpdateWithoutApplicationInput>
  }

  export type employmenthistoriesUpdateManyWithWhereWithoutApplicationInput = {
    where: employmenthistoriesScalarWhereInput
    data: XOR<employmenthistoriesUpdateManyMutationInput, employmenthistoriesUncheckedUpdateManyWithoutApplicationInput>
  }

  export type employmenthistoriesScalarWhereInput = {
    AND?: employmenthistoriesScalarWhereInput | employmenthistoriesScalarWhereInput[]
    OR?: employmenthistoriesScalarWhereInput[]
    NOT?: employmenthistoriesScalarWhereInput | employmenthistoriesScalarWhereInput[]
    EmploymentID?: IntFilter<"employmenthistories"> | number
    ApplicationID?: IntNullableFilter<"employmenthistories"> | number | null
    PostHeld?: StringNullableFilter<"employmenthistories"> | string | null
    Institution?: StringNullableFilter<"employmenthistories"> | string | null
    FromDate?: DateTimeNullableFilter<"employmenthistories"> | Date | string | null
    ToDate?: DateTimeNullableFilter<"employmenthistories"> | Date | string | null
    LastSalary?: DecimalNullableFilter<"employmenthistories"> | Decimal | DecimalJsLike | number | string | null
  }

  export type experiencedetailsUpsertWithWhereUniqueWithoutApplicationInput = {
    where: experiencedetailsWhereUniqueInput
    update: XOR<experiencedetailsUpdateWithoutApplicationInput, experiencedetailsUncheckedUpdateWithoutApplicationInput>
    create: XOR<experiencedetailsCreateWithoutApplicationInput, experiencedetailsUncheckedCreateWithoutApplicationInput>
  }

  export type experiencedetailsUpdateWithWhereUniqueWithoutApplicationInput = {
    where: experiencedetailsWhereUniqueInput
    data: XOR<experiencedetailsUpdateWithoutApplicationInput, experiencedetailsUncheckedUpdateWithoutApplicationInput>
  }

  export type experiencedetailsUpdateManyWithWhereWithoutApplicationInput = {
    where: experiencedetailsScalarWhereInput
    data: XOR<experiencedetailsUpdateManyMutationInput, experiencedetailsUncheckedUpdateManyWithoutApplicationInput>
  }

  export type experiencedetailsScalarWhereInput = {
    AND?: experiencedetailsScalarWhereInput | experiencedetailsScalarWhereInput[]
    OR?: experiencedetailsScalarWhereInput[]
    NOT?: experiencedetailsScalarWhereInput | experiencedetailsScalarWhereInput[]
    ExperienceID?: IntFilter<"experiencedetails"> | number
    ApplicationID?: IntNullableFilter<"experiencedetails"> | number | null
    Description?: StringNullableFilter<"experiencedetails"> | string | null
  }

  export type gce_al_resultsUpsertWithWhereUniqueWithoutApplicationInput = {
    where: gce_al_resultsWhereUniqueInput
    update: XOR<gce_al_resultsUpdateWithoutApplicationInput, gce_al_resultsUncheckedUpdateWithoutApplicationInput>
    create: XOR<gce_al_resultsCreateWithoutApplicationInput, gce_al_resultsUncheckedCreateWithoutApplicationInput>
  }

  export type gce_al_resultsUpdateWithWhereUniqueWithoutApplicationInput = {
    where: gce_al_resultsWhereUniqueInput
    data: XOR<gce_al_resultsUpdateWithoutApplicationInput, gce_al_resultsUncheckedUpdateWithoutApplicationInput>
  }

  export type gce_al_resultsUpdateManyWithWhereWithoutApplicationInput = {
    where: gce_al_resultsScalarWhereInput
    data: XOR<gce_al_resultsUpdateManyMutationInput, gce_al_resultsUncheckedUpdateManyWithoutApplicationInput>
  }

  export type gce_al_resultsScalarWhereInput = {
    AND?: gce_al_resultsScalarWhereInput | gce_al_resultsScalarWhereInput[]
    OR?: gce_al_resultsScalarWhereInput[]
    NOT?: gce_al_resultsScalarWhereInput | gce_al_resultsScalarWhereInput[]
    AL_ID?: IntFilter<"gce_al_results"> | number
    ApplicationID?: IntNullableFilter<"gce_al_results"> | number | null
    Subject?: StringNullableFilter<"gce_al_results"> | string | null
    Grade?: StringNullableFilter<"gce_al_results"> | string | null
  }

  export type gce_ol_resultsUpsertWithWhereUniqueWithoutApplicationInput = {
    where: gce_ol_resultsWhereUniqueInput
    update: XOR<gce_ol_resultsUpdateWithoutApplicationInput, gce_ol_resultsUncheckedUpdateWithoutApplicationInput>
    create: XOR<gce_ol_resultsCreateWithoutApplicationInput, gce_ol_resultsUncheckedCreateWithoutApplicationInput>
  }

  export type gce_ol_resultsUpdateWithWhereUniqueWithoutApplicationInput = {
    where: gce_ol_resultsWhereUniqueInput
    data: XOR<gce_ol_resultsUpdateWithoutApplicationInput, gce_ol_resultsUncheckedUpdateWithoutApplicationInput>
  }

  export type gce_ol_resultsUpdateManyWithWhereWithoutApplicationInput = {
    where: gce_ol_resultsScalarWhereInput
    data: XOR<gce_ol_resultsUpdateManyMutationInput, gce_ol_resultsUncheckedUpdateManyWithoutApplicationInput>
  }

  export type gce_ol_resultsScalarWhereInput = {
    AND?: gce_ol_resultsScalarWhereInput | gce_ol_resultsScalarWhereInput[]
    OR?: gce_ol_resultsScalarWhereInput[]
    NOT?: gce_ol_resultsScalarWhereInput | gce_ol_resultsScalarWhereInput[]
    OL_ID?: IntFilter<"gce_ol_results"> | number
    ApplicationID?: IntNullableFilter<"gce_ol_results"> | number | null
    Subject?: StringNullableFilter<"gce_ol_results"> | string | null
    Grade?: StringNullableFilter<"gce_ol_results"> | string | null
  }

  export type languageproficienciesUpsertWithWhereUniqueWithoutApplicationInput = {
    where: languageproficienciesWhereUniqueInput
    update: XOR<languageproficienciesUpdateWithoutApplicationInput, languageproficienciesUncheckedUpdateWithoutApplicationInput>
    create: XOR<languageproficienciesCreateWithoutApplicationInput, languageproficienciesUncheckedCreateWithoutApplicationInput>
  }

  export type languageproficienciesUpdateWithWhereUniqueWithoutApplicationInput = {
    where: languageproficienciesWhereUniqueInput
    data: XOR<languageproficienciesUpdateWithoutApplicationInput, languageproficienciesUncheckedUpdateWithoutApplicationInput>
  }

  export type languageproficienciesUpdateManyWithWhereWithoutApplicationInput = {
    where: languageproficienciesScalarWhereInput
    data: XOR<languageproficienciesUpdateManyMutationInput, languageproficienciesUncheckedUpdateManyWithoutApplicationInput>
  }

  export type languageproficienciesScalarWhereInput = {
    AND?: languageproficienciesScalarWhereInput | languageproficienciesScalarWhereInput[]
    OR?: languageproficienciesScalarWhereInput[]
    NOT?: languageproficienciesScalarWhereInput | languageproficienciesScalarWhereInput[]
    LangProfID?: IntFilter<"languageproficiencies"> | number
    ApplicationID?: IntNullableFilter<"languageproficiencies"> | number | null
    Language?: StringNullableFilter<"languageproficiencies"> | string | null
    CanSpeak?: Enumlanguageproficiencies_CanSpeakNullableFilter<"languageproficiencies"> | $Enums.languageproficiencies_CanSpeak | null
    CanRead?: Enumlanguageproficiencies_CanReadNullableFilter<"languageproficiencies"> | $Enums.languageproficiencies_CanRead | null
    CanWrite?: Enumlanguageproficiencies_CanWriteNullableFilter<"languageproficiencies"> | $Enums.languageproficiencies_CanWrite | null
    CanTeach?: Enumlanguageproficiencies_CanTeachNullableFilter<"languageproficiencies"> | $Enums.languageproficiencies_CanTeach | null
  }

  export type professionalqualificationsUpsertWithWhereUniqueWithoutApplicationInput = {
    where: professionalqualificationsWhereUniqueInput
    update: XOR<professionalqualificationsUpdateWithoutApplicationInput, professionalqualificationsUncheckedUpdateWithoutApplicationInput>
    create: XOR<professionalqualificationsCreateWithoutApplicationInput, professionalqualificationsUncheckedCreateWithoutApplicationInput>
  }

  export type professionalqualificationsUpdateWithWhereUniqueWithoutApplicationInput = {
    where: professionalqualificationsWhereUniqueInput
    data: XOR<professionalqualificationsUpdateWithoutApplicationInput, professionalqualificationsUncheckedUpdateWithoutApplicationInput>
  }

  export type professionalqualificationsUpdateManyWithWhereWithoutApplicationInput = {
    where: professionalqualificationsScalarWhereInput
    data: XOR<professionalqualificationsUpdateManyMutationInput, professionalqualificationsUncheckedUpdateManyWithoutApplicationInput>
  }

  export type professionalqualificationsScalarWhereInput = {
    AND?: professionalqualificationsScalarWhereInput | professionalqualificationsScalarWhereInput[]
    OR?: professionalqualificationsScalarWhereInput[]
    NOT?: professionalqualificationsScalarWhereInput | professionalqualificationsScalarWhereInput[]
    PQ_ID?: IntFilter<"professionalqualifications"> | number
    ApplicationID?: IntNullableFilter<"professionalqualifications"> | number | null
    Institution?: StringNullableFilter<"professionalqualifications"> | string | null
    QualificationName?: StringNullableFilter<"professionalqualifications"> | string | null
    FromYear?: IntNullableFilter<"professionalqualifications"> | number | null
    ToYear?: IntNullableFilter<"professionalqualifications"> | number | null
    ResultOrExamPassed?: StringNullableFilter<"professionalqualifications"> | string | null
  }

  export type researchandpublicationsUpsertWithWhereUniqueWithoutApplicationInput = {
    where: researchandpublicationsWhereUniqueInput
    update: XOR<researchandpublicationsUpdateWithoutApplicationInput, researchandpublicationsUncheckedUpdateWithoutApplicationInput>
    create: XOR<researchandpublicationsCreateWithoutApplicationInput, researchandpublicationsUncheckedCreateWithoutApplicationInput>
  }

  export type researchandpublicationsUpdateWithWhereUniqueWithoutApplicationInput = {
    where: researchandpublicationsWhereUniqueInput
    data: XOR<researchandpublicationsUpdateWithoutApplicationInput, researchandpublicationsUncheckedUpdateWithoutApplicationInput>
  }

  export type researchandpublicationsUpdateManyWithWhereWithoutApplicationInput = {
    where: researchandpublicationsScalarWhereInput
    data: XOR<researchandpublicationsUpdateManyMutationInput, researchandpublicationsUncheckedUpdateManyWithoutApplicationInput>
  }

  export type researchandpublicationsScalarWhereInput = {
    AND?: researchandpublicationsScalarWhereInput | researchandpublicationsScalarWhereInput[]
    OR?: researchandpublicationsScalarWhereInput[]
    NOT?: researchandpublicationsScalarWhereInput | researchandpublicationsScalarWhereInput[]
    ResearchID?: IntFilter<"researchandpublications"> | number
    ApplicationID?: IntNullableFilter<"researchandpublications"> | number | null
    Description?: StringNullableFilter<"researchandpublications"> | string | null
  }

  export type specialqualificationsUpsertWithWhereUniqueWithoutApplicationInput = {
    where: specialqualificationsWhereUniqueInput
    update: XOR<specialqualificationsUpdateWithoutApplicationInput, specialqualificationsUncheckedUpdateWithoutApplicationInput>
    create: XOR<specialqualificationsCreateWithoutApplicationInput, specialqualificationsUncheckedCreateWithoutApplicationInput>
  }

  export type specialqualificationsUpdateWithWhereUniqueWithoutApplicationInput = {
    where: specialqualificationsWhereUniqueInput
    data: XOR<specialqualificationsUpdateWithoutApplicationInput, specialqualificationsUncheckedUpdateWithoutApplicationInput>
  }

  export type specialqualificationsUpdateManyWithWhereWithoutApplicationInput = {
    where: specialqualificationsScalarWhereInput
    data: XOR<specialqualificationsUpdateManyMutationInput, specialqualificationsUncheckedUpdateManyWithoutApplicationInput>
  }

  export type specialqualificationsScalarWhereInput = {
    AND?: specialqualificationsScalarWhereInput | specialqualificationsScalarWhereInput[]
    OR?: specialqualificationsScalarWhereInput[]
    NOT?: specialqualificationsScalarWhereInput | specialqualificationsScalarWhereInput[]
    SpecialQualID?: IntFilter<"specialqualifications"> | number
    ApplicationID?: IntNullableFilter<"specialqualifications"> | number | null
    Description?: StringNullableFilter<"specialqualifications"> | string | null
  }

  export type universityeducationsUpsertWithWhereUniqueWithoutApplicationInput = {
    where: universityeducationsWhereUniqueInput
    update: XOR<universityeducationsUpdateWithoutApplicationInput, universityeducationsUncheckedUpdateWithoutApplicationInput>
    create: XOR<universityeducationsCreateWithoutApplicationInput, universityeducationsUncheckedCreateWithoutApplicationInput>
  }

  export type universityeducationsUpdateWithWhereUniqueWithoutApplicationInput = {
    where: universityeducationsWhereUniqueInput
    data: XOR<universityeducationsUpdateWithoutApplicationInput, universityeducationsUncheckedUpdateWithoutApplicationInput>
  }

  export type universityeducationsUpdateManyWithWhereWithoutApplicationInput = {
    where: universityeducationsScalarWhereInput
    data: XOR<universityeducationsUpdateManyMutationInput, universityeducationsUncheckedUpdateManyWithoutApplicationInput>
  }

  export type universityeducationsScalarWhereInput = {
    AND?: universityeducationsScalarWhereInput | universityeducationsScalarWhereInput[]
    OR?: universityeducationsScalarWhereInput[]
    NOT?: universityeducationsScalarWhereInput | universityeducationsScalarWhereInput[]
    UE_ID?: IntFilter<"universityeducations"> | number
    ApplicationID?: IntNullableFilter<"universityeducations"> | number | null
    DegreeOrDiploma?: StringNullableFilter<"universityeducations"> | string | null
    Institute?: StringNullableFilter<"universityeducations"> | string | null
    FromYear?: IntNullableFilter<"universityeducations"> | number | null
    ToYear?: IntNullableFilter<"universityeducations"> | number | null
    Class?: StringNullableFilter<"universityeducations"> | string | null
    YearObtained?: IntNullableFilter<"universityeducations"> | number | null
    IndexNumber?: StringNullableFilter<"universityeducations"> | string | null
  }

  export type applicationCreateWithoutApplicationattachmentsInput = {
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoCreateNestedManyWithoutApplicationInput
    user?: userCreateNestedOneWithoutApplicationInput
    jobvacancy?: jobvacancyCreateNestedOneWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsCreateNestedManyWithoutApplicationInput
  }

  export type applicationUncheckedCreateWithoutApplicationattachmentsInput = {
    ApplicationID?: number
    UserID?: number | null
    JobID?: number | null
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoUncheckedCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesUncheckedCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesUncheckedCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsUncheckedCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsUncheckedCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsUncheckedCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesUncheckedCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsUncheckedCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type applicationCreateOrConnectWithoutApplicationattachmentsInput = {
    where: applicationWhereUniqueInput
    create: XOR<applicationCreateWithoutApplicationattachmentsInput, applicationUncheckedCreateWithoutApplicationattachmentsInput>
  }

  export type applicationUpsertWithoutApplicationattachmentsInput = {
    update: XOR<applicationUpdateWithoutApplicationattachmentsInput, applicationUncheckedUpdateWithoutApplicationattachmentsInput>
    create: XOR<applicationCreateWithoutApplicationattachmentsInput, applicationUncheckedCreateWithoutApplicationattachmentsInput>
    where?: applicationWhereInput
  }

  export type applicationUpdateToOneWithWhereWithoutApplicationattachmentsInput = {
    where?: applicationWhereInput
    data: XOR<applicationUpdateWithoutApplicationattachmentsInput, applicationUncheckedUpdateWithoutApplicationattachmentsInput>
  }

  export type applicationUpdateWithoutApplicationattachmentsInput = {
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUpdateManyWithoutApplicationNestedInput
    user?: userUpdateOneWithoutApplicationNestedInput
    jobvacancy?: jobvacancyUpdateOneWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUpdateManyWithoutApplicationNestedInput
  }

  export type applicationUncheckedUpdateWithoutApplicationattachmentsInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    UserID?: NullableIntFieldUpdateOperationsInput | number | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUncheckedUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUncheckedUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUncheckedUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUncheckedUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUncheckedUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type applicationCreateWithoutApplicationgeneraldetailsInput = {
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoCreateNestedManyWithoutApplicationInput
    user?: userCreateNestedOneWithoutApplicationInput
    jobvacancy?: jobvacancyCreateNestedOneWithoutApplicationInput
    applicationattachments?: applicationattachmentsCreateNestedManyWithoutApplicationInput
    applicationreferences?: applicationreferencesCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsCreateNestedManyWithoutApplicationInput
  }

  export type applicationUncheckedCreateWithoutApplicationgeneraldetailsInput = {
    ApplicationID?: number
    UserID?: number | null
    JobID?: number | null
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoUncheckedCreateNestedManyWithoutApplicationInput
    applicationattachments?: applicationattachmentsUncheckedCreateNestedManyWithoutApplicationInput
    applicationreferences?: applicationreferencesUncheckedCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesUncheckedCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsUncheckedCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsUncheckedCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsUncheckedCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesUncheckedCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsUncheckedCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type applicationCreateOrConnectWithoutApplicationgeneraldetailsInput = {
    where: applicationWhereUniqueInput
    create: XOR<applicationCreateWithoutApplicationgeneraldetailsInput, applicationUncheckedCreateWithoutApplicationgeneraldetailsInput>
  }

  export type applicationUpsertWithoutApplicationgeneraldetailsInput = {
    update: XOR<applicationUpdateWithoutApplicationgeneraldetailsInput, applicationUncheckedUpdateWithoutApplicationgeneraldetailsInput>
    create: XOR<applicationCreateWithoutApplicationgeneraldetailsInput, applicationUncheckedCreateWithoutApplicationgeneraldetailsInput>
    where?: applicationWhereInput
  }

  export type applicationUpdateToOneWithWhereWithoutApplicationgeneraldetailsInput = {
    where?: applicationWhereInput
    data: XOR<applicationUpdateWithoutApplicationgeneraldetailsInput, applicationUncheckedUpdateWithoutApplicationgeneraldetailsInput>
  }

  export type applicationUpdateWithoutApplicationgeneraldetailsInput = {
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUpdateManyWithoutApplicationNestedInput
    user?: userUpdateOneWithoutApplicationNestedInput
    jobvacancy?: jobvacancyUpdateOneWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUpdateManyWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUpdateManyWithoutApplicationNestedInput
  }

  export type applicationUncheckedUpdateWithoutApplicationgeneraldetailsInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    UserID?: NullableIntFieldUpdateOperationsInput | number | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUncheckedUpdateManyWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUncheckedUpdateManyWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUncheckedUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUncheckedUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUncheckedUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUncheckedUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type applicationCreateWithoutApplicationreferencesInput = {
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoCreateNestedManyWithoutApplicationInput
    user?: userCreateNestedOneWithoutApplicationInput
    jobvacancy?: jobvacancyCreateNestedOneWithoutApplicationInput
    applicationattachments?: applicationattachmentsCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsCreateNestedOneWithoutApplicationInput
    employmenthistories?: employmenthistoriesCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsCreateNestedManyWithoutApplicationInput
  }

  export type applicationUncheckedCreateWithoutApplicationreferencesInput = {
    ApplicationID?: number
    UserID?: number | null
    JobID?: number | null
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoUncheckedCreateNestedManyWithoutApplicationInput
    applicationattachments?: applicationattachmentsUncheckedCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedCreateNestedOneWithoutApplicationInput
    employmenthistories?: employmenthistoriesUncheckedCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsUncheckedCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsUncheckedCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsUncheckedCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesUncheckedCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsUncheckedCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type applicationCreateOrConnectWithoutApplicationreferencesInput = {
    where: applicationWhereUniqueInput
    create: XOR<applicationCreateWithoutApplicationreferencesInput, applicationUncheckedCreateWithoutApplicationreferencesInput>
  }

  export type applicationUpsertWithoutApplicationreferencesInput = {
    update: XOR<applicationUpdateWithoutApplicationreferencesInput, applicationUncheckedUpdateWithoutApplicationreferencesInput>
    create: XOR<applicationCreateWithoutApplicationreferencesInput, applicationUncheckedCreateWithoutApplicationreferencesInput>
    where?: applicationWhereInput
  }

  export type applicationUpdateToOneWithWhereWithoutApplicationreferencesInput = {
    where?: applicationWhereInput
    data: XOR<applicationUpdateWithoutApplicationreferencesInput, applicationUncheckedUpdateWithoutApplicationreferencesInput>
  }

  export type applicationUpdateWithoutApplicationreferencesInput = {
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUpdateManyWithoutApplicationNestedInput
    user?: userUpdateOneWithoutApplicationNestedInput
    jobvacancy?: jobvacancyUpdateOneWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUpdateOneWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUpdateManyWithoutApplicationNestedInput
  }

  export type applicationUncheckedUpdateWithoutApplicationreferencesInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    UserID?: NullableIntFieldUpdateOperationsInput | number | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUncheckedUpdateManyWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUncheckedUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedUpdateOneWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUncheckedUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUncheckedUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUncheckedUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type adminCreateWithoutApplicationtemplateInput = {
    FullName?: string | null
    Email?: string | null
    PasswordHash?: string | null
    Department?: string | null
    PhoneNumber?: string | null
    CreatedAt?: Date | string | null
    UpdatedAt?: Date | string | null
    isDeleted?: boolean | null
    jobvacancy?: jobvacancyCreateNestedManyWithoutAdminInput
  }

  export type adminUncheckedCreateWithoutApplicationtemplateInput = {
    AdminID?: number
    FullName?: string | null
    Email?: string | null
    PasswordHash?: string | null
    Department?: string | null
    PhoneNumber?: string | null
    CreatedAt?: Date | string | null
    UpdatedAt?: Date | string | null
    isDeleted?: boolean | null
    jobvacancy?: jobvacancyUncheckedCreateNestedManyWithoutAdminInput
  }

  export type adminCreateOrConnectWithoutApplicationtemplateInput = {
    where: adminWhereUniqueInput
    create: XOR<adminCreateWithoutApplicationtemplateInput, adminUncheckedCreateWithoutApplicationtemplateInput>
  }

  export type jobvacancyCreateWithoutApplicationtemplateInput = {
    Title?: string | null
    Description?: string | null
    Type?: $Enums.jobvacancy_Type | null
    Department?: string | null
    Level?: string | null
    PostedDate?: Date | string | null
    ExpiryDate?: Date | string | null
    Status?: $Enums.jobvacancy_Status | null
    application?: applicationCreateNestedManyWithoutJobvacancyInput
    admin?: adminCreateNestedOneWithoutJobvacancyInput
  }

  export type jobvacancyUncheckedCreateWithoutApplicationtemplateInput = {
    JobID?: number
    Title?: string | null
    Description?: string | null
    Type?: $Enums.jobvacancy_Type | null
    Department?: string | null
    Level?: string | null
    PostedBy?: number | null
    PostedDate?: Date | string | null
    ExpiryDate?: Date | string | null
    Status?: $Enums.jobvacancy_Status | null
    application?: applicationUncheckedCreateNestedManyWithoutJobvacancyInput
  }

  export type jobvacancyCreateOrConnectWithoutApplicationtemplateInput = {
    where: jobvacancyWhereUniqueInput
    create: XOR<jobvacancyCreateWithoutApplicationtemplateInput, jobvacancyUncheckedCreateWithoutApplicationtemplateInput>
  }

  export type jobvacancyCreateManyApplicationtemplateInputEnvelope = {
    data: jobvacancyCreateManyApplicationtemplateInput | jobvacancyCreateManyApplicationtemplateInput[]
    skipDuplicates?: boolean
  }

  export type adminUpsertWithoutApplicationtemplateInput = {
    update: XOR<adminUpdateWithoutApplicationtemplateInput, adminUncheckedUpdateWithoutApplicationtemplateInput>
    create: XOR<adminCreateWithoutApplicationtemplateInput, adminUncheckedCreateWithoutApplicationtemplateInput>
    where?: adminWhereInput
  }

  export type adminUpdateToOneWithWhereWithoutApplicationtemplateInput = {
    where?: adminWhereInput
    data: XOR<adminUpdateWithoutApplicationtemplateInput, adminUncheckedUpdateWithoutApplicationtemplateInput>
  }

  export type adminUpdateWithoutApplicationtemplateInput = {
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    Department?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    jobvacancy?: jobvacancyUpdateManyWithoutAdminNestedInput
  }

  export type adminUncheckedUpdateWithoutApplicationtemplateInput = {
    AdminID?: IntFieldUpdateOperationsInput | number
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    Department?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    jobvacancy?: jobvacancyUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type jobvacancyUpsertWithWhereUniqueWithoutApplicationtemplateInput = {
    where: jobvacancyWhereUniqueInput
    update: XOR<jobvacancyUpdateWithoutApplicationtemplateInput, jobvacancyUncheckedUpdateWithoutApplicationtemplateInput>
    create: XOR<jobvacancyCreateWithoutApplicationtemplateInput, jobvacancyUncheckedCreateWithoutApplicationtemplateInput>
  }

  export type jobvacancyUpdateWithWhereUniqueWithoutApplicationtemplateInput = {
    where: jobvacancyWhereUniqueInput
    data: XOR<jobvacancyUpdateWithoutApplicationtemplateInput, jobvacancyUncheckedUpdateWithoutApplicationtemplateInput>
  }

  export type jobvacancyUpdateManyWithWhereWithoutApplicationtemplateInput = {
    where: jobvacancyScalarWhereInput
    data: XOR<jobvacancyUpdateManyMutationInput, jobvacancyUncheckedUpdateManyWithoutApplicationtemplateInput>
  }

  export type applicationCreateWithoutEmploymenthistoriesInput = {
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoCreateNestedManyWithoutApplicationInput
    user?: userCreateNestedOneWithoutApplicationInput
    jobvacancy?: jobvacancyCreateNestedOneWithoutApplicationInput
    applicationattachments?: applicationattachmentsCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsCreateNestedManyWithoutApplicationInput
  }

  export type applicationUncheckedCreateWithoutEmploymenthistoriesInput = {
    ApplicationID?: number
    UserID?: number | null
    JobID?: number | null
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoUncheckedCreateNestedManyWithoutApplicationInput
    applicationattachments?: applicationattachmentsUncheckedCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesUncheckedCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsUncheckedCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsUncheckedCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsUncheckedCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesUncheckedCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsUncheckedCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type applicationCreateOrConnectWithoutEmploymenthistoriesInput = {
    where: applicationWhereUniqueInput
    create: XOR<applicationCreateWithoutEmploymenthistoriesInput, applicationUncheckedCreateWithoutEmploymenthistoriesInput>
  }

  export type applicationUpsertWithoutEmploymenthistoriesInput = {
    update: XOR<applicationUpdateWithoutEmploymenthistoriesInput, applicationUncheckedUpdateWithoutEmploymenthistoriesInput>
    create: XOR<applicationCreateWithoutEmploymenthistoriesInput, applicationUncheckedCreateWithoutEmploymenthistoriesInput>
    where?: applicationWhereInput
  }

  export type applicationUpdateToOneWithWhereWithoutEmploymenthistoriesInput = {
    where?: applicationWhereInput
    data: XOR<applicationUpdateWithoutEmploymenthistoriesInput, applicationUncheckedUpdateWithoutEmploymenthistoriesInput>
  }

  export type applicationUpdateWithoutEmploymenthistoriesInput = {
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUpdateManyWithoutApplicationNestedInput
    user?: userUpdateOneWithoutApplicationNestedInput
    jobvacancy?: jobvacancyUpdateOneWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUpdateManyWithoutApplicationNestedInput
  }

  export type applicationUncheckedUpdateWithoutEmploymenthistoriesInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    UserID?: NullableIntFieldUpdateOperationsInput | number | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUncheckedUpdateManyWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUncheckedUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUncheckedUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUncheckedUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUncheckedUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type applicationCreateWithoutExperiencedetailsInput = {
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoCreateNestedManyWithoutApplicationInput
    user?: userCreateNestedOneWithoutApplicationInput
    jobvacancy?: jobvacancyCreateNestedOneWithoutApplicationInput
    applicationattachments?: applicationattachmentsCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsCreateNestedManyWithoutApplicationInput
  }

  export type applicationUncheckedCreateWithoutExperiencedetailsInput = {
    ApplicationID?: number
    UserID?: number | null
    JobID?: number | null
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoUncheckedCreateNestedManyWithoutApplicationInput
    applicationattachments?: applicationattachmentsUncheckedCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesUncheckedCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesUncheckedCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsUncheckedCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsUncheckedCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesUncheckedCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsUncheckedCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type applicationCreateOrConnectWithoutExperiencedetailsInput = {
    where: applicationWhereUniqueInput
    create: XOR<applicationCreateWithoutExperiencedetailsInput, applicationUncheckedCreateWithoutExperiencedetailsInput>
  }

  export type applicationUpsertWithoutExperiencedetailsInput = {
    update: XOR<applicationUpdateWithoutExperiencedetailsInput, applicationUncheckedUpdateWithoutExperiencedetailsInput>
    create: XOR<applicationCreateWithoutExperiencedetailsInput, applicationUncheckedCreateWithoutExperiencedetailsInput>
    where?: applicationWhereInput
  }

  export type applicationUpdateToOneWithWhereWithoutExperiencedetailsInput = {
    where?: applicationWhereInput
    data: XOR<applicationUpdateWithoutExperiencedetailsInput, applicationUncheckedUpdateWithoutExperiencedetailsInput>
  }

  export type applicationUpdateWithoutExperiencedetailsInput = {
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUpdateManyWithoutApplicationNestedInput
    user?: userUpdateOneWithoutApplicationNestedInput
    jobvacancy?: jobvacancyUpdateOneWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUpdateManyWithoutApplicationNestedInput
  }

  export type applicationUncheckedUpdateWithoutExperiencedetailsInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    UserID?: NullableIntFieldUpdateOperationsInput | number | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUncheckedUpdateManyWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUncheckedUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUncheckedUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUncheckedUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUncheckedUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUncheckedUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type applicationCreateWithoutGce_al_resultsInput = {
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoCreateNestedManyWithoutApplicationInput
    user?: userCreateNestedOneWithoutApplicationInput
    jobvacancy?: jobvacancyCreateNestedOneWithoutApplicationInput
    applicationattachments?: applicationattachmentsCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsCreateNestedManyWithoutApplicationInput
  }

  export type applicationUncheckedCreateWithoutGce_al_resultsInput = {
    ApplicationID?: number
    UserID?: number | null
    JobID?: number | null
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoUncheckedCreateNestedManyWithoutApplicationInput
    applicationattachments?: applicationattachmentsUncheckedCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesUncheckedCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesUncheckedCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsUncheckedCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsUncheckedCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesUncheckedCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsUncheckedCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type applicationCreateOrConnectWithoutGce_al_resultsInput = {
    where: applicationWhereUniqueInput
    create: XOR<applicationCreateWithoutGce_al_resultsInput, applicationUncheckedCreateWithoutGce_al_resultsInput>
  }

  export type applicationUpsertWithoutGce_al_resultsInput = {
    update: XOR<applicationUpdateWithoutGce_al_resultsInput, applicationUncheckedUpdateWithoutGce_al_resultsInput>
    create: XOR<applicationCreateWithoutGce_al_resultsInput, applicationUncheckedCreateWithoutGce_al_resultsInput>
    where?: applicationWhereInput
  }

  export type applicationUpdateToOneWithWhereWithoutGce_al_resultsInput = {
    where?: applicationWhereInput
    data: XOR<applicationUpdateWithoutGce_al_resultsInput, applicationUncheckedUpdateWithoutGce_al_resultsInput>
  }

  export type applicationUpdateWithoutGce_al_resultsInput = {
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUpdateManyWithoutApplicationNestedInput
    user?: userUpdateOneWithoutApplicationNestedInput
    jobvacancy?: jobvacancyUpdateOneWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUpdateManyWithoutApplicationNestedInput
  }

  export type applicationUncheckedUpdateWithoutGce_al_resultsInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    UserID?: NullableIntFieldUpdateOperationsInput | number | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUncheckedUpdateManyWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUncheckedUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUncheckedUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUncheckedUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUncheckedUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUncheckedUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type applicationCreateWithoutGce_ol_resultsInput = {
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoCreateNestedManyWithoutApplicationInput
    user?: userCreateNestedOneWithoutApplicationInput
    jobvacancy?: jobvacancyCreateNestedOneWithoutApplicationInput
    applicationattachments?: applicationattachmentsCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsCreateNestedManyWithoutApplicationInput
  }

  export type applicationUncheckedCreateWithoutGce_ol_resultsInput = {
    ApplicationID?: number
    UserID?: number | null
    JobID?: number | null
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoUncheckedCreateNestedManyWithoutApplicationInput
    applicationattachments?: applicationattachmentsUncheckedCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesUncheckedCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesUncheckedCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsUncheckedCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsUncheckedCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesUncheckedCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsUncheckedCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type applicationCreateOrConnectWithoutGce_ol_resultsInput = {
    where: applicationWhereUniqueInput
    create: XOR<applicationCreateWithoutGce_ol_resultsInput, applicationUncheckedCreateWithoutGce_ol_resultsInput>
  }

  export type applicationUpsertWithoutGce_ol_resultsInput = {
    update: XOR<applicationUpdateWithoutGce_ol_resultsInput, applicationUncheckedUpdateWithoutGce_ol_resultsInput>
    create: XOR<applicationCreateWithoutGce_ol_resultsInput, applicationUncheckedCreateWithoutGce_ol_resultsInput>
    where?: applicationWhereInput
  }

  export type applicationUpdateToOneWithWhereWithoutGce_ol_resultsInput = {
    where?: applicationWhereInput
    data: XOR<applicationUpdateWithoutGce_ol_resultsInput, applicationUncheckedUpdateWithoutGce_ol_resultsInput>
  }

  export type applicationUpdateWithoutGce_ol_resultsInput = {
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUpdateManyWithoutApplicationNestedInput
    user?: userUpdateOneWithoutApplicationNestedInput
    jobvacancy?: jobvacancyUpdateOneWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUpdateManyWithoutApplicationNestedInput
  }

  export type applicationUncheckedUpdateWithoutGce_ol_resultsInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    UserID?: NullableIntFieldUpdateOperationsInput | number | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUncheckedUpdateManyWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUncheckedUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUncheckedUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUncheckedUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUncheckedUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUncheckedUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type applicationCreateWithoutJobvacancyInput = {
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoCreateNestedManyWithoutApplicationInput
    user?: userCreateNestedOneWithoutApplicationInput
    applicationattachments?: applicationattachmentsCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsCreateNestedManyWithoutApplicationInput
  }

  export type applicationUncheckedCreateWithoutJobvacancyInput = {
    ApplicationID?: number
    UserID?: number | null
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoUncheckedCreateNestedManyWithoutApplicationInput
    applicationattachments?: applicationattachmentsUncheckedCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesUncheckedCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesUncheckedCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsUncheckedCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsUncheckedCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsUncheckedCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesUncheckedCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsUncheckedCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type applicationCreateOrConnectWithoutJobvacancyInput = {
    where: applicationWhereUniqueInput
    create: XOR<applicationCreateWithoutJobvacancyInput, applicationUncheckedCreateWithoutJobvacancyInput>
  }

  export type applicationCreateManyJobvacancyInputEnvelope = {
    data: applicationCreateManyJobvacancyInput | applicationCreateManyJobvacancyInput[]
    skipDuplicates?: boolean
  }

  export type adminCreateWithoutJobvacancyInput = {
    FullName?: string | null
    Email?: string | null
    PasswordHash?: string | null
    Department?: string | null
    PhoneNumber?: string | null
    CreatedAt?: Date | string | null
    UpdatedAt?: Date | string | null
    isDeleted?: boolean | null
    applicationtemplate?: applicationtemplateCreateNestedManyWithoutAdminInput
  }

  export type adminUncheckedCreateWithoutJobvacancyInput = {
    AdminID?: number
    FullName?: string | null
    Email?: string | null
    PasswordHash?: string | null
    Department?: string | null
    PhoneNumber?: string | null
    CreatedAt?: Date | string | null
    UpdatedAt?: Date | string | null
    isDeleted?: boolean | null
    applicationtemplate?: applicationtemplateUncheckedCreateNestedManyWithoutAdminInput
  }

  export type adminCreateOrConnectWithoutJobvacancyInput = {
    where: adminWhereUniqueInput
    create: XOR<adminCreateWithoutJobvacancyInput, adminUncheckedCreateWithoutJobvacancyInput>
  }

  export type applicationtemplateCreateWithoutJobvacancyInput = {
    Type?: $Enums.applicationtemplate_Type | null
    FilePath?: string | null
    UploadDate?: Date | string | null
    admin?: adminCreateNestedOneWithoutApplicationtemplateInput
  }

  export type applicationtemplateUncheckedCreateWithoutJobvacancyInput = {
    TemplateID?: number
    Type?: $Enums.applicationtemplate_Type | null
    FilePath?: string | null
    UploadedBy?: number | null
    UploadDate?: Date | string | null
  }

  export type applicationtemplateCreateOrConnectWithoutJobvacancyInput = {
    where: applicationtemplateWhereUniqueInput
    create: XOR<applicationtemplateCreateWithoutJobvacancyInput, applicationtemplateUncheckedCreateWithoutJobvacancyInput>
  }

  export type applicationUpsertWithWhereUniqueWithoutJobvacancyInput = {
    where: applicationWhereUniqueInput
    update: XOR<applicationUpdateWithoutJobvacancyInput, applicationUncheckedUpdateWithoutJobvacancyInput>
    create: XOR<applicationCreateWithoutJobvacancyInput, applicationUncheckedCreateWithoutJobvacancyInput>
  }

  export type applicationUpdateWithWhereUniqueWithoutJobvacancyInput = {
    where: applicationWhereUniqueInput
    data: XOR<applicationUpdateWithoutJobvacancyInput, applicationUncheckedUpdateWithoutJobvacancyInput>
  }

  export type applicationUpdateManyWithWhereWithoutJobvacancyInput = {
    where: applicationScalarWhereInput
    data: XOR<applicationUpdateManyMutationInput, applicationUncheckedUpdateManyWithoutJobvacancyInput>
  }

  export type applicationScalarWhereInput = {
    AND?: applicationScalarWhereInput | applicationScalarWhereInput[]
    OR?: applicationScalarWhereInput[]
    NOT?: applicationScalarWhereInput | applicationScalarWhereInput[]
    ApplicationID?: IntFilter<"application"> | number
    UserID?: IntNullableFilter<"application"> | number | null
    JobID?: IntNullableFilter<"application"> | number | null
    SubmissionDate?: DateTimeNullableFilter<"application"> | Date | string | null
    Status?: Enumapplication_StatusNullableFilter<"application"> | $Enums.application_Status | null
    Remarks?: StringNullableFilter<"application"> | string | null
  }

  export type adminUpsertWithoutJobvacancyInput = {
    update: XOR<adminUpdateWithoutJobvacancyInput, adminUncheckedUpdateWithoutJobvacancyInput>
    create: XOR<adminCreateWithoutJobvacancyInput, adminUncheckedCreateWithoutJobvacancyInput>
    where?: adminWhereInput
  }

  export type adminUpdateToOneWithWhereWithoutJobvacancyInput = {
    where?: adminWhereInput
    data: XOR<adminUpdateWithoutJobvacancyInput, adminUncheckedUpdateWithoutJobvacancyInput>
  }

  export type adminUpdateWithoutJobvacancyInput = {
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    Department?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    applicationtemplate?: applicationtemplateUpdateManyWithoutAdminNestedInput
  }

  export type adminUncheckedUpdateWithoutJobvacancyInput = {
    AdminID?: IntFieldUpdateOperationsInput | number
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    Department?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    applicationtemplate?: applicationtemplateUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type applicationtemplateUpsertWithoutJobvacancyInput = {
    update: XOR<applicationtemplateUpdateWithoutJobvacancyInput, applicationtemplateUncheckedUpdateWithoutJobvacancyInput>
    create: XOR<applicationtemplateCreateWithoutJobvacancyInput, applicationtemplateUncheckedCreateWithoutJobvacancyInput>
    where?: applicationtemplateWhereInput
  }

  export type applicationtemplateUpdateToOneWithWhereWithoutJobvacancyInput = {
    where?: applicationtemplateWhereInput
    data: XOR<applicationtemplateUpdateWithoutJobvacancyInput, applicationtemplateUncheckedUpdateWithoutJobvacancyInput>
  }

  export type applicationtemplateUpdateWithoutJobvacancyInput = {
    Type?: NullableEnumapplicationtemplate_TypeFieldUpdateOperationsInput | $Enums.applicationtemplate_Type | null
    FilePath?: NullableStringFieldUpdateOperationsInput | string | null
    UploadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: adminUpdateOneWithoutApplicationtemplateNestedInput
  }

  export type applicationtemplateUncheckedUpdateWithoutJobvacancyInput = {
    TemplateID?: IntFieldUpdateOperationsInput | number
    Type?: NullableEnumapplicationtemplate_TypeFieldUpdateOperationsInput | $Enums.applicationtemplate_Type | null
    FilePath?: NullableStringFieldUpdateOperationsInput | string | null
    UploadedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UploadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type applicationCreateWithoutLanguageproficienciesInput = {
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoCreateNestedManyWithoutApplicationInput
    user?: userCreateNestedOneWithoutApplicationInput
    jobvacancy?: jobvacancyCreateNestedOneWithoutApplicationInput
    applicationattachments?: applicationattachmentsCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsCreateNestedManyWithoutApplicationInput
  }

  export type applicationUncheckedCreateWithoutLanguageproficienciesInput = {
    ApplicationID?: number
    UserID?: number | null
    JobID?: number | null
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoUncheckedCreateNestedManyWithoutApplicationInput
    applicationattachments?: applicationattachmentsUncheckedCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesUncheckedCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesUncheckedCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsUncheckedCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsUncheckedCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsUncheckedCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsUncheckedCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type applicationCreateOrConnectWithoutLanguageproficienciesInput = {
    where: applicationWhereUniqueInput
    create: XOR<applicationCreateWithoutLanguageproficienciesInput, applicationUncheckedCreateWithoutLanguageproficienciesInput>
  }

  export type applicationUpsertWithoutLanguageproficienciesInput = {
    update: XOR<applicationUpdateWithoutLanguageproficienciesInput, applicationUncheckedUpdateWithoutLanguageproficienciesInput>
    create: XOR<applicationCreateWithoutLanguageproficienciesInput, applicationUncheckedCreateWithoutLanguageproficienciesInput>
    where?: applicationWhereInput
  }

  export type applicationUpdateToOneWithWhereWithoutLanguageproficienciesInput = {
    where?: applicationWhereInput
    data: XOR<applicationUpdateWithoutLanguageproficienciesInput, applicationUncheckedUpdateWithoutLanguageproficienciesInput>
  }

  export type applicationUpdateWithoutLanguageproficienciesInput = {
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUpdateManyWithoutApplicationNestedInput
    user?: userUpdateOneWithoutApplicationNestedInput
    jobvacancy?: jobvacancyUpdateOneWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUpdateManyWithoutApplicationNestedInput
  }

  export type applicationUncheckedUpdateWithoutLanguageproficienciesInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    UserID?: NullableIntFieldUpdateOperationsInput | number | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUncheckedUpdateManyWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUncheckedUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUncheckedUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUncheckedUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUncheckedUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type applicationCreateWithoutProfessionalqualificationsInput = {
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoCreateNestedManyWithoutApplicationInput
    user?: userCreateNestedOneWithoutApplicationInput
    jobvacancy?: jobvacancyCreateNestedOneWithoutApplicationInput
    applicationattachments?: applicationattachmentsCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsCreateNestedManyWithoutApplicationInput
  }

  export type applicationUncheckedCreateWithoutProfessionalqualificationsInput = {
    ApplicationID?: number
    UserID?: number | null
    JobID?: number | null
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoUncheckedCreateNestedManyWithoutApplicationInput
    applicationattachments?: applicationattachmentsUncheckedCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesUncheckedCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesUncheckedCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsUncheckedCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsUncheckedCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsUncheckedCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesUncheckedCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsUncheckedCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type applicationCreateOrConnectWithoutProfessionalqualificationsInput = {
    where: applicationWhereUniqueInput
    create: XOR<applicationCreateWithoutProfessionalqualificationsInput, applicationUncheckedCreateWithoutProfessionalqualificationsInput>
  }

  export type applicationUpsertWithoutProfessionalqualificationsInput = {
    update: XOR<applicationUpdateWithoutProfessionalqualificationsInput, applicationUncheckedUpdateWithoutProfessionalqualificationsInput>
    create: XOR<applicationCreateWithoutProfessionalqualificationsInput, applicationUncheckedCreateWithoutProfessionalqualificationsInput>
    where?: applicationWhereInput
  }

  export type applicationUpdateToOneWithWhereWithoutProfessionalqualificationsInput = {
    where?: applicationWhereInput
    data: XOR<applicationUpdateWithoutProfessionalqualificationsInput, applicationUncheckedUpdateWithoutProfessionalqualificationsInput>
  }

  export type applicationUpdateWithoutProfessionalqualificationsInput = {
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUpdateManyWithoutApplicationNestedInput
    user?: userUpdateOneWithoutApplicationNestedInput
    jobvacancy?: jobvacancyUpdateOneWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUpdateManyWithoutApplicationNestedInput
  }

  export type applicationUncheckedUpdateWithoutProfessionalqualificationsInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    UserID?: NullableIntFieldUpdateOperationsInput | number | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUncheckedUpdateManyWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUncheckedUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUncheckedUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUncheckedUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUncheckedUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUncheckedUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type applicationCreateWithoutResearchandpublicationsInput = {
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoCreateNestedManyWithoutApplicationInput
    user?: userCreateNestedOneWithoutApplicationInput
    jobvacancy?: jobvacancyCreateNestedOneWithoutApplicationInput
    applicationattachments?: applicationattachmentsCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsCreateNestedManyWithoutApplicationInput
  }

  export type applicationUncheckedCreateWithoutResearchandpublicationsInput = {
    ApplicationID?: number
    UserID?: number | null
    JobID?: number | null
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoUncheckedCreateNestedManyWithoutApplicationInput
    applicationattachments?: applicationattachmentsUncheckedCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesUncheckedCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesUncheckedCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsUncheckedCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsUncheckedCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsUncheckedCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesUncheckedCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type applicationCreateOrConnectWithoutResearchandpublicationsInput = {
    where: applicationWhereUniqueInput
    create: XOR<applicationCreateWithoutResearchandpublicationsInput, applicationUncheckedCreateWithoutResearchandpublicationsInput>
  }

  export type applicationUpsertWithoutResearchandpublicationsInput = {
    update: XOR<applicationUpdateWithoutResearchandpublicationsInput, applicationUncheckedUpdateWithoutResearchandpublicationsInput>
    create: XOR<applicationCreateWithoutResearchandpublicationsInput, applicationUncheckedCreateWithoutResearchandpublicationsInput>
    where?: applicationWhereInput
  }

  export type applicationUpdateToOneWithWhereWithoutResearchandpublicationsInput = {
    where?: applicationWhereInput
    data: XOR<applicationUpdateWithoutResearchandpublicationsInput, applicationUncheckedUpdateWithoutResearchandpublicationsInput>
  }

  export type applicationUpdateWithoutResearchandpublicationsInput = {
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUpdateManyWithoutApplicationNestedInput
    user?: userUpdateOneWithoutApplicationNestedInput
    jobvacancy?: jobvacancyUpdateOneWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUpdateManyWithoutApplicationNestedInput
  }

  export type applicationUncheckedUpdateWithoutResearchandpublicationsInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    UserID?: NullableIntFieldUpdateOperationsInput | number | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUncheckedUpdateManyWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUncheckedUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUncheckedUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUncheckedUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUncheckedUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type applicationCreateWithoutSpecialqualificationsInput = {
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoCreateNestedManyWithoutApplicationInput
    user?: userCreateNestedOneWithoutApplicationInput
    jobvacancy?: jobvacancyCreateNestedOneWithoutApplicationInput
    applicationattachments?: applicationattachmentsCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsCreateNestedManyWithoutApplicationInput
  }

  export type applicationUncheckedCreateWithoutSpecialqualificationsInput = {
    ApplicationID?: number
    UserID?: number | null
    JobID?: number | null
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoUncheckedCreateNestedManyWithoutApplicationInput
    applicationattachments?: applicationattachmentsUncheckedCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesUncheckedCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesUncheckedCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsUncheckedCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsUncheckedCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsUncheckedCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesUncheckedCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsUncheckedCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type applicationCreateOrConnectWithoutSpecialqualificationsInput = {
    where: applicationWhereUniqueInput
    create: XOR<applicationCreateWithoutSpecialqualificationsInput, applicationUncheckedCreateWithoutSpecialqualificationsInput>
  }

  export type applicationUpsertWithoutSpecialqualificationsInput = {
    update: XOR<applicationUpdateWithoutSpecialqualificationsInput, applicationUncheckedUpdateWithoutSpecialqualificationsInput>
    create: XOR<applicationCreateWithoutSpecialqualificationsInput, applicationUncheckedCreateWithoutSpecialqualificationsInput>
    where?: applicationWhereInput
  }

  export type applicationUpdateToOneWithWhereWithoutSpecialqualificationsInput = {
    where?: applicationWhereInput
    data: XOR<applicationUpdateWithoutSpecialqualificationsInput, applicationUncheckedUpdateWithoutSpecialqualificationsInput>
  }

  export type applicationUpdateWithoutSpecialqualificationsInput = {
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUpdateManyWithoutApplicationNestedInput
    user?: userUpdateOneWithoutApplicationNestedInput
    jobvacancy?: jobvacancyUpdateOneWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUpdateManyWithoutApplicationNestedInput
  }

  export type applicationUncheckedUpdateWithoutSpecialqualificationsInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    UserID?: NullableIntFieldUpdateOperationsInput | number | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUncheckedUpdateManyWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUncheckedUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUncheckedUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUncheckedUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUncheckedUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUncheckedUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type applicationCreateWithoutUniversityeducationsInput = {
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoCreateNestedManyWithoutApplicationInput
    user?: userCreateNestedOneWithoutApplicationInput
    jobvacancy?: jobvacancyCreateNestedOneWithoutApplicationInput
    applicationattachments?: applicationattachmentsCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsCreateNestedManyWithoutApplicationInput
  }

  export type applicationUncheckedCreateWithoutUniversityeducationsInput = {
    ApplicationID?: number
    UserID?: number | null
    JobID?: number | null
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoUncheckedCreateNestedManyWithoutApplicationInput
    applicationattachments?: applicationattachmentsUncheckedCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesUncheckedCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesUncheckedCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsUncheckedCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsUncheckedCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsUncheckedCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesUncheckedCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsUncheckedCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type applicationCreateOrConnectWithoutUniversityeducationsInput = {
    where: applicationWhereUniqueInput
    create: XOR<applicationCreateWithoutUniversityeducationsInput, applicationUncheckedCreateWithoutUniversityeducationsInput>
  }

  export type applicationUpsertWithoutUniversityeducationsInput = {
    update: XOR<applicationUpdateWithoutUniversityeducationsInput, applicationUncheckedUpdateWithoutUniversityeducationsInput>
    create: XOR<applicationCreateWithoutUniversityeducationsInput, applicationUncheckedCreateWithoutUniversityeducationsInput>
    where?: applicationWhereInput
  }

  export type applicationUpdateToOneWithWhereWithoutUniversityeducationsInput = {
    where?: applicationWhereInput
    data: XOR<applicationUpdateWithoutUniversityeducationsInput, applicationUncheckedUpdateWithoutUniversityeducationsInput>
  }

  export type applicationUpdateWithoutUniversityeducationsInput = {
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUpdateManyWithoutApplicationNestedInput
    user?: userUpdateOneWithoutApplicationNestedInput
    jobvacancy?: jobvacancyUpdateOneWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUpdateManyWithoutApplicationNestedInput
  }

  export type applicationUncheckedUpdateWithoutUniversityeducationsInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    UserID?: NullableIntFieldUpdateOperationsInput | number | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUncheckedUpdateManyWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUncheckedUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUncheckedUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUncheckedUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUncheckedUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUncheckedUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type applicationCreateWithoutUserInput = {
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoCreateNestedManyWithoutApplicationInput
    jobvacancy?: jobvacancyCreateNestedOneWithoutApplicationInput
    applicationattachments?: applicationattachmentsCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsCreateNestedManyWithoutApplicationInput
  }

  export type applicationUncheckedCreateWithoutUserInput = {
    ApplicationID?: number
    JobID?: number | null
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
    additionalinfo?: additionalinfoUncheckedCreateNestedManyWithoutApplicationInput
    applicationattachments?: applicationattachmentsUncheckedCreateNestedManyWithoutApplicationInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedCreateNestedOneWithoutApplicationInput
    applicationreferences?: applicationreferencesUncheckedCreateNestedManyWithoutApplicationInput
    employmenthistories?: employmenthistoriesUncheckedCreateNestedManyWithoutApplicationInput
    experiencedetails?: experiencedetailsUncheckedCreateNestedManyWithoutApplicationInput
    gce_al_results?: gce_al_resultsUncheckedCreateNestedManyWithoutApplicationInput
    gce_ol_results?: gce_ol_resultsUncheckedCreateNestedManyWithoutApplicationInput
    languageproficiencies?: languageproficienciesUncheckedCreateNestedManyWithoutApplicationInput
    professionalqualifications?: professionalqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    researchandpublications?: researchandpublicationsUncheckedCreateNestedManyWithoutApplicationInput
    specialqualifications?: specialqualificationsUncheckedCreateNestedManyWithoutApplicationInput
    universityeducations?: universityeducationsUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type applicationCreateOrConnectWithoutUserInput = {
    where: applicationWhereUniqueInput
    create: XOR<applicationCreateWithoutUserInput, applicationUncheckedCreateWithoutUserInput>
  }

  export type applicationCreateManyUserInputEnvelope = {
    data: applicationCreateManyUserInput | applicationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type applicationUpsertWithWhereUniqueWithoutUserInput = {
    where: applicationWhereUniqueInput
    update: XOR<applicationUpdateWithoutUserInput, applicationUncheckedUpdateWithoutUserInput>
    create: XOR<applicationCreateWithoutUserInput, applicationUncheckedCreateWithoutUserInput>
  }

  export type applicationUpdateWithWhereUniqueWithoutUserInput = {
    where: applicationWhereUniqueInput
    data: XOR<applicationUpdateWithoutUserInput, applicationUncheckedUpdateWithoutUserInput>
  }

  export type applicationUpdateManyWithWhereWithoutUserInput = {
    where: applicationScalarWhereInput
    data: XOR<applicationUpdateManyMutationInput, applicationUncheckedUpdateManyWithoutUserInput>
  }

  export type applicationtemplateCreateManyAdminInput = {
    TemplateID?: number
    Type?: $Enums.applicationtemplate_Type | null
    FilePath?: string | null
    UploadDate?: Date | string | null
  }

  export type jobvacancyCreateManyAdminInput = {
    JobID?: number
    Title?: string | null
    Description?: string | null
    Type?: $Enums.jobvacancy_Type | null
    Department?: string | null
    Level?: string | null
    PostedDate?: Date | string | null
    ExpiryDate?: Date | string | null
    Status?: $Enums.jobvacancy_Status | null
    TemplateID?: number | null
  }

  export type applicationtemplateUpdateWithoutAdminInput = {
    Type?: NullableEnumapplicationtemplate_TypeFieldUpdateOperationsInput | $Enums.applicationtemplate_Type | null
    FilePath?: NullableStringFieldUpdateOperationsInput | string | null
    UploadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobvacancy?: jobvacancyUpdateManyWithoutApplicationtemplateNestedInput
  }

  export type applicationtemplateUncheckedUpdateWithoutAdminInput = {
    TemplateID?: IntFieldUpdateOperationsInput | number
    Type?: NullableEnumapplicationtemplate_TypeFieldUpdateOperationsInput | $Enums.applicationtemplate_Type | null
    FilePath?: NullableStringFieldUpdateOperationsInput | string | null
    UploadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobvacancy?: jobvacancyUncheckedUpdateManyWithoutApplicationtemplateNestedInput
  }

  export type applicationtemplateUncheckedUpdateManyWithoutAdminInput = {
    TemplateID?: IntFieldUpdateOperationsInput | number
    Type?: NullableEnumapplicationtemplate_TypeFieldUpdateOperationsInput | $Enums.applicationtemplate_Type | null
    FilePath?: NullableStringFieldUpdateOperationsInput | string | null
    UploadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type jobvacancyUpdateWithoutAdminInput = {
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableEnumjobvacancy_TypeFieldUpdateOperationsInput | $Enums.jobvacancy_Type | null
    Department?: NullableStringFieldUpdateOperationsInput | string | null
    Level?: NullableStringFieldUpdateOperationsInput | string | null
    PostedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumjobvacancy_StatusFieldUpdateOperationsInput | $Enums.jobvacancy_Status | null
    application?: applicationUpdateManyWithoutJobvacancyNestedInput
    applicationtemplate?: applicationtemplateUpdateOneWithoutJobvacancyNestedInput
  }

  export type jobvacancyUncheckedUpdateWithoutAdminInput = {
    JobID?: IntFieldUpdateOperationsInput | number
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableEnumjobvacancy_TypeFieldUpdateOperationsInput | $Enums.jobvacancy_Type | null
    Department?: NullableStringFieldUpdateOperationsInput | string | null
    Level?: NullableStringFieldUpdateOperationsInput | string | null
    PostedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumjobvacancy_StatusFieldUpdateOperationsInput | $Enums.jobvacancy_Status | null
    TemplateID?: NullableIntFieldUpdateOperationsInput | number | null
    application?: applicationUncheckedUpdateManyWithoutJobvacancyNestedInput
  }

  export type jobvacancyUncheckedUpdateManyWithoutAdminInput = {
    JobID?: IntFieldUpdateOperationsInput | number
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableEnumjobvacancy_TypeFieldUpdateOperationsInput | $Enums.jobvacancy_Type | null
    Department?: NullableStringFieldUpdateOperationsInput | string | null
    Level?: NullableStringFieldUpdateOperationsInput | string | null
    PostedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumjobvacancy_StatusFieldUpdateOperationsInput | $Enums.jobvacancy_Status | null
    TemplateID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type additionalinfoCreateManyApplicationInput = {
    InfoID?: number
    Content?: string | null
  }

  export type applicationattachmentsCreateManyApplicationInput = {
    AttachmentID?: number
    FileType?: string | null
    FilePath?: string | null
    UploadedAt?: Date | string | null
  }

  export type applicationreferencesCreateManyApplicationInput = {
    ReferenceID?: number
    Name?: string | null
    Designation?: string | null
    Address?: string | null
  }

  export type employmenthistoriesCreateManyApplicationInput = {
    EmploymentID?: number
    PostHeld?: string | null
    Institution?: string | null
    FromDate?: Date | string | null
    ToDate?: Date | string | null
    LastSalary?: Decimal | DecimalJsLike | number | string | null
  }

  export type experiencedetailsCreateManyApplicationInput = {
    ExperienceID?: number
    Description?: string | null
  }

  export type gce_al_resultsCreateManyApplicationInput = {
    AL_ID?: number
    Subject?: string | null
    Grade?: string | null
  }

  export type gce_ol_resultsCreateManyApplicationInput = {
    OL_ID?: number
    Subject?: string | null
    Grade?: string | null
  }

  export type languageproficienciesCreateManyApplicationInput = {
    LangProfID?: number
    Language?: string | null
    CanSpeak?: $Enums.languageproficiencies_CanSpeak | null
    CanRead?: $Enums.languageproficiencies_CanRead | null
    CanWrite?: $Enums.languageproficiencies_CanWrite | null
    CanTeach?: $Enums.languageproficiencies_CanTeach | null
  }

  export type professionalqualificationsCreateManyApplicationInput = {
    PQ_ID?: number
    Institution?: string | null
    QualificationName?: string | null
    FromYear?: number | null
    ToYear?: number | null
    ResultOrExamPassed?: string | null
  }

  export type researchandpublicationsCreateManyApplicationInput = {
    ResearchID?: number
    Description?: string | null
  }

  export type specialqualificationsCreateManyApplicationInput = {
    SpecialQualID?: number
    Description?: string | null
  }

  export type universityeducationsCreateManyApplicationInput = {
    UE_ID?: number
    DegreeOrDiploma?: string | null
    Institute?: string | null
    FromYear?: number | null
    ToYear?: number | null
    Class?: string | null
    YearObtained?: number | null
    IndexNumber?: string | null
  }

  export type additionalinfoUpdateWithoutApplicationInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type additionalinfoUncheckedUpdateWithoutApplicationInput = {
    InfoID?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type additionalinfoUncheckedUpdateManyWithoutApplicationInput = {
    InfoID?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type applicationattachmentsUpdateWithoutApplicationInput = {
    FileType?: NullableStringFieldUpdateOperationsInput | string | null
    FilePath?: NullableStringFieldUpdateOperationsInput | string | null
    UploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type applicationattachmentsUncheckedUpdateWithoutApplicationInput = {
    AttachmentID?: IntFieldUpdateOperationsInput | number
    FileType?: NullableStringFieldUpdateOperationsInput | string | null
    FilePath?: NullableStringFieldUpdateOperationsInput | string | null
    UploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type applicationattachmentsUncheckedUpdateManyWithoutApplicationInput = {
    AttachmentID?: IntFieldUpdateOperationsInput | number
    FileType?: NullableStringFieldUpdateOperationsInput | string | null
    FilePath?: NullableStringFieldUpdateOperationsInput | string | null
    UploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type applicationreferencesUpdateWithoutApplicationInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Designation?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type applicationreferencesUncheckedUpdateWithoutApplicationInput = {
    ReferenceID?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Designation?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type applicationreferencesUncheckedUpdateManyWithoutApplicationInput = {
    ReferenceID?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Designation?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type employmenthistoriesUpdateWithoutApplicationInput = {
    PostHeld?: NullableStringFieldUpdateOperationsInput | string | null
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
    FromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type employmenthistoriesUncheckedUpdateWithoutApplicationInput = {
    EmploymentID?: IntFieldUpdateOperationsInput | number
    PostHeld?: NullableStringFieldUpdateOperationsInput | string | null
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
    FromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type employmenthistoriesUncheckedUpdateManyWithoutApplicationInput = {
    EmploymentID?: IntFieldUpdateOperationsInput | number
    PostHeld?: NullableStringFieldUpdateOperationsInput | string | null
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
    FromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type experiencedetailsUpdateWithoutApplicationInput = {
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type experiencedetailsUncheckedUpdateWithoutApplicationInput = {
    ExperienceID?: IntFieldUpdateOperationsInput | number
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type experiencedetailsUncheckedUpdateManyWithoutApplicationInput = {
    ExperienceID?: IntFieldUpdateOperationsInput | number
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gce_al_resultsUpdateWithoutApplicationInput = {
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gce_al_resultsUncheckedUpdateWithoutApplicationInput = {
    AL_ID?: IntFieldUpdateOperationsInput | number
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gce_al_resultsUncheckedUpdateManyWithoutApplicationInput = {
    AL_ID?: IntFieldUpdateOperationsInput | number
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gce_ol_resultsUpdateWithoutApplicationInput = {
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gce_ol_resultsUncheckedUpdateWithoutApplicationInput = {
    OL_ID?: IntFieldUpdateOperationsInput | number
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gce_ol_resultsUncheckedUpdateManyWithoutApplicationInput = {
    OL_ID?: IntFieldUpdateOperationsInput | number
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    Grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type languageproficienciesUpdateWithoutApplicationInput = {
    Language?: NullableStringFieldUpdateOperationsInput | string | null
    CanSpeak?: NullableEnumlanguageproficiencies_CanSpeakFieldUpdateOperationsInput | $Enums.languageproficiencies_CanSpeak | null
    CanRead?: NullableEnumlanguageproficiencies_CanReadFieldUpdateOperationsInput | $Enums.languageproficiencies_CanRead | null
    CanWrite?: NullableEnumlanguageproficiencies_CanWriteFieldUpdateOperationsInput | $Enums.languageproficiencies_CanWrite | null
    CanTeach?: NullableEnumlanguageproficiencies_CanTeachFieldUpdateOperationsInput | $Enums.languageproficiencies_CanTeach | null
  }

  export type languageproficienciesUncheckedUpdateWithoutApplicationInput = {
    LangProfID?: IntFieldUpdateOperationsInput | number
    Language?: NullableStringFieldUpdateOperationsInput | string | null
    CanSpeak?: NullableEnumlanguageproficiencies_CanSpeakFieldUpdateOperationsInput | $Enums.languageproficiencies_CanSpeak | null
    CanRead?: NullableEnumlanguageproficiencies_CanReadFieldUpdateOperationsInput | $Enums.languageproficiencies_CanRead | null
    CanWrite?: NullableEnumlanguageproficiencies_CanWriteFieldUpdateOperationsInput | $Enums.languageproficiencies_CanWrite | null
    CanTeach?: NullableEnumlanguageproficiencies_CanTeachFieldUpdateOperationsInput | $Enums.languageproficiencies_CanTeach | null
  }

  export type languageproficienciesUncheckedUpdateManyWithoutApplicationInput = {
    LangProfID?: IntFieldUpdateOperationsInput | number
    Language?: NullableStringFieldUpdateOperationsInput | string | null
    CanSpeak?: NullableEnumlanguageproficiencies_CanSpeakFieldUpdateOperationsInput | $Enums.languageproficiencies_CanSpeak | null
    CanRead?: NullableEnumlanguageproficiencies_CanReadFieldUpdateOperationsInput | $Enums.languageproficiencies_CanRead | null
    CanWrite?: NullableEnumlanguageproficiencies_CanWriteFieldUpdateOperationsInput | $Enums.languageproficiencies_CanWrite | null
    CanTeach?: NullableEnumlanguageproficiencies_CanTeachFieldUpdateOperationsInput | $Enums.languageproficiencies_CanTeach | null
  }

  export type professionalqualificationsUpdateWithoutApplicationInput = {
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
    QualificationName?: NullableStringFieldUpdateOperationsInput | string | null
    FromYear?: NullableIntFieldUpdateOperationsInput | number | null
    ToYear?: NullableIntFieldUpdateOperationsInput | number | null
    ResultOrExamPassed?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type professionalqualificationsUncheckedUpdateWithoutApplicationInput = {
    PQ_ID?: IntFieldUpdateOperationsInput | number
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
    QualificationName?: NullableStringFieldUpdateOperationsInput | string | null
    FromYear?: NullableIntFieldUpdateOperationsInput | number | null
    ToYear?: NullableIntFieldUpdateOperationsInput | number | null
    ResultOrExamPassed?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type professionalqualificationsUncheckedUpdateManyWithoutApplicationInput = {
    PQ_ID?: IntFieldUpdateOperationsInput | number
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
    QualificationName?: NullableStringFieldUpdateOperationsInput | string | null
    FromYear?: NullableIntFieldUpdateOperationsInput | number | null
    ToYear?: NullableIntFieldUpdateOperationsInput | number | null
    ResultOrExamPassed?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type researchandpublicationsUpdateWithoutApplicationInput = {
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type researchandpublicationsUncheckedUpdateWithoutApplicationInput = {
    ResearchID?: IntFieldUpdateOperationsInput | number
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type researchandpublicationsUncheckedUpdateManyWithoutApplicationInput = {
    ResearchID?: IntFieldUpdateOperationsInput | number
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type specialqualificationsUpdateWithoutApplicationInput = {
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type specialqualificationsUncheckedUpdateWithoutApplicationInput = {
    SpecialQualID?: IntFieldUpdateOperationsInput | number
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type specialqualificationsUncheckedUpdateManyWithoutApplicationInput = {
    SpecialQualID?: IntFieldUpdateOperationsInput | number
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type universityeducationsUpdateWithoutApplicationInput = {
    DegreeOrDiploma?: NullableStringFieldUpdateOperationsInput | string | null
    Institute?: NullableStringFieldUpdateOperationsInput | string | null
    FromYear?: NullableIntFieldUpdateOperationsInput | number | null
    ToYear?: NullableIntFieldUpdateOperationsInput | number | null
    Class?: NullableStringFieldUpdateOperationsInput | string | null
    YearObtained?: NullableIntFieldUpdateOperationsInput | number | null
    IndexNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type universityeducationsUncheckedUpdateWithoutApplicationInput = {
    UE_ID?: IntFieldUpdateOperationsInput | number
    DegreeOrDiploma?: NullableStringFieldUpdateOperationsInput | string | null
    Institute?: NullableStringFieldUpdateOperationsInput | string | null
    FromYear?: NullableIntFieldUpdateOperationsInput | number | null
    ToYear?: NullableIntFieldUpdateOperationsInput | number | null
    Class?: NullableStringFieldUpdateOperationsInput | string | null
    YearObtained?: NullableIntFieldUpdateOperationsInput | number | null
    IndexNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type universityeducationsUncheckedUpdateManyWithoutApplicationInput = {
    UE_ID?: IntFieldUpdateOperationsInput | number
    DegreeOrDiploma?: NullableStringFieldUpdateOperationsInput | string | null
    Institute?: NullableStringFieldUpdateOperationsInput | string | null
    FromYear?: NullableIntFieldUpdateOperationsInput | number | null
    ToYear?: NullableIntFieldUpdateOperationsInput | number | null
    Class?: NullableStringFieldUpdateOperationsInput | string | null
    YearObtained?: NullableIntFieldUpdateOperationsInput | number | null
    IndexNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type jobvacancyCreateManyApplicationtemplateInput = {
    JobID?: number
    Title?: string | null
    Description?: string | null
    Type?: $Enums.jobvacancy_Type | null
    Department?: string | null
    Level?: string | null
    PostedBy?: number | null
    PostedDate?: Date | string | null
    ExpiryDate?: Date | string | null
    Status?: $Enums.jobvacancy_Status | null
  }

  export type jobvacancyUpdateWithoutApplicationtemplateInput = {
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableEnumjobvacancy_TypeFieldUpdateOperationsInput | $Enums.jobvacancy_Type | null
    Department?: NullableStringFieldUpdateOperationsInput | string | null
    Level?: NullableStringFieldUpdateOperationsInput | string | null
    PostedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumjobvacancy_StatusFieldUpdateOperationsInput | $Enums.jobvacancy_Status | null
    application?: applicationUpdateManyWithoutJobvacancyNestedInput
    admin?: adminUpdateOneWithoutJobvacancyNestedInput
  }

  export type jobvacancyUncheckedUpdateWithoutApplicationtemplateInput = {
    JobID?: IntFieldUpdateOperationsInput | number
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableEnumjobvacancy_TypeFieldUpdateOperationsInput | $Enums.jobvacancy_Type | null
    Department?: NullableStringFieldUpdateOperationsInput | string | null
    Level?: NullableStringFieldUpdateOperationsInput | string | null
    PostedBy?: NullableIntFieldUpdateOperationsInput | number | null
    PostedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumjobvacancy_StatusFieldUpdateOperationsInput | $Enums.jobvacancy_Status | null
    application?: applicationUncheckedUpdateManyWithoutJobvacancyNestedInput
  }

  export type jobvacancyUncheckedUpdateManyWithoutApplicationtemplateInput = {
    JobID?: IntFieldUpdateOperationsInput | number
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableEnumjobvacancy_TypeFieldUpdateOperationsInput | $Enums.jobvacancy_Type | null
    Department?: NullableStringFieldUpdateOperationsInput | string | null
    Level?: NullableStringFieldUpdateOperationsInput | string | null
    PostedBy?: NullableIntFieldUpdateOperationsInput | number | null
    PostedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumjobvacancy_StatusFieldUpdateOperationsInput | $Enums.jobvacancy_Status | null
  }

  export type applicationCreateManyJobvacancyInput = {
    ApplicationID?: number
    UserID?: number | null
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
  }

  export type applicationUpdateWithoutJobvacancyInput = {
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUpdateManyWithoutApplicationNestedInput
    user?: userUpdateOneWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUpdateManyWithoutApplicationNestedInput
  }

  export type applicationUncheckedUpdateWithoutJobvacancyInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    UserID?: NullableIntFieldUpdateOperationsInput | number | null
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUncheckedUpdateManyWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUncheckedUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUncheckedUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUncheckedUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUncheckedUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUncheckedUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type applicationUncheckedUpdateManyWithoutJobvacancyInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    UserID?: NullableIntFieldUpdateOperationsInput | number | null
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type applicationCreateManyUserInput = {
    ApplicationID?: number
    JobID?: number | null
    SubmissionDate?: Date | string | null
    Status?: $Enums.application_Status | null
    Remarks?: string | null
  }

  export type applicationUpdateWithoutUserInput = {
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUpdateManyWithoutApplicationNestedInput
    jobvacancy?: jobvacancyUpdateOneWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUpdateManyWithoutApplicationNestedInput
  }

  export type applicationUncheckedUpdateWithoutUserInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    additionalinfo?: additionalinfoUncheckedUpdateManyWithoutApplicationNestedInput
    applicationattachments?: applicationattachmentsUncheckedUpdateManyWithoutApplicationNestedInput
    applicationgeneraldetails?: applicationgeneraldetailsUncheckedUpdateOneWithoutApplicationNestedInput
    applicationreferences?: applicationreferencesUncheckedUpdateManyWithoutApplicationNestedInput
    employmenthistories?: employmenthistoriesUncheckedUpdateManyWithoutApplicationNestedInput
    experiencedetails?: experiencedetailsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_al_results?: gce_al_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    gce_ol_results?: gce_ol_resultsUncheckedUpdateManyWithoutApplicationNestedInput
    languageproficiencies?: languageproficienciesUncheckedUpdateManyWithoutApplicationNestedInput
    professionalqualifications?: professionalqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    researchandpublications?: researchandpublicationsUncheckedUpdateManyWithoutApplicationNestedInput
    specialqualifications?: specialqualificationsUncheckedUpdateManyWithoutApplicationNestedInput
    universityeducations?: universityeducationsUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type applicationUncheckedUpdateManyWithoutUserInput = {
    ApplicationID?: IntFieldUpdateOperationsInput | number
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    SubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableEnumapplication_StatusFieldUpdateOperationsInput | $Enums.application_Status | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}